{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"the Software Development Kit for neutral atom quantum computers <p>Bloqade is QuEra Computing's software development kit (SDK) for neutral atom quantum computers. It is designed to be a hub of embedded domain-specific languages (eDSLs) for neutral atom quantum computing. Bloqade is built on top of Kirin, the Kernel Intermediate Representation Infrastructure.</p> <p>Warning</p> <p>Bloqade is currently in the early stages of development. The APIs and features are subject to change. While we do not promise stability and backward compatibility at the moment, we will try to minimize breaking changes as much as possible. If you are concerned about the stability of the APIs, consider pin the version of Bloqade in your project.</p> <p>Info</p> <p>The old version (&lt;= 0.15) of Bloqade is still available as a sub-package <code>bloqade-analog</code>. You can keep using it via <code>bloqade.analog</code> module. For example <code>from bloqade import start</code> becomes <code>from bloqade.analog import start</code>. See Installation for more information.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install Bloqade, you can use the following command:</p> <pre><code>pip install bloqade\n</code></pre> <p>To install the extensions or extras for Bloqade and to setup the development environment, please refer to the installation guide.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with Bloqade, you can refer to the following tutorials:</p> <ul> <li>Background: Background information on neutral atom quantum computing.</li> <li>Digital quick start: A quick start guide on writing digital circuits.</li> <li>Analog quick start: A quick start guide for the analog quantum computing eDSL (same as older <code>bloqade</code> versions).</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to Bloqade. Please refer to the contribution guide for more information.</p>"},{"location":"#license","title":"License","text":"<p>Bloqade is licensed under the Apache License 2.0.</p>"},{"location":"background/","title":"Background","text":""},{"location":"background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>A key feature of a quantum computer is the ability to physically represent qubits. In neutral atom computers, the qubit is represented in the electronic state of the valence electron of Rubdidium 87. Arrays of individual atoms are held by laser tweezers, and quantum computations are executed by manipulating the electronic state of each atom using lasers and RF fields. Entanglement can be generated using the Rydberg state, which is a highly excited state that strongly interacts with adjacent atoms through a \\(R^{-6}\\) power law Van der Waals force.</p>"},{"location":"background/#analog-mode-quantum-computing","title":"Analog mode Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital. In analog mode, the qubit is represented as in a ground state and a Rydberg state of an atom. The atoms are placed in user-specified arbitrary positions in a 2d space, and quantum computations can be enacted by driving the atoms between the ground and Rydberg state. However, adjacent atoms in the Rydberg state are always interacting, so the computation is done through a time evolution of the atoms via the Schrodinger equation</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] <p>Were \\(H\\) is a time-dependent \"Rydberg atom\" Hamiltonian.</p> \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p> <p>For a more nuanced read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing. For more details on QuEra's cloud-accessible analog mode computer Aquila, please check out the Aquila whitepaper.</p>"},{"location":"background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). The digital mode qubit is represented in the two hyperfine clock ground states of the Rubidium 87 atom. These two states are extremely weakly interactive with the environment and other adjacent atoms, which leads to a very long coherence time upwards of 1 second. Single-qubit gates can be executed through a Raman laser drive coupling the two states to enact arbitrary rotations.</p> <p>Unlike Analog mode where the Rydberg state is persistent as part of the qubit encoding into the electronic states, digital mode only temporarily excites the atoms to the Rydberg state in order to interact with adjacent qubits, a process which typically takes less than ~1usec. Thus, a neutral atom entangling gate is executed by bringing multiple atoms together within the Rydberg blockade radius, and then doing some time-dependent drive between the hyperfine ground states and the Rydberg state, so that the final state returns to the hyperfine ground states. Due to the Rydberg blockade, only one atom can be in the Rydberg state at a time, which creates entanglement between the atoms. For more details see this paper on a recent demonstration of high fidelity gates.</p> <p>A unique advantage of reconfigurable neutral atom architectures is parallelism: the same laser can effect many lasers by aiming it in the same plane as the atom array. A single global Raman laser can enact the same parallel single-qubit gate on all qubits at the same time, and a single Rydberg laser (technically, two counter-propagating) can enact the same parallel multi-qubit gate on all cliques of qubits in an entangling region of the array. For more details see this paper on a recent demonstration of reconfigurable architectures. For this reason, it is important to represent quantum executions and circuits to be as parallel as possible. In our qasm2 dialect, we have extended qasm to natively include parallelism-- for example, <code>qasm2.parallel.cx(controls, targets)</code> represents a parallel CNOT gate between a list of <code>controls</code> on a list of <code>targets</code>.</p>"},{"location":"background/#reconfigurable-architectures-and-all-to-all-connectivity","title":"Reconfigurable architectures and \"all to all\" connectivity","text":"<p>A second advantage of reconfigurable neutral atom architectures is reconfigurability: atoms can be moved in parallel between sites in the array. QuEra's devices will have a zoned architecture, with distinct storage and entanglement zones and the ability to move atoms between them using a set of dynamic crossed AOD laser tweezers. This mobility can be considered as an efficient parallel swap gate, where any qubit can easily be moved to be adjacent to any other to enact entangling gates. For this reason, reconfigurable neutral atoms do not have a \"connectivity graph\" in the traditional sense-- instead, they have an \"all-to-all\" connectivity. There are still some technical constraints on this connectivity due to restrictions on the crossed AOD which we will detail when we open-source a move level dialect set in the near future.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"install/","title":"Installation","text":"<p>Bloqade is compatible with Python 3.10+ and available on PyPI. You can install it via <code>pip</code> into your environment:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"install/#bloqade-and-its-friends","title":"Bloqade and its friends","text":"<p>Bloqade is a Python namespace package, we officially provide several sub-packages, each of which is an eDSL for neutral atom quantum computing. The following is a list of the sub-packages in Bloqade:</p> <p>Note</p> <p>If you have already installed Bloqade via the instructions above, all the following subpckages are already installed with the exception of the <code>stim</code> eDSL which is currently experimental.</p>"},{"location":"install/#bloqadeqasm2","title":"<code>bloqade.qasm2</code>","text":"<p>QASM2 and its extensions support for neutral atom quantum computing. Available via:</p> <pre><code>pip install bloqade[qasm2]\n</code></pre>"},{"location":"install/#bloqadeanalog","title":"<code>bloqade.analog</code>","text":"<p>Analog quantum computing eDSL for neutral atom quantum computing (previously <code>bloqade-python</code>). Available via:</p> <pre><code>pip install bloqade-analog\n</code></pre>"},{"location":"install/#bloqadeqbraid","title":"<code>bloqade.qbraid</code>","text":"<p>Support of the qBraid cloud service as a runtime backend for retrieving noise models and running circuits.</p> <pre><code>pip install bloqade[qbraid]\n</code></pre>"},{"location":"install/#bloqadestim-experimental","title":"<code>bloqade.stim</code> (Experimental)","text":"<p>Stim and its extensions support for neutral atom quantum computing. Available via:</p> <pre><code>pip install bloqade[stim]\n</code></pre>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Bloqade, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/bloqade.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment.</p> <p>You can install <code>uv</code> via the following:</p> Linux and macOS <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>=== </p> <pre><code>```cmd\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n```\n</code></pre> <p>Then you can install the development dependencies executing one of the following commands:</p> <pre><code># For contributing to code\nuv sync --group dev\n# For contributions to documentation\nuv sync --group doc\n# For just getting everything mentioned above\nuv sync --all-groups\n</code></pre> <p>Our code review requires that you pass the tests and linting checks. We recommend you install <code>pre-commit</code> to run the checks before you commit your changes.  <code>pre-commit</code> is already specified as a development dependency for bloqade and once installed,  you can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"manifesto/","title":"Bloqade Manifesto","text":"<p>The vision of Bloqade is to empower quantum scientists, from applications development to algorithmic co-design, to build hybrid quantum-classical programs that leverage the strength of neutral atom quantum computers and have a real chance of demonstrating quantum utility. Bloqade is built on top of Kirin, an open source compiler infrastructure designed for kernel functions and composable representations.</p>"},{"location":"manifesto/#composable-quantum-programming","title":"Composable quantum programming","text":"<p>Today Bloqade becomes a namespace package of multiple eDSLs (embedded domain-specific languages) around digital and analog quantum computation. <code>bloqade.analog</code> is the module for analog-mode neutral atom computers and includes several handy utilities ranging from building or analyzing analog programs, to emulation or executing on QuEra's cloud-accessible hardware \"Aquila\".</p> <p>Other submodules such as <code>bloqade.qasm2</code>, <code>bloqade.pyqrack</code> and <code>bloqade.stim</code> are the initial iteration to represent digital circuit execution using gate-based quantum computing on reconfigurable neutral atoms. It extends the QASM2 language to include extra annotation of circuits that is important for efficient execution, such as parallelism and global gates. As well as being able to construct quantum programs with the full convenience of typical classical programming within hardware kernels -- such as loops and control flow -- Bloqade also includes basic compiler transformation passes, emulation, and code generation.</p> <p>But Bloqade is not done with just these modules. We envision adding new modules (called \"dialects\") which help you write programs which are tuned for optimal performance in an error corrected era, and on neutral atom hardware. Stay tuned and help us build the future of quantum computing as we build out new components, such as QEC and atom moving dialects.</p>"},{"location":"manifesto/#hardware-oriented-programming-and-co-design","title":"Hardware-oriented programming and co-design","text":"<p>At its core, Bloqade strives to be the neutral atom SDK for getting the most out of today's and tomorrows' quantum hardware. It is clear that the circuit-level abstraction is not enough to program real quantum hardware; indeed, tomorrows' quantum demonstrations and applications must program at the hardware level and develop special tooling to compile higher-level abstractions to efficient implementations. We call this process \"co-design\": designing algorithms specialized to near-term hardware, with an eye on nontrivial demonstrations and scalable solutions. Ultimately, this co-design approach requires hardware-specific DSLs which explicitly represent the native executions on neutral atom hardware: in other words, Bloqade.</p>"},{"location":"manifesto/#hybrid-computing-beyond-circuits","title":"Hybrid computing beyond circuits","text":"<p>Many quantum algorithms are hybrid, requiring both classical and quantum resources to work together in a hybrid computation architecture. This could be anything from syndrome extraction and measurement-based computing to variational parameter updates in VQE methods and orbital fragmentation methods in molecular simulation. Through the use of the Kirin compiler infrastructure, Bloqade embraces this philosophy of heterogeneous compute. Kirin programs are written as (compositions of) kernels-- subroutines that are intended to run on particular hardware (such as QPUs), or orchestrated to run on heterogeneous compute (such as a real-time classical runtime plus a QPU). These subroutines-- plus the built-in hybrid representations-- enable many key primitives, such as error correction.</p> <p>Additionally, the ability to compose functions together and to use typical classical programming structures like <code>if</code> and recursion enables many simplifications in writing raw circuit executions. In fact, recursion and the ability to dynamically allocate new memory (which is not known until runtime) enables many powerful subroutines and is natively enabled with Bloqade's kernel-based representation; for example, see this implementation of a repeat-until-success program.</p>"},{"location":"manifesto/#analog-digital-logical-towards-real-quantum-utility","title":"Analog, digital, logical: towards real quantum utility","text":"<p>The first step in Bloqade was building out the analog mode SDK, designed to interface with QuEra\u2019s cloud-accessible analog-mode neutral-atom quantum computer Aquila, as well as enable analysis and scientific discovery in analog quantum computing. But the journey should not stop there: real quantum utility is error corrected and requires robust algorithmic exploration and design of quantum primitives, in-depth analysis of near-term hardware performance and benchmarking, and building pipelines and hybrid architectures that are intended not just for today\u2019s demonstrators but also for tomorrow\u2019s utility-scale hardware. By introducing the next generation of Bloqade, we hope to enable this exploration by adding in support for near-term digital and intermediate-term logical representations of hybrid quantum computations.</p>"},{"location":"manifesto/#join-us","title":"Join us!","text":"<p>If you are interested in contributing, please see the contribution page here. If you are interested in exploring more about neutral atom quantum computing, check out some analog tutorials here, and some circuit tutorials here. If you wish to work closer with QuEra, please feel free to reach out!</p>"},{"location":"analog/","title":"Index","text":"<p>Note</p> <p>Bloqade has been restructured to make room for new features and improvements. Please refer to the migration guide for more information.</p>"},{"location":"analog/#what-is-bloqade-analog","title":"What is Bloqade Analog?","text":"<p>Bloqade Analog is a Python SDK for QuEra's neutral atom quantum computer Aquila (check out our paper!). It's designed to make writing and analyzing the results of analog quantum programs on Aquila as easy as possible. It features custom atom geometries and flexible waveform definitions in both emulation and real hardware. Bloqade interfaces with the AWS Braket cloud service where Aquila  is hosted, enabling you to submit programs as well as retrieve and analyze real hardware results all-in-one.</p>"},{"location":"analog/#installation","title":"Installation","text":"<p>You can install the package with <code>pip</code> in your Python environment of choice via:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"analog/#a-glimpse-of-bloqade-analog","title":"A Glimpse of Bloqade Analog","text":"<p>Let's try a simple example where we drive a Rabi oscillation on a single neutral atom. Don't worry if you're unfamiliar with neutral atom physics, (you can check out our Background for more information!) the goal here is to just give you a taste of what Bloqade can do.</p> <p>We start by defining where our atoms go, otherwise known as the atom geometry. In this particular example we will use a small Honeycomb lattice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\n</code></pre> <p>We can verify what the atom geometry looks like by <code>.show()</code>'ing it:</p> <pre><code>geometry.show()\n</code></pre> <p>We now define what the time evolution looks like using a pulse sequence. The pulse sequence here is the time profile of the Rabi Drive targeting the ground-Rydberg two level transition, which causes the Rabi oscillations. We choose a constant waveform with a value of \\(\\frac{\\pi}{2} \\text{rad}/\\text{us}\\) and a duration of \\(1.0 \\,\\text{us}\\). This produces a \\(\\frac{\\pi}{2}\\) rotation on the Bloch sphere meaning our final measurements should be split 50/50 between the ground and Rydberg state.</p> <pre><code>from math import pi\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\n</code></pre> <p>Here <code>rabi.amplitude</code> means exactly what it is, the Rabi amplitude term of the Hamiltonian. <code>uniform</code> refers to applying the waveform uniformly across all the atom locations.</p> <p>We can visualize what our program looks like again with <code>.show()</code>:</p> <p>We can now run the program through Bloqade's built-in emulator to get some results. We designate that we want the program to be run and measurements performed 100 times:</p> <pre><code>emulation_results = rabi_program.bloqade.python().run(100)\n</code></pre> <p>With the results we can generate a report object that contains a number of methods for analyzing our data, including the number of counts per unique bitstring:</p> <pre><code>bitstring_counts = emulation_results.report().counts()\n</code></pre> <p>Which gives us:</p> <pre><code>[OrderedDict([('0', 55), ('1', 45)])]\n</code></pre> <p>If we want to submit our program to hardware we'll need to adjust the waveform as there is a constraint the Rabi amplitude waveform must start and end at zero. This is easy to do as we can build off the atom geometry we saved previously but apply a piecewise linear waveform:</p> <pre><code>hardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\n\nhardware_rabi_program.show()\n</code></pre> <p>Now instead of using the built-in Bloqade emulator we submit the program to Aquila. You will need to use the AWS CLI to obtain credentials from your AWS account or set the proper environment variables before hand.</p> <pre><code>hardware_results = hardware_rabi_program.braket.aquila.run_async(100)\n</code></pre> <p><code>.run_async</code> is a non-blocking version of the standard <code>.run</code> method, allowing you to continue work while waiting for results from Aquila. <code>.run_async</code> immediately returns an object you can query for the status of your tasks in the queue as well.</p> <p>You can do the exact same analysis you do on emulation results with hardware results too:</p> <pre><code>hardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p>If you want to try the above at once, we collected the above steps into the snippet below:</p> <pre><code>from math import pi\nfrom bloqade.analog.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\nemulation_results = rabi_program.bloqade.python().run(100)\nbitstring_counts = emulation_results.report().counts()\n\nhardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nhardware_results = hardware_rabi_program.braket.aquila.run_async(100)\nhardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p> </p>"},{"location":"analog/#features","title":"Features","text":""},{"location":"analog/#customizable-atom-geometries","title":"Customizable Atom Geometries","text":"<p>You can easily explore a number of common geometric lattices with Bloqade's <code>atom_arrangement</code>'s:</p> <pre><code>from bloqade.analog.atom_arrangement import Lieb, Square, Chain, Kagome\n\ngeometry_1 = Lieb(3)\ngeometry_2 = Square(2)\ngeometry_3 = Chain(5)\ngeometry_4 = Kagome(3)\n</code></pre> <p>If you're not satisfied with the Bravais lattices we also allow you to modify existing Bravais lattices as follows:</p> <pre><code>geometry_5 = Kagome(3).add_position((10,11))\n</code></pre> <p>You can also build your geometry completely from scratch:</p> <pre><code>from bloqade import start\n\ngeometry = start.add_positions([(0,0), (6,0), (12,0)])\n</code></pre>"},{"location":"analog/#flexible-pulse-sequence-construction","title":"Flexible Pulse Sequence Construction","text":"<p>Define waveforms for pulse sequences any way you like by either building (and chaining!) them immediately as part of your program:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\ngeometry = Square(2)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\ncustom_rabi_amp_waveform = (\n  target_rabi_amplitude\n  .piecewise_linear(values=[0, 10, 10, 0], durations=[0.1, 3.5, 0.1])\n  .piecewise_linear(values=[0, 5, 3, 0], durations=[0.2, 2.0, 0.2])\n)\n</code></pre> <p>Or building them separately and applying them later:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Chain\n\ngeometry_1 = Square(3)\ngeometry_2 = Chain(5)\n\ntarget_rabi_amplitude = start.rydberg.rabi.amplitude.uniform\npulse_sequence = target_rabi_amplitude.uniform.constant(value=2.0, duration=1.5).parse_sequence()\n\nprogram_1 = geometry_1.apply(pulse_sequence)\nprogram_2 = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/#hardware-and-emulation-backends","title":"Hardware and Emulation Backends","text":"<p>Go from a fast and powerful emulator:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\nfrom math import pi\n\ngeometry = Square(3, lattice_spacing = 6.5)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nprogram = (\n  target_rabi_amplitude\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nemulation_results = program.bloqade.python().run(100)\n</code></pre> <p>To real quantum hardware in a snap:</p> <pre><code>hardware_results = program.braket.aquila().run_async(100)\n</code></pre>"},{"location":"analog/#simple-parameter-sweeps","title":"Simple Parameter Sweeps","text":"<p>Use variables to make parameter sweeps easy on both emulation and hardware:</p> <pre><code>from bloqade import start\nimport numpy as np\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_oscillation_program = (\n  target_rabi_amplitude\n  .piecewise_linear(durations = [0.06, \"run_time\", 0.06], values = [0, 15, 15, 0])\n)\nrabi_oscillation_job = rabi_oscillation_program.batch_assign(run_time=np.linspace(0, 3, 101))\n\nemulation_results = rabi_oscillation_job.bloqade.python().run(100)\nhardware_results = rabi_oscillation_job.braket.aquila().run(100)\n</code></pre> <pre><code>emulation_results.report().rydberg_densities()\n                0\ntask_number\n0            0.16\n1            0.35\n2            0.59\n3            0.78\n4            0.96\n...           ...\n96           0.01\n97           0.09\n98           0.24\n99           0.49\n100          0.68\n\n[101 rows x 1 columns]\n</code></pre>"},{"location":"analog/#quick-results-analysis","title":"Quick Results Analysis","text":"<p>Want to just see some plots of your results? <code>.show()</code> will show you the way!</p> <p><pre><code>from bloqade.analog.atom_arrangement import Square\n\nrabi_amplitude_values = [0.0, 15.8, 15.8, 0.0]\nrabi_detuning_values = [-16.33, -16.33, 42.66, 42.66]\ndurations = [0.8, 2.4, 0.8]\n\ngeometry = Square(3, lattice_spacing=5.9)\nrabi_amplitude_waveform = (\n  geometry\n  .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)\n)\nprogram = (\n  rabi_amplitude_waveform\n  .detuning.uniform.piecewise_linear(durations, rabi_detuning_values)\n)\nemulation_results = program.bloqade.python().run(100)\nemulation_results.report().show()\n</code></pre> </p>"},{"location":"analog/#contributing-to-bloqade","title":"Contributing to Bloqade","text":"<p>Bloqade is released under the Apache License, Version 2.0. If you'd like the chance to shape the future of neutral atom quantum computation, see our Contributing Guide for more info!</p>"},{"location":"analog/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the project! We welcome all contributions. There are many different ways to contribute to Bloqade, and we are always looking for more help. We accept contributions in the form of bug reports, feature requests, documentation improvements, and code contributions. For more information about how to contribute, please read the following sections.</p>"},{"location":"analog/contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Reporting a Bug </li> <li>Reporting Documentation Issues</li> <li>Feature Requests</li> <li>Developing Bloqade</li> <li>Design Philosophy and Architecture</li> <li>Community Slack</li> <li>Ask a Question</li> <li>Providing Feedback</li> </ul>"},{"location":"analog/contributing/asking-a-question/","title":"Ask a Question","text":"<p>If you're interested in contributing to Bloqade, or just want to discuss the project, join the discussion on GitHub Discussions at https://github.com/QuEraComputing/bloqade-analog/discussions</p>"},{"location":"analog/contributing/code-of-conduct/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"analog/contributing/code-of-conduct/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"analog/contributing/code-of-conduct/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"analog/contributing/code-of-conduct/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"analog/contributing/community-slack/","title":"Community Slack","text":"<p>You can join QuEra's Slack workspace with this link. Join the <code>#bloqade</code> channel to discuss anything related to Bloqade.</p>"},{"location":"analog/contributing/design-philosophy-and-architecture/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"analog/contributing/design-philosophy-and-architecture/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"analog/contributing/design-philosophy-and-architecture/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"analog/contributing/design-philosophy-and-architecture/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"analog/contributing/documentation-issues/","title":"Reporting a Documentation Issue","text":"<p>We are always looking to improve our documentation. If you find a typo or think something is unclear, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-analog/issues</p> <p>For typos or other minor problems, create an issue that contains a link to the specific page that includes the problem, along with a description of the problem and possibly a solution.</p> <p>For a request for new documentation content, please open up an issue and describe what you think is missing from the documentation.</p>"},{"location":"analog/contributing/feature-requests/","title":"Requesting new Features","text":"<p>Given that we are currently at the beginning of the development of the Bloqade python interface, we are open to suggestions about what features would be helpful to include in future package iterations. If you have a request for a new feature, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-analog/issues</p> <p>We ask that the feature requests be as specific as possible. Please include the following information in your feature request:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the feature, including your attempt to solve the problem with the current version of Bloqade.</p> </li> <li> <p>A minimal code example that demonstrates the need for the feature.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"analog/contributing/providing-feedback/","title":"Providing Feedback","text":"<p>While Github Issues are a great way for us to better understand any issues your having with Bloqade as well as provide us with feature requests, we're always looking for ways to collect more general feedback about what the user experience with Bloqade is like.</p> <p>To do that we have this form where you can provide your thoughts after using/experimenting/tinkering/hacking with Bloqade.</p> <p>Your feedback will help guide the future of Bloqade's design so be honest and know that you're contributing to the future of Quantum Computing with Neutral Atoms!</p>"},{"location":"analog/contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>Bloqade is currently in the alpha phase of development, meaning bugs most likely exist in the current implementation. We are continuously striving to improve the stability of Bloqade. As such, we encourage our users to report all bugs they find. To do this, we ask you to submit an issue to our GitHub page: https://github.com/QuEraComputing/bloqade-analog/issues</p> <p>Please include the following information in your bug report:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the bug, including the expected behavior and what happened.</p> </li> <li> <p>A minimal code example that reproduces the bug.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"analog/home/background/","title":"Background","text":""},{"location":"analog/home/background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>The qubits that QuEra's neutral atom computer Aquila and Bloqade are designed to emulate are based on neutral atoms. As the name implies they are atoms that are neutrally charged but are also capable of achieving a Rydberg state where a single electron can be excited to an incredibly high energy level without ionizing the atom.</p> <p>This incredibly excited electron energy level \\(|r\\rangle\\) and its default ground state \\(|g\\rangle\\) create a two-level system where superposition can occur. For enabling interaction between two or more qubits and achieving entanglement, when the neutral atoms are in the Rydberg state a phenomenon known as the Rydberg blockade can occur where an atom in the Rydberg state prevents a neighboring atom from also being excited to the same state.</p> <p>For a more nuanced and in-depth read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p>"},{"location":"analog/home/background/#analog-vs-digital-quantum-computing","title":"Analog vs Digital Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital.</p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing</p>"},{"location":"analog/home/background/#analog-mode","title":"Analog Mode","text":"<p>In the analog mode (supported by Bloqade and Aquila) you control your computation through the parameters of a time-dependent Hamiltonian that influences all the qubits at once. There are options for local control of the Hamiltonian on certain qubits however.</p>"},{"location":"analog/home/background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). For neutral atoms, this digital mode can be accomplished with the introduction of hyperfine coupling, enabling a quantum state to be stored for long periods of time while also allowing for multi-qubit gates.</p>"},{"location":"analog/home/background/#rydberg-many-body-hamiltonian","title":"Rydberg Many-Body Hamiltonian","text":"<p>When you emulate a program in Bloqade, you are emulating the time evolution of the Rydberg many-body Hamiltonian which looks like this:</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p>"},{"location":"analog/home/background/#local-control","title":"Local Control","text":"<p>The Rydberg Many-Body Hamiltonian already implies from its subscripts that you can also have local control over your atoms. In Bloqade this local control extends to any term in the Hamiltonian while on Aquila this is currently restricted to the \\(\\Delta_j\\) laser detuning term.</p> <p>Fields in Bloqade give you local (single-atom) control over the many-body Rydberg Hamiltonian.</p> <p>They are a sum of one or more spatial modulations, which allows you to scale the amplitude of the waveform across the different sites in the system:</p> \\[ F_{i}(t) = \\sum_{\\alpha} C_{i}^{\\alpha}f_{\\alpha}(t) \\] \\[ C_{i}^{\\alpha} \\in \\mathbb{R} \\] \\[ f_{\\alpha}(t) \\colon \\mathbb{R} \\to \\mathbb{R} \\] <p>The \\(i\\)-th component of the field is used to generate the drive at the \\(i\\)-th site.</p> <p>Note that the drive is only applied if the \\(i\\)-th site is filled with an atom.</p> <p>You build fields in Bloqade by first specifying the spatial modulation followed by the waveform it should be multiplied by.</p> <p>In the case of a uniform spatial modulation, it can be interpreted as a constant scaling factor where \\(C_{i}^{\\alpha} = 1.0\\).</p>"},{"location":"analog/home/emulation/","title":"Emulation","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/geometry/","title":"Geometry","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/gotchas/","title":"Bloqade Gotchas: Common Mistakes in Using Bloqade","text":"<p>It is tempting when coming from different quantum SDKs and frameworks to apply the same pattern of thought to Bloqade. However, a lot of practices from those prior tools end up being anti-patterns in Bloqade. While you can use those patterns and they can still work, it ends up causing you the developer to write unnecessarily verbose, complex, and hard-to-read code as well as preventing you from reaping the full benefits of what Bloqade has to offer.</p> <p>This page is dedicated to cataloguing those anti-patterns and what you can do instead to maximize the benefit Bloqade can offer you.</p>"},{"location":"analog/home/gotchas/#redefining-lattices-and-common-atom-arrangements","title":"Redefining Lattices and Common Atom Arrangements","text":"<p>You might be tempted to define lattice-based geometries through the following means:</p> <pre><code>from bloqade import start\n\nspacing = 4.0\ngeometry = start.add_positions(\n    [(i * spacing, j * spacing) for i in range(4) for j in range(4)]\n)\n</code></pre> <p>This is quite redundant and verbose, especially considering Bloqade offers a large number of pre-defined lattices you can customize the spacing of in <code>bloqade.atom_arrangement</code>. In the code above, we're just defining a 4x4 square lattice of atoms with 4.0 micrometers of spacing between them. This can be expressed as follows</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nspacing = 4.0\ngeometry = Square(4, lattice_spacing = spacing)\n</code></pre>"},{"location":"analog/home/gotchas/#copying-a-program-to-create-new-ones","title":"Copying a Program to create New Ones","text":"<p>Many gate-based SDKs rely on having a mutable object representing your circuit. This means if you want to build on top of some base circuit without mutating it, you have to copy it:</p> <pre><code>import copy\n\nbase_circuit = qubits.x(0)....\n# make copy of base circuit\ncustom_circuit_1 = copy(base_circuit)\n# build on top of copy of base circuit\ncustom_circuit_1.x(0).z(5)...\n# create a new circuit by copying the base again\ncustom_circuit_2 = copy(base_circuit)\n# build on top of that copy again\ncustom_circuit_2.y(5).cz(0,2)...\n</code></pre> <p>In Bloqade Python this is unnecessary because at every step of your program an immutable object is returned which means you can save it and not have to worry about mutating any internal state.</p> <pre><code>from bloqade import start\nbase_program = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n# Just recycle your base program! No `copy` needed!\nnew_program_1 = base_program.constant(duration=5.0, value=5.0)\nnew_program_2 = base_program.piecewise_linear(\n    durations=[5.0], values = [0.0, 5.0]\n)\n</code></pre>"},{"location":"analog/home/gotchas/#creating-new-programs-instead-of-using-batch_assign","title":"Creating New Programs Instead of Using <code>.batch_assign</code>","text":"<p>If you have a set of parameters you'd like to test your program on versus a single parameter, don't generate a new program for each value:</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\nprograms_with_different_rabi_values = []\n\nfor rabi_value in rabi_values:\n    program = start.add_position((0, 0)).rydberg.rabi.amplitude.uniform.constant(\n        duration=5.0, value=rabi_value\n    )\n    programs_with_different_rabi_values.append(program)\n\nresults = []\n\nfor program in programs_with_different_rabi_values:\n    result = program.bloqade.python().run(100)\n    results.append(result)\n</code></pre> <p>Instead take advantage of the fact Bloqade has facilities specifically designed to make trying out multiple values in your program without needing to make individual copies via <code>.batch_assign</code>. The results are also automatically handled for you so each value you test has its own set of results, but all collected in a singular dataframe versus the above where you'd have to keep track of individual results.</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\n# place a variable for the Rabi Value and then batch assign values to it\nprogram_with_rabi_values = start.add_position(\n    0, 0\n).rydberg.rabi.amplitude.uniform.constant(duration=5.0, value=\"rabi_value\")\nprogram_with_assignments = program_with_rabi_values.batch_assign(\n    rabi_value=rabi_values\n)\n\n# get your results in one dataframe versus having to keep track of a\n# bunch of individual programs and their individual results\nbatch = program_with_assignments.bloqade.python().run(100)\nresults_dataframe = batch.report().dataframe\n</code></pre>"},{"location":"analog/home/migration/","title":"Migrating to Bloqade Analog","text":""},{"location":"analog/home/migration/#introduction","title":"Introduction","text":"<p>In order to make room for more features inside the Bloqade ecosystem, we have created a new package to take the place of the old <code>bloqade</code> package. The new package is called <code>bloqade-analog</code>. The old package <code>bloqade</code> will house a namespace package for other features such as our new Bloqade Digital package with support for circuit-based quantum computers!</p>"},{"location":"analog/home/migration/#installation","title":"Installation","text":"<p>You can install the package with <code>pip</code> in your Python environment of choice via:</p> <pre><code>pip install bloqade-analog\n</code></pre>"},{"location":"analog/home/migration/#migration","title":"Migration","text":"<p>The new package is a drop-in replacement for the old one. You can simply replace <code>import bloqade</code> with <code>import bloqade.analog</code>  or <code>from bloqade.analog import ...</code> in your code. Everything else should work as before.</p>"},{"location":"analog/home/migration/#example","title":"Example","text":"<p>lets say your header of your python script looks like this:</p> <p><pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n...\n</code></pre> You can simply replace it with:</p> <pre><code>from bloqade.analog import var\nfrom bloqade.analog.atom_arrangement import Square\n...\n</code></pre>"},{"location":"analog/home/migration/#migrating-old-bloqade-json-files","title":"Migrating old bloqade JSON files","text":"<p>If you have old bloqade JSON files, you will not be able to directly deserialize them anymore because of the package restructuring. However, we have provided some tools to migrate those JSON files to be compatible with <code>bloqade-analog</code>. You can do this by running the following command in the command line for a one or more files:</p> <p><pre><code>python -m bloqade.analog.migrate &lt;path_to_old_json_file1&gt; &lt;path_to_old_json_file2&gt; ...\n</code></pre> With default arguments this will create a new file with the same name as the old file, but with <code>-analog</code> appended to the end of the filename. For example, if you have a file called <code>my_bloqade.json</code>, the new file will be called <code>my_bloqade-analog.json</code>. You can then use <code>load</code> to deserialize this file with the <code>bloqade-analog</code> package. There are other options for converting the file, such as setting the indent level for the output file or overwriting the old file. You can see all the options by running:</p> <pre><code>python -m bloqade.analog.migrate --help\n</code></pre> <p>Another option is to use the migration tool in a python script:</p> <p><pre><code>from bloqade.analog.migrate import migrate\n\n # set the indent level for the output file\nindent: int = ...\n# set to True if you want to overwrite the old file, otherwise the new file will be created with -analog appended to the end of the filename\noverwrite: bool = ...\nf\nor filename in [\"file1.json\", \"file2.json\", ...]:\n    migrate(filename, indent=indent, overwrite=overwrite)\n</code></pre> This will migrate all the files in the list to the new format.</p>"},{"location":"analog/home/migration/#having-trouble-comments-or-concerns","title":"Having trouble, comments, or concerns?","text":"<p>Please open an issue on our GitHub</p>"},{"location":"analog/home/quick_start/","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"analog/home/quick_start/#navigating-the-bloqade-api","title":"Navigating the Bloqade API","text":"<p>As you develop your Bloqade program, you are expected to rely on pop-up \"hints\" provided in your development environment to help you determine what the next part of your program should be.</p>"},{"location":"analog/home/quick_start/#vs-code","title":"VS Code","text":"<p>In VS Code this is automatic, just type the <code>.</code> and see what options pop up:</p> <p></p>"},{"location":"analog/home/quick_start/#jetbrains-pycharm","title":"JetBrains PyCharm","text":"<p>The same goes for JetBrains PyCharm:</p> <p></p>"},{"location":"analog/home/quick_start/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>In a Jupyter Notebook you'll need to type <code>.</code> and then hit tab for the hints to appear:</p> <p></p>"},{"location":"analog/home/quick_start/#ipython","title":"IPython","text":"<p>The same goes for IPython:</p> <p></p>"},{"location":"analog/home/quick_start/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"analog/home/quick_start/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"analog/home/quick_start/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"analog/home/quick_start/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"analog/home/quick_start/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/home/quick_start/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"analog/home/quick_start/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"analog/home/quick_start/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"analog/home/quick_start/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"analog/home/quick_start/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"analog/home/quick_start/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"analog/home/submission/","title":"Submission","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/visualization/","title":"Visualization","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/waveforms/","title":"Waveforms","text":"<p>This page is a work in progress!</p>"},{"location":"analog/reference/hardware-capabilities/","title":"Hardware Capabilities","text":"<p>During program development, it can be quite handy to know what true hardware capabilities are and incorporate that information programmatically. Bloqade offers the ability to do this via <code>get_capabilities()</code>.</p>"},{"location":"analog/reference/hardware-capabilities/#programmatic-access","title":"Programmatic Access","text":"<p><code>get_capabilities()</code> (importable directly from <code>bloqade</code>) returns a <code>QuEraCapabilities</code> object. This object contains all the hardware constraints in <code>Decimal</code> format for the Aquila machine, our publicly-accessible QPU on AWS Braket.</p> <p>An example of using <code>get_capabilities()</code> is presented below:</p> <pre><code>from bloqade import get_capabilities, piecewise_linear\n\n# get capabilities for Aquila\naquila_capabilities = get_capabilities()\n\n# obtain maximum Rabi frequency as Decimal\nmax_rabi = aquila_capabilities.capabilities.rydberg.global_.rabi_frequency_max\n\n# use that value in constructing a neat Rabi waveform\nrabi_wf = piecewise_linear(durations = [0.5, 1.0, 0.5], values = [0, max_rabi, max_rabi, 0])\n</code></pre> <p>The attribute names for each value have been provided below but will require you to provide the proper prefix like in the example above (e.g. the maximum number of qubits lives under the <code>number_qubits_max</code> attribute which can be navigated to via <code>*your_QuEra_Capabilities_Object*.lattice.number_qubits_max</code>).</p>"},{"location":"analog/reference/hardware-capabilities/#aquila-capabilities","title":"Aquila Capabilities","text":""},{"location":"analog/reference/hardware-capabilities/#task","title":"Task","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.task</code> for:<ul> <li>minimum number of shots</li> <li>maximum number of shots</li> </ul> </li> </ul> Capability Attribute Value Minimum Number of Shots <code>number_shots_min</code> 1 Maximum Number of Shots <code>number_shots_max</code> 1000"},{"location":"analog/reference/hardware-capabilities/#lattice-geometry","title":"Lattice Geometry","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.lattice</code> for:<ul> <li>maximum number of qubits</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.area</code> for:<ul> <li>maximum lattice area width</li> <li>maximum lattice area height</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.geometry</code> for:<ul> <li>maximum number of sites</li> <li>position resolution</li> <li>minimum radial spacing</li> <li>minimum vertical spacing</li> </ul> </li> </ul> Capability Attribute Value Maximum Number of Qubits <code>number_qubits_max</code> 256 Maximum Lattice Area Width <code>width</code> 75.0 \u00b5m Maximum Lattice Area Height <code>height</code> 76.0 \u00b5m Minimum Radial Spacing between Qubits <code>spacing_radial_min</code> 4.0 \u00b5m Minimum Vertical Spacing between Qubits <code>spacing_vertical_min</code> 4.0 \u00b5m Position Resolution <code>position_resolution</code> 0.1 \u00b5m Maximum Number of Sites <code>number_sites_max</code> 256"},{"location":"analog/reference/hardware-capabilities/#global-rydberg-values","title":"Global Rydberg Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg</code> for:<ul> <li>C6 Coefficient</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.global_</code> for:<ul> <li>Everything else related to global (applied to all atom) capabilities</li> </ul> </li> </ul> Capability Attribute Value Rydberg Interaction Constant <code>c6_coefficient</code> 5.42\u00d710\u2076 rad/\u03bcs \u00d7 \u00b5m\u2076 Minimum Rabi Frequency <code>rabi_frequency_min</code> 0.00 rad/\u03bcs Maximum Rabi Frequency <code>rabi_frequency_max</code> 15.8 rad/\u03bcs Rabi Frequency Resolution <code>rabi_frequency_resolution</code> 0.0004 rad/\u03bcs Maximum Rabi Frequency Slew Rate <code>rabi_frequency_slew_rate_max</code> 250.0 rad/\u00b5s\u00b2 Minimum Detuning <code>detuning_min</code> -125.0 rad/\u03bcs Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Detuning Resolution <code>detuning_resolution</code> 2.0\u00d710\u207b\u2077 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 2500.0 rad/\u00b5s\u00b2 Minimum Phase <code>phase_min</code> -99.0 rad Maximum Phase <code>phase_max</code> 99.0 rad Phase Resolution <code>phase_resolution</code> 5.0\u00d710\u207b\u2077 rad Minimum Time <code>time_min</code> 0.0 \u00b5s Maximum Time <code>time_max</code> 4.0 \u00b5s Time Resolution <code>time_resolution</code> 0.001 \u00b5s Minimum \u0394t <code>time_delta_min</code> 0.05 \u00b5s"},{"location":"analog/reference/hardware-capabilities/#local-detuning-values","title":"Local Detuning Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.local</code> for the following values:</li> </ul> Capability Attribute Value Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Minimum Detuning <code>detuning_min</code> 0 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 1256.0 rad/\u00b5s\u00b2 Maximum Number of Local Detuning Sites <code>number_local_detuning_sites</code> 200 Maximum Site Coefficient <code>site_coefficient_max</code> 1.0 Minimum Site Coefficient <code>site_ceofficient_min</code> 0.0 Minimum Radial Spacing <code>spacing_radial_min</code> 5 \u00b5m Minimum \u0394t <code>time_delta_min</code> 0.05 \u03bcs Time Resolution <code>time_resolution</code> 0.001 \u00b5s"},{"location":"analog/reference/overview/","title":"Builder Overview","text":"<p>You may have noticed from the Getting Started and Tutorials that Bloqade uses this interesting, dot-intensive syntax.</p> <p><pre><code>from bloqade import start\n\nprog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform.constant(1,1)\n</code></pre> Exhibit A: Lots of Dots</p> <p>In fact, it might look remniscent of what you see in some gate-based Quantum Computing SDKs:</p> <pre><code># this is strictly pseudocode\ncircuit = init_qubits(n_qubits)\n# note the dots!\ncircuit.x(0).z(1).cnot(0, 1)...\n</code></pre> <p>What's the deal with that?</p>"},{"location":"analog/reference/overview/#syntax-motivations","title":"Syntax Motivations","text":"<p>We call this syntax the builder or builder syntax and as its name implies, it is designed to let you build programs for Analog Hamiltonian Simulation hardware as easily and as straightforward as possible.</p> <p>The linear structure implies a natural hierarchy in how you think about targeting the various degrees of freedom (detuning, atom positions, Rabi amplitude, etc.) your program will have. In the beginning you have unrestricted access to all these degrees of freedom but in order to do something useful you need to:</p> <ol> <li>Narrow down and explicitly identify what you want to control</li> <li>Provide the instructions on how you want to control what your focused on</li> </ol> <p>Context is a strong component of the builder syntax, as you are both actively restricted from doing certain things that can introduce ambiguity based on where you are in your program and repeating the same action in different parts of the program yields different results.</p>"},{"location":"analog/reference/overview/#visual-guides","title":"Visual Guides","text":"<p>While we hope the Smart Documentation (the ability to instantly see all your next possible steps and their capabilities in your favorite IDE/IPython) is sufficient to get you where you need to go, we understand it's particularly beneficial to get a high-level overview of things before diving in.</p> <p>The Standard Representation is a nice flow chart that gives a high-level overview of the different steps and components in the builder syntax.</p>"},{"location":"analog/reference/standard/","title":"Build Workflow","text":"<pre><code>\nflowchart TD\n  ProgramStart([\"start\"])\n\n  Geometry(\"Geometry or Lattice\")\n\n  Coupling[\"Coupling\n  -----------\n  rydberg\n  hyperfine\"]\n\n  Detuning[\"detuning\"]\n  Rabi[\"rabi\"]\n\n  Amplitude[\"amplitude\"]\n  Phase[\"phase\"]\n\n  SpaceModulation(\"SpatialModulation\n  ----------------------\n  uniform\n  scale\n  location\n  \")\n  Waveform{\"Waveform\n  ------------\n  piecewise_linear\n  piecewise_constant\n  constant\n  linear\n  poly\n  fn\n  \"}\n\n  Options([\"Options\n  ---------\n  assign\n  batch_assign\n  args\n  parallelize\n  \"])\n\n  Services([\"Services\n  ----------\n  bloqade\n  quera\n  braket\"])\n\n  QuEraBackends([\"Backends\n  ------------\n  mock\n  cloud_mock\n  aquila\n  device\"])\n\n  BraketBackends([\"Backends\n  ------------\n  aquila\n  local_emulator\"])\n\n  BloqadeBackends([\"Backends\n  ------------\n  python\n  julia\"])\n\n  Execution(\"\n  Execution hardware only\n  -------------------------------\n  run_async()\n\n  Hardware and simulation\n  -------------------------------\n  run()\n  __call__\")\n\n  ProgramStart --&gt;|add_position| Geometry;\n  Geometry --&gt; Coupling;\n  ProgramStart --&gt; Coupling;\n\n  Coupling --&gt; Detuning;\n  Coupling --&gt; Rabi;\n\n  Rabi --&gt; Amplitude;\n  Rabi --&gt; Phase;\n\n  Detuning --&gt; SpaceModulation;\n  Amplitude --&gt; SpaceModulation;\n  Phase --&gt; SpaceModulation;\n\n  SpaceModulation --&gt; Waveform;\n\n  Waveform --&gt; Coupling;\n  Waveform --&gt; Services;\n  Waveform --&gt; Options;\n  Options --&gt; Services;\n\n  Services --&gt;|quera| QuEraBackends;\n  Services --&gt;|braket| BraketBackends;\n  Services --&gt;|bloqade| BloqadeBackends;\n  QuEraBackends --&gt; Execution;\n  BraketBackends --&gt; Execution;\n  BloqadeBackends --&gt; Execution;\n\n  click ProgramStart \"../bloqade/#bloqade.start\";\n  click Geometry \"../bloqade/atom_arrangement/\";\n  click Coupling \"../bloqade/builder/drive/\";\n  click Detuning \"../bloqade/builder/field/#bloqade.builder.field.Detuning\";\n  click Rabi \"../bloqade/builder/field/#bloqade.builder.field.Rabi\";\n  click Amplitude \"../bloqade/builder/field/#bloqade.builder.field.Amplitude\";\n  click Phase \"../bloqade/builder/field/#bloqade.builder.field.Phase\";\n  click SpaceModulation \"../bloqade/builder/spatial/\";\n  click Waveform \"../bloqade/builder/waveform/\";\n  click Options \"../bloqade/builder/pragmas/\";\n  click Services \"../bloqade/builder/backend/\";\n  click QuEraBackends \"../bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute\";\n  click BraketBackends \"../bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute\";\n  click BloqadeBackends \"../bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeBackend\";\n  click Execution \"../bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketRoutine\";\n</code></pre>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorial optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#highlights","title":"Highlights","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n\nimport numpy as np\n\nadiabatic_durations = [0.4, 3.2, 0.4]\n\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\n    Square(3, \"lattice_spacing\")\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=adiabatic_durations,\n        values=[\n            -max_detuning, # scalar variables support direct arithmetic operations\n            -max_detuning,\n            max_detuning,\n            max_detuning,\n        ],\n    )\n    .assign(max_rabi=15.8, max_detuning=16.33)\n    .batch_assign(lattice_spacing=np.arrange(4.0, 7.0, 0.5))\n)\n\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenonema/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/","title":"A new journey for Bloqade","text":"<p>In 2023 we were excited to introduce Bloqade, a python SDK for programming and interfacing with analog mode neutral atom hardware based off feedback from our community as well as a need to make conducting experiments on our hardware easier. Today, we introduce the next generation of Bloqade: as well as programming analog-mode computation, our new bloqade module enables programming gate-based computation, with an eye on near-term NISQ demonstrations and intermediate-term fault tolerant solutions. Don\u2019t worry; all of your favorite features of the previous generation of Bloqade are still there under the <code>bloqade.analog</code> namespace, but now you can explore digital-mode computation specialized to reconfigurable neutral atom architectures. Why have we built this new module? There are plenty of incredible quantum programming packages, such as Qiskit and Cirq, as well as an entire ecosystem of middleware providers with specialized pipelines to turn abstract problems into circuits. However, these packages may not be everything that is needed for efficient hardware execution on neutral atom hardware: a circuits-only representation of quantum executions may be an insufficient abstraction for effective hardware-level programs. This is a challenge: we want to enable everyone to maximally leverage the power of neutral atom quantum computers beyond abstract circuit representations. For this reason, we are building Bloqade to be a hardware-oriented SDK to represent hybrid executions on reconfigurable neutral atom hardware. In this way, Bloqade can be integrated into the larger ecosystem\u2014for example, code generation of QASM from a Bloqade program, but be an SDK specialized to our hardware: THE SDK for neutral atoms.</p> <p>The vision of Bloqade is to empower quantum scientists, working on things ranging from applications development to algorithmic co-design, to build hybrid quantum-classical programs that leverage the strength of neutral atom quantum computers and have a real chance of demonstrating quantum utility. Bloqade is built on top of Kirin, an open source compiler infrastructure designed for kernel functions and embedded Domain-Specific Language (eDSL) creation.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#composable-quantum-programming","title":"Composable quantum programming","text":"<p>As of today, Bloqade has two objectives: digital and analog quantum computing. <code>bloqade-analog</code> is the SDK for analog-mode neutral atom computers and includes several handy utilities ranging from building and analyzing analog programs, to emulation and execution on QuEra's cloud-accessible hardware \"Aquila\". <code>bloqade</code> is the initial iteration to represent digital circuit execution using gate-based quantum computing on reconfigurable neutral atom architecture. It extends the QASM2 language to include extra annotation of circuits that is important for efficient execution, such as parallelism and global gates. As well as being able to construct quantum programs with the full convenience of features found in classical programming languages - such as loops, control flows and closures - <code>bloqade</code> also includes basic compiler transformation passes, emulation, and code generation.</p> <p>But <code>bloqade</code> is not done with just these two components. We envision adding new components (called \"dialects\") which help you write programs which are tuned for optimal performance in an error corrected era of neutral atom hardware. Stay tuned and help us build the future of quantum computing as we build out new components targeting QEC and atom moving!</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#hardware-oriented-programming-and-co-design","title":"Hardware-oriented programming and co-design","text":"<p>At its core, Bloqade strives to be the neutral atom SDK for getting the most out of today's and tomorrows' quantum hardware. It is clear that the circuit-level abstraction is not enough to program real quantum hardware; indeed, tomorrows' quantum demonstrations and applications must program at the hardware level and develop special tooling to compile higher-level abstractions to efficient implementations. We call this process \"co-design\": designing algorithms specialized to near-term hardware, with an eye on nontrivial demonstrations and scalable solutions. Ultimately, this co-design approach requires hardware-specific DSLs which explicitly represent the native executions on neutral atom hardware: in other words, Bloqade.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#hybrid-computing-beyond-circuits","title":"Hybrid computing beyond circuits","text":"<p>Many quantum algorithms are hybrid, requiring both classical and quantum resources to work together in tandem. This could be anything from syndrome extraction and measurement-based computing to variational parameter updates in VQE methods and orbital fragmentation methods in molecular simulation. Through the use of the Kirin compiler infrastructure, Bloqade embraces this philosophy of heterogeneous compute. Kirin programs are written as (compositions of) kernels -- subroutines that are intended to run on particular hardware (such as QPUs), or orchestrated to run on heterogeneous compute (such as a real-time classical runtime plus a QPU). These subroutines -- plus the built-in hybrid representations-- enable many key primitives, such as error correction.</p> <p>Additionally, the ability to compose functions together and to use typical classical programming structures like <code>if</code> and recursions enables many simplifications in writing complex circuits. In fact, recursions and the ability to dynamically allocate new memory (which is not known until runtime) enables many powerful subroutines and is natively enabled with Bloqade's kernel-based representation; for example, see this implementation of a repeat-until-success program.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#analog-digital-logical-towards-real-quantum-utility","title":"Analog, digital, logical: towards real quantum utility","text":"<p>The first step in Bloqade's journey was building out the analog mode SDK, designed to interface with QuEra\u2019s cloud-accessible analog-mode neutral-atom quantum computer Aquila, as well as enable analysis and scientific discovery in analog quantum computing. But the journey should not stop there: real quantum utility is error corrected and requires robust algorithmic exploration and design of quantum primitives, in-depth analysis of near-term hardware performance and benchmarking, and building pipelines and hybrid architectures that are intended not just for today\u2019s demonstrations but also for tomorrow\u2019s utility-scale hardware. By introducing the next generation of Bloqade, we hope to enable this exploration by adding in support for near-term digital and intermediate-term logical representations of hybrid quantum computations.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#learn-more","title":"Learn more","text":"<p>Bloqade is an open-source project and can be freely downloaded and modified; you can learn how to do so here. If you want to see how to write programs with of the new <code>bloqade</code> package, check out our examples here. If you would like to learn more about QuEra Computing Inc., check out our webpage as well as discover our many academic publications and demonstrations.</p>"},{"location":"digital/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"digital/#digital-bloqade","title":"Digital Bloqade","text":"<p>The digital submodule of Bloqade, called <code>bloqade-circuit</code> defines a set of embedded domain-specific languages (eDSLs) that can be used to define digital quantum programs. These programs are intended for both simulation and to be run on hardware. This package is open source and can be found on GitHub.</p> <p>Please refer to the Dialects and Kernels section of this documentation for an overview over the most important eDSLs. The infrastructure behind these compilers is built on top of Kirin.</p> <p>It is easiest to learn how to use this package by checking out the examples &amp; tutorials section, where we show how you can build and study different quantum programs written in different DSLs. You can also find the corresponding scripts in jupytext format at the bloqade repository under <code>docs/digital/examples/</code>.</p> <p>Finally, if you want the full details on the API, please refer to the API reference documentation.</p>"},{"location":"digital/#installation","title":"Installation","text":"<p>The package comes as a submodule of Bloqade, so you can just run</p> <pre><code>pip install bloqade\n</code></pre> <p>in order to obtain it.</p> <p>Sometimes, you may want to reduce the number of dependencies, in which case you can also only install the submodule</p> <pre><code>pip install bloqade-circuit\n</code></pre> <p>Note, that bloqade-circuit also has some optional dependencies, which you may want to install. For example</p> <pre><code>pip install bloqade-circuit[cirq,qasm2,stim]\n</code></pre>"},{"location":"digital/#tldr","title":"TL;DR","text":"<p>Here's a GHZ preparation circuit written in the <code>squin</code> dialect:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef ghz(n: int):\n    q = squin.qubit.new(n)\n\n    squin.gate.h(q[0])\n\n    for i in range(1, n):\n        squin.gate.cx(q[i - 1], q[i])\n\n    return squin.qubit.measure(q)\n</code></pre> <p>Here are some more examples.</p>"},{"location":"digital/dialects_and_kernels/","title":"Dialects and kernels","text":"<p>Bloqade provides a set of pre-defined dialects, with which you can write your programs and circuits.</p> <p>Once you have defined your kernel, you can inspect their intermediate representation (IR), apply different optimizations using compiler passes, or run them on a (simulator) device.</p> <p>Info</p> <p>A kernel function is a piece of code that runs on specialized hardware such as a quantum computer.</p> <p>A dialect is a domain-specific language (DSL) with which you can write such a kernel. Each dialect comes with a specific set of statements and instructions you can use in order to write your program.</p> <p>When running code that targets a specialized execution environment, there are typically several layers involved. At the surface, the programmer writes functions in a syntax that may resemble a host language (e.g., Python), but is actually expressed in a dialect\u2014 a domain-specific variant with its own semantics. A decorator marks these functions so they can be intercepted before normal host-language execution. All dialects can be used by decorating a function.</p> <p>Info</p> <p>Here's a short primer on decorators: a decorator in Python is simply a function (or any callable really) that takes in another function as argument and returns yet another function (callable). Usually, the returned function will be a modified version of the input. Decorators are used with the <code>@</code> syntax.</p> <p>Instead of running directly, the kernel function body is parsed and translated (lowered) into an intermediate representation (IR). This IR can be manipulated (e.g. to perform optimizations) and can later be executed by an interpreter that understands the dialect's semantics. The interpreter uses an internal instruction set to execute the code on the intended backend, which may be a simulator, virtual machine, or physical device. This separation lets developers write high-level, expressive code while the interpreter ensures it runs correctly in the target environment. QuEra's Kirin infrastructure uses this concept by defining custom dialects that are tailored towards the needs to program neutral atom quantum computers. While the dialects are not python syntax, Kirin still uses the python interpreter to execute the code.</p> <p>Note</p> <p>It is important to understand that when you are writing a kernel function in a dialect you are generally not writing Python code, even though it looks a lot like it. Therefore, kernel functions can usually not be called directly. Think of this as trying to execute another programming language with the Python interpreter: of course, that will error.</p>"},{"location":"digital/dialects_and_kernels/#available-dialects","title":"Available dialects","text":"<p>Here's a quick overview of the most important available dialects.</p>"},{"location":"digital/dialects_and_kernels/#qasm2","title":"qasm2","text":"<p>There are a number of dialects with which you can write kernels that represent QASM2 programs. See also the qasm2 API reference</p>"},{"location":"digital/dialects_and_kernels/#qasm2main","title":"qasm2.main","text":"<p>This dialect allows you to write native QASM2 programs. As such, it includes definitions gates, measurements and quantum and classical registers, which are part of the QASM2 specification. For details on the language, see the specification.</p> <p>Here's an example kernel</p> <pre><code>from bloqade import qasm2\n\n@qasm2.main\ndef main():\n    q = qasm2.qreg(2)\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n\n    c = qasm2.creg(2)\n    qasm2.measure(q, c)\n    return c\n</code></pre> <p>Here's how you can look at the QASM2 program this kernel represents:</p> <pre><code>from bloqade.qasm2.emit import QASM2\nfrom bloqade.qasm2.parse import pprint\n\n\ntarget = QASM2()\nqasm2_program = target.emit(main)\npprint(qasm2_program)\n</code></pre>"},{"location":"digital/dialects_and_kernels/#qasm2extended","title":"qasm2.extended","text":"<p>This dialect can also be used to write QASM2 programs. However, it adds a couple of statements that makes it easier to write programs. For example, QASM2 does not support for-loops. With <code>qasm2.extended</code>, however, you can use for-loops and can let the compiler worry about unrolling these loops such that valid QASM2 code is produced.</p> <pre><code>from bloqade import qasm2\n\n@qasm2.extended\ndef main():\n    n = 2\n    q = qasm2.qreg(n)\n\n    for i in range(n):\n        qasm2.h(q[i])\n\n    qasm2.cx(q[0], q[1])\n    c = qasm2.creg(n)\n    qasm2.measure(q, c)\n    return c\n</code></pre> <p>If you run this through the code emission as shown above, you'll see that the for-loop gets unrolled into separate hadamard gate applications for each qubit. At the same time, if you try to define this kernel using the <code>qasm2.main</code> dialect only, you will receive a <code>BuildError</code> telling you to take that crazy for-loop out of there as it's not supported.</p>"},{"location":"digital/dialects_and_kernels/#noisenative","title":"noise.native","text":"<p>Using this dialect, you can represent different noise processes in your kernel. As of now, there are essentially two different noise channels:</p> <ul> <li>A pauli noise channel, which can represent different types of decoherence.</li> <li>An atomic loss channel, which can be used to model effects of losing a qubit during the execution of a program.</li> </ul> <p>Usually, you don't want to write noise statements directly. Instead, use a [NoisePass][bloqade.qasm2.passes.NoisePass] in order to inject noise statements automatically according to a specific noise model.</p> <p>Note</p> <p>Right now, only the <code>qasm2.extended</code> dialect fully support noise.</p> <p>For example, you may want to do something like this:</p> <pre><code>from bloqade import qasm2\nfrom bloqade.qasm2.passes import NoisePass\n\n@qasm2.extended\ndef main():\n    n = 2\n    q = qasm2.qreg(n)\n\n    for i in range(n):\n        qasm2.h(q[i])\n\n    qasm2.cx(q[0], q[1])\n    c = qasm2.creg(n)\n    qasm2.measure(q, c)\n    return c\n\n# Define the noise pass you want to use\nnoise_pass = NoisePass(main.dialects)  # just use the default noise model for now\n\n# Inject the noise - note that the main method will be updated in-place\nnoise_pass(main)\n\n# Look at the IR and all the glorious noise in there\nmain.print()\n</code></pre>"},{"location":"digital/dialects_and_kernels/#squin","title":"squin","text":"<p>Warning</p> <p>The squin dialect is in an early stage of development. Expect substantial changes to it in the near future.</p> <p>This dialect is, in a sense, more expressive than the qasm2 dialects: it allows you to specify operators rather than just gate applications. That can be useful if you're trying to e.g. simulate a Hamiltonian time evolution.</p> <p>For simple circuits, however, gate applications also have short-hand standard library definitions defined in the <code>squin.gate</code> submodule. Here's a short example:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef main():\n    q = squin.qubit.new(2)\n    squin.gate.h(q[0])\n    squin.gate.cx(q[0], q[1])\n    return squin.qubit.measure(q)\n\n# have a look at the IR\nmain.print()\n</code></pre> <p>As mentioned above, you can also build up more complex \"operators\" that are then applied to any number of qubits. To show how you can do that, here's an example on how to write the above kernel defining the gates as separate operators. This isn't exactly a practical use-case, but serves as an example.</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef main():\n    q = squin.qubit.new(2)\n    h = squin.op.h()\n\n    # apply a hadamard to only the first qubit\n    h1 = squin.op.kron(h, squin.op.identity(sites=1))\n\n    squin.qubit.apply(h1, q[0], q[1])\n\n    cx = squin.op.cx()\n    squin.qubit.apply(cx, q[0], q[1])\n\n    return squin.qubit.measure(q)\n\n# have a look at the IR\nmain.print()\n</code></pre> <p>See also the squin API reference</p>"},{"location":"digital/dialects_and_kernels/#stim","title":"stim","text":"<p>Warning</p> <p>Sorry folks, still under construction.</p> <p>See also the stim API reference</p>"},{"location":"digital/tutorials_index/","title":"Tutorials on digital circuits","text":"<p>In this section you will find a number of tutorials that show how you can use the digital bloqade subpackage, <code>bloqade-circuit</code>, in order to write quantum programs. The tutorials are split into sub-sections featuring the different dialects and submodules.</p>"},{"location":"digital/tutorials_index/#squin","title":"Squin","text":"<p>Squin is bloqade-circuits central dialect used to build circuits and run them on simulators and hardware.</p> <ul> <li> <p>Deutsch-Jozsa Algorithm</p> <p>See how you can implement the fundamental Deutsch-Jozsa algorithm with a Squin kernel function.</p> </li> <li> <p>GHZ state preparation and noise</p> <p>Inject noise manually in a simple squin kernel.</p> </li> </ul>"},{"location":"digital/tutorials_index/#interoperability-with-other-sdks","title":"Interoperability with other SDKs","text":"<p>While bloqade-circuit provides a number of different dialects (eDSLs), it may also be convenient to transpile circuits written using other SDKs.</p> <ul> <li> <p>Heuristic noise models applied to GHZ state preparation</p> <p>Learn how to apply our heuristic noise models built to work with the cirq SDK.</p> </li> </ul>"},{"location":"digital/tutorials_index/#qasm2","title":"QASM2","text":"<p>One of the most central languages used to define quantum programs is QASM2. You can also write your quantum programs using the QASM2 dialect directly in bloqade-circuit.</p> <p>Warning</p> <p>Some of the examples below use the <code>qasm2.extended</code> dialect, which adds more advanced language features, such as control flow. However, this dialect is deprecated and we recommend using <code>squin</code> instead.</p> <ul> <li> <p>Quantum Fourier Transform</p> <p>An example showing how to implement the well-known Quantum Fourier Transform (QFT).</p> </li> <li> <p>GHZ Preparation and Parallelism</p> <p>Learn how to use parallelism to reduce the circuit (execution) depth.</p> </li> <li> <p>Pauli Exponentiation for Quantum Simulation</p> <p>Simulating Hamiltonian dynamics by exponentiating Pauli operators.</p> </li> <li> <p>Repeat until success with STAR gadget</p> <p>Here's how to implement a Z phase gate with the repeat-until-success protocol.</p> </li> </ul>"},{"location":"digital/cirq_interop/","title":"Interoperability with cirq","text":"<p>The Cirq framework is a powerful tool for writing quantum circuits targeting near-term devices. Instead of reinventing the wheel, Bloqade offers convenient interoperability with Cirq that allows you to jointly use both libraries in order to develop your quantum program.</p> <p>Specifically, you can turn a <code>cirq.Circuit</code> object into a squin kernel function and vice versa.</p> <p>For details on each of these, please see the documentation pages below:</p> <ul> <li>Obtaining a squin kernel function from a <code>cirq.Circuit</code></li> <li>Emitting a <code>cirq.Circuit</code> from a squin kernel</li> </ul> <p>For the API reference, please see the <code>cirq</code> submodule in the squin API docs.</p>"},{"location":"digital/cirq_interop/#tldr","title":"TL;DR","text":"<p>Here's a short example:</p> <pre><code>from bloqade import squin\nimport cirq\n\nq = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(q[0]),\n    cirq.CX(q[0], q[1])\n)\nprint(circuit)\n\nmain = squin.cirq.load_circuit(circuit)\nmain.print()\n\nroundtrip_circuit = squin.cirq.emit_circuit(main)\nprint(roundtrip_circuit)\n</code></pre>"},{"location":"digital/cirq_interop/cirq_to_squin/","title":"Converting cirq to squin","text":"<p>If you want to obtain a squin kernel from a circuit, you can use the <code>load_circuit</code> method in the <code>squin.cirq</code> submodule. What you're effectively doing is lowering a circuit to a squin IR. This IR can then be further lowered to eventually run on hardware.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#basic-examples","title":"Basic examples","text":"<p>Here are some basic usage examples to help you get started.</p> <pre><code>from bloqade import squin\nimport cirq\n\nqubits = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    cirq.CX(qubits[0], qubits[1]),\n    cirq.measure(qubits)\n)\n\n# let's have a look\nprint(circuit)\n\nmain_loaded = squin.cirq.load_circuit(circuit, kernel_name=\"main_loaded\")\n</code></pre> <p>The above is equivalent to writing the following kernel function yourself:</p> <pre><code>@squin.kernel\ndef main():\n    q = squin.qubit.new(2)\n    H = squin.op.h()\n    CX = squin.op.cx()\n    squin.qubit.apply(H, q[0])\n    squin.qubit.apply(CX, q)\n    squin.qubit.measure(q)\n</code></pre> <p>You can further inspect the lowered kernel as usual, e.g. by printing the IR. Let's compare the manually written version and the loaded version:</p> <pre><code>main.print()\nmain_loaded.print()\n</code></pre> <p>The resulting IR is equivalent, yet the loaded is a bit longer since the automated loading can make fewer assumptions about the code. Still, you can use the kernel as any other, e.g. by calling it from another kernel or running it via a simulator.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#noise","title":"Noise","text":"<p>Lowering a noisy circuit to squin is also supported. All common channels in cirq will be lowered to an equivalent noise statement in squin.</p> <pre><code>from bloqade import squin\nimport cirq\n\nqubits = cirq.LineQubit.range(2)\nnoisy_circuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    cirq.CX(qubits[0], qubits[1]),\n    cirq.depolarize(p=0.01).on_each(qubits),\n)\n\n# let's have a look\nprint(noisy_circuit)\n\nnoisy_kernel = squin.cirq.load_circuit(noisy_circuit)\nnoisy_kernel.print()\n</code></pre> <p>This becomes especially useful when used together with a <code>cirq.NoiseModel</code> that automatically adds noise to a circuit via <code>circuit.with_noise(model)</code>.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#composability-of-kernels","title":"Composability of kernels","text":"<p>You may also run into a situation, where you define a circuit that is used as part of a larger one, maybe even multiple times. In order to allow you to do something similar here, you can pass in and / or return the qubit register in a loaded kernel. Both these options are controlled by simple keyword arguments.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#qubits-as-argument-to-the-kernel-function","title":"Qubits as argument to the kernel function","text":"<p>Setting <code>register_as_argument=True</code> when loading a kernel, will result in a squin kernel function that accepts (and requires) a single argument of type <code>IList[Qubit]</code>. This means you can use a loaded circuit as part of another kernel function. Check it out:</p> <pre><code>from bloqade import squin\nimport cirq\n\nqubits = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    cirq.CX(qubits[0], qubits[1]),\n)\n\nsub_kernel = squin.cirq.load_circuit(circuit, register_as_argument=True, kernel_name=\"sub_kernel\")\n\n\n@squin.kernel\ndef main():\n    q = squin.qubit.new(4)\n\n    # entangle qubits 1 and 2\n    sub_kernel([q[0], q[1]])\n\n    # entangle qubits 3 and 4\n    sub_kernel([q[2], q[3]])\n\n\nmain.print()\n</code></pre> <p>Looking at the IR of the resulting kernel, you can see that there is are <code>invoke sub_kernel</code> statements present, which call the lowered circuit with the given arguments.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#qubits-as-return-value-from-the-kernel","title":"Qubits as return value from the kernel","text":"<p>Similarly to above, you may also want to return a list of qubits from a loaded kernel. Let's adapt the above to instantiate and return a pair of entangled qubits using the same circuit:</p> <pre><code>sub_kernel = squin.cirq.load_circuit(circuit, return_register=True, kernel_name=\"sub_kernel\")\n\n@squin.kernel\ndef main():\n    # instantiate and entangle a list of two qubits\n    q1 = sub_kernel()\n\n    # do it again, to get another set\n    q2 = sub_kernel()\n\n    # now we have 4 qubits to work with\n    ...\n\nmain.print()\n</code></pre> <p>Note</p> <p>You can also mix both options by setting <code>register_as_argument = True</code> and <code>return_register = True</code> in order to obtain a kernel function that both accepts and returns a list of qubits.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#limitations","title":"Limitations","text":"<p>There are some limitations when loading circuits. One, for example, is that custom gates are not supported as you can't generally know how to lower them to a squin statement.</p> <p>If you find a missing feature, please feel free to open a GitHub issue.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/","title":"Converting squin to Cirq","text":"<p>You can convert a squin kernel function to a <code>cirq.Circuit</code> object. The output circuit will feature gates that most closely resemble the kernel you put in.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/#basic-usage","title":"Basic usage","text":"<p>You can obtain a circuit using the <code>squin.cirq.emit_circuit</code> function.</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef main():\n    q = squin.qubit.new(2)\n    h = squin.op.h()\n    squin.qubit.apply(h, q[0])\n    cx = squin.op.cx()\n    squin.qubit.apply(cx, q[0], q[1])\n    squin.qubit.measure(q)\n\ncircuit = squin.cirq.emit_circuit(main)\nprint(circuit)\n</code></pre> <p>There is one crucial difference between a squin kernel and a cirq circuit: the qubits are defined inside a kernel, whereas for a circuit they are defined outside.</p> <p>The default behavior here is to emit a set of <code>cirq.LineQubit</code>, which is of the correct length. They will be sorted by their <code>Qid</code> (position) according to the order they appear in the kernel.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/#customizing-qubits","title":"Customizing qubits","text":"<p>By default, a set of <code>cirq.LineQubit</code>s of the appropriate size is created internally, on which the resulting circuit operates. This may be undesirable sometimes, e.g. when you want to combine multiple circuits or if you want to have qubits of a different type.</p> <p>To allow modifications here, you can simply pass in a list of qubits (a sequence of <code>cirq.Qid</code>s) into the emit function.</p> <pre><code>import cirq\n\nqubits = cirq.GridQubit.rect(rows=1, cols=2)\ncircuit = squin.cirq.emit_circuit(main, qubits=qubits)\nprint(circuit)\n</code></pre> <p>Note, that the qubits will be used in the resulting circuit in the order they appear in <code>squin.qubit.new</code> statements.</p> <p>Warning</p> <p>When passing in a list of qubits, you need to make sure there is sufficiently many qubits. Otherwise, you may get indexing errors.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/#limitations","title":"Limitations","text":"<p>Please note that there are some limitations, especially regarding control flow. Using <code>if</code> statements or loops inside a kernel function may lead to errors.</p> <p>If you run into an issue that you think should be supported, please report an issue on the GitHub repository.</p>"},{"location":"digital/examples/interop/noisy_ghz/","title":"GHZ State preparation and noise","text":"In\u00a0[\u00a0]: Copied! <pre>import cirq\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.cirq_utils import noise, transpile\n\nfrom bloqade import squin\n\n\ndef ghz_circuit(n: int) -&gt; cirq.Circuit:\n    qubits = cirq.LineQubit.range(n)\n\n    # Step 1: Hadamard on the first qubit\n    circuit = cirq.Circuit(cirq.H(qubits[0]))\n\n    # Step 2: CNOT chain from qubit i to i+1\n    for i in range(n - 1):\n        circuit.append(cirq.CNOT(qubits[i], qubits[i + 1]))\n\n    return circuit\n</pre> import cirq import numpy as np import matplotlib.pyplot as plt from bloqade.cirq_utils import noise, transpile  from bloqade import squin   def ghz_circuit(n: int) -&gt; cirq.Circuit:     qubits = cirq.LineQubit.range(n)      # Step 1: Hadamard on the first qubit     circuit = cirq.Circuit(cirq.H(qubits[0]))      # Step 2: CNOT chain from qubit i to i+1     for i in range(n - 1):         circuit.append(cirq.CNOT(qubits[i], qubits[i + 1]))      return circuit <p>Here's what this circuit looks like for <code>n=3</code> qubits:</p> In\u00a0[\u00a0]: Copied! <pre>ghz_circuit_3 = ghz_circuit(3)\nprint(ghz_circuit_3)\n</pre> ghz_circuit_3 = ghz_circuit(3) print(ghz_circuit_3) <p>So far so good. Now, we will convert the circuit above to a noisy one using bloqade's <code>cirq_utils</code> submodule.</p> <p>Specifically, we can use the <code>noise.transform_circuit</code> utility function with a noise model of our choice.</p> In\u00a0[\u00a0]: Copied! <pre>noise_model = noise.GeminiOneZoneNoiseModel()\nnoisy_ghz_circuit_3 = noise.transform_circuit(ghz_circuit_3, model=noise_model)\nprint(noisy_ghz_circuit_3)\n</pre> noise_model = noise.GeminiOneZoneNoiseModel() noisy_ghz_circuit_3 = noise.transform_circuit(ghz_circuit_3, model=noise_model) print(noisy_ghz_circuit_3) <p>As you can see, we have successfully added noise. However, the circuit also looks very different in terms of its gates.</p> <p>This is because <code>noise.transform_circuit</code> does actually two things:</p> <ol> <li>Since we want to consider a circuit that is compatible with the Gemini architecture, we need to transform it to the native gate set first. This set consists of (phased) X gates and CZ gates only.</li> <li>Once we have a native circuit, noise is injected according to the chosen noise model.</li> </ol> <p>To clarify, here is how you would convert the circuit without using the <code>noise.transform_circuit</code> utility function:</p> In\u00a0[\u00a0]: Copied! <pre>native_ghz_3 = transpile(ghz_circuit_3)\nprint(native_ghz_3)\n</pre> native_ghz_3 = transpile(ghz_circuit_3) print(native_ghz_3) <p>Note that <code>transpile</code> basically just wraps cirq's own <code>cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())</code>, with some additional benefits (such as filtering out empty moments).</p> <p>Using this native circuit, we can obtain the same noisy circuit as before by simply using cirq's <code>cirq.Circuit.with_noise</code> method.</p> In\u00a0[\u00a0]: Copied! <pre>noisy_ghz_circuit_3 = native_ghz_3.with_noise(noise_model)\nprint(noisy_ghz_circuit_3)\n</pre> noisy_ghz_circuit_3 = native_ghz_3.with_noise(noise_model) print(noisy_ghz_circuit_3) <p>Fidelity calculation</p> <p>     In the following, we will simply use the expectation value of the noisy density matrix computed against the noiseless one as a proxy for fidelity.     This is a suboptimal choice, but we wanted to keep the example simple.     Feel free to substitute the fidelity calculation by the fidelity of your choice (e.g. the Uhlmann fidelity) </p> In\u00a0[\u00a0]: Copied! <pre>qubits = range(3, 9)\n\none_zone_model = noise.GeminiOneZoneNoiseModel()\ntwo_zone_model = noise.GeminiTwoZoneNoiseModel()\nsimulator = cirq.DensityMatrixSimulator()\n\nfidelities_one_zone = []\nfidelities_two_zone = []\nfor n in qubits:\n    circuit = ghz_circuit(n)\n    one_zone_circuit = noise.transform_circuit(circuit, model=one_zone_model)\n    two_zone_circuit = noise.transform_circuit(circuit, model=two_zone_model)\n\n    rho = simulator.simulate(circuit).final_density_matrix\n    rho_one_zone = simulator.simulate(one_zone_circuit).final_density_matrix\n    rho_two_zone = simulator.simulate(two_zone_circuit).final_density_matrix\n\n    fidelity_one_zone = np.trace(rho @ rho_one_zone)\n    fidelity_two_zone = np.trace(rho @ rho_two_zone)\n\n    fidelities_one_zone.append(fidelity_one_zone)\n    fidelities_two_zone.append(fidelity_two_zone)\n</pre> qubits = range(3, 9)  one_zone_model = noise.GeminiOneZoneNoiseModel() two_zone_model = noise.GeminiTwoZoneNoiseModel() simulator = cirq.DensityMatrixSimulator()  fidelities_one_zone = [] fidelities_two_zone = [] for n in qubits:     circuit = ghz_circuit(n)     one_zone_circuit = noise.transform_circuit(circuit, model=one_zone_model)     two_zone_circuit = noise.transform_circuit(circuit, model=two_zone_model)      rho = simulator.simulate(circuit).final_density_matrix     rho_one_zone = simulator.simulate(one_zone_circuit).final_density_matrix     rho_two_zone = simulator.simulate(two_zone_circuit).final_density_matrix      fidelity_one_zone = np.trace(rho @ rho_one_zone)     fidelity_two_zone = np.trace(rho @ rho_two_zone)      fidelities_one_zone.append(fidelity_one_zone)     fidelities_two_zone.append(fidelity_two_zone) <p>Now, let's have a look at the results.</p> In\u00a0[\u00a0]: Copied! <pre>plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\")\nplt.plot(qubits, fidelities_two_zone, \"x\", label=\"two-zone model\")\nplt.xlabel(\"Number of qubits\")\nplt.ylabel(\"Fidelity\")\nplt.legend()\n</pre> plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\") plt.plot(qubits, fidelities_two_zone, \"x\", label=\"two-zone model\") plt.xlabel(\"Number of qubits\") plt.ylabel(\"Fidelity\") plt.legend() <p>We can see that in both cases the fidelity goes down when increasing the number of qubits.</p> <p>Interestingly, there is a cross-over point where the two-zone model starts to exhibit a better fidelity. This is because as the number of qubits grows, the error introduced on idle qubits inside the gate zone is larger in the one-zone model since all qubits are always inside the gate zone. Whereas, in the two-zone model, qubits are moved between the gate and storage zones.</p> <p>You could now think about how to optimize the circuits in order to reduce their sensitivity for noise. For example, you can reduce the circuit depth</p> In\u00a0[\u00a0]: Copied! <pre>default_model = noise.GeminiTwoZoneNoiseModel()\npx, py, pz = default_model.mover_px, default_model.mover_py, default_model.mover_pz\nprint(\n    f\"The noise Pauli channel associated with moving atoms is (px, py, pz) = ({px,py,pz}).\"\n)\n</pre> default_model = noise.GeminiTwoZoneNoiseModel() px, py, pz = default_model.mover_px, default_model.mover_py, default_model.mover_pz print(     f\"The noise Pauli channel associated with moving atoms is (px, py, pz) = ({px,py,pz}).\" ) <p>Then we can instantiate a noise model with modified parameters:</p> In\u00a0[\u00a0]: Copied! <pre>modified_two_zone_model = noise.GeminiTwoZoneNoiseModel(\n    mover_px=2e-3,\n    mover_py=2e-3,\n    mover_pz=3e-3,\n)\nfidelities_modified_two_zone = []\nfor n in qubits:\n    circuit = ghz_circuit(n)\n    noisy_circuit = noise.transform_circuit(circuit, model=modified_two_zone_model)\n    rho = simulator.simulate(circuit).final_density_matrix\n    rho_noisy = simulator.simulate(noisy_circuit).final_density_matrix\n    fidelities_modified_two_zone.append(np.trace(rho @ rho_noisy))\n</pre> modified_two_zone_model = noise.GeminiTwoZoneNoiseModel(     mover_px=2e-3,     mover_py=2e-3,     mover_pz=3e-3, ) fidelities_modified_two_zone = [] for n in qubits:     circuit = ghz_circuit(n)     noisy_circuit = noise.transform_circuit(circuit, model=modified_two_zone_model)     rho = simulator.simulate(circuit).final_density_matrix     rho_noisy = simulator.simulate(noisy_circuit).final_density_matrix     fidelities_modified_two_zone.append(np.trace(rho @ rho_noisy)) In\u00a0[\u00a0]: Copied! <pre>plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\")\nplt.plot(qubits, fidelities_modified_two_zone, \"x\", label=\"modified two-zone model\")\nplt.xlabel(\"Number of qubits\")\nplt.ylabel(\"Fidelity\")\nplt.legend()\n</pre> plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\") plt.plot(qubits, fidelities_modified_two_zone, \"x\", label=\"modified two-zone model\") plt.xlabel(\"Number of qubits\") plt.ylabel(\"Fidelity\") plt.legend() <p>As you can see, the fidelities no longer cross over since the increased movement noise now eliminates the advantage of the two-zone model for the considered numbers of qubits.</p> In\u00a0[\u00a0]: Copied! <pre>circuit = ghz_circuit(5)\nnoisy_circuit = noise.transform_circuit(circuit, model=noise.GeminiOneZoneNoiseModel())\n</pre> circuit = ghz_circuit(5) noisy_circuit = noise.transform_circuit(circuit, model=noise.GeminiOneZoneNoiseModel()) In\u00a0[\u00a0]: Copied! <pre>kernel = squin.cirq.load_circuit(circuit, kernel_name=\"kernel\")\nnoisy_kernel = squin.cirq.load_circuit(noisy_circuit, kernel_name=\"noisy_kernel\")\nkernel.print()\n</pre> kernel = squin.cirq.load_circuit(circuit, kernel_name=\"kernel\") noisy_kernel = squin.cirq.load_circuit(noisy_circuit, kernel_name=\"noisy_kernel\") kernel.print()"},{"location":"digital/examples/interop/noisy_ghz/#ghz-state-preparation-and-noise","title":"GHZ State preparation and noise\u00b6","text":"<p>In this example, we will illustrate how to work with <code>bloqade</code>'s heuristic noise models of Gemini class digital quantum processors by applying them to a circuit that prepares a GHZ state.</p>"},{"location":"digital/examples/interop/noisy_ghz/#primer-on-gemini-noise-models","title":"Primer on Gemini noise models\u00b6","text":"<p>In <code>bloqade</code>, there are two classes of heuristic noise models: one-zone models such as <code>GeminiOneZoneNoiseModel</code> and a two-zone model <code>GeminiTwoZoneNoiseModel</code>. These are inspired by two distinct approaches to implement a quantum circuit on hardware and are designed to get a sense of the influence of noise on Gemini class hardware.</p> <p>On the one hand, the one-zone model assumes a single-zone layout where qubits remain in the gate zone throughout the computation. On the other hand, the two-zone model incorporates a storage zone and assumes that qubits are transported between gate and storage regions.</p> <p>Both models are informed by benchmark data on the device but are intentionally conservative. Specifically, they tend to overestimate noise due to the lack of knowledge about optimized move schedules, which leads to overestimating move-induced errors.</p> <p>At this stage, we recommend interpreting the two models as providing a range for expected noise levels on Gemini-class devices, rather than precise predictions. They are useful for gaining intuition about noise sensitivity and for benchmarking algorithmic robustness to errors, using hardware-informed but simplistic assumptions.</p> <p>Note, that there are actually two additional one-zone noise models, <code>GeminiOneZoneNoiseModelCorrelated</code> and <code>GeminiOneZoneNoiseModelConflictGraphMoves</code>. As the names suggest, the former also takes into account correlated noise, whereas the latter takes into account more realistic move schedules. In the following example, we will not be considering these two, but they are interchangeable with the used noise models (up to the fact, that the conflict graph moves require you to specify qubits as <code>cirq.GridQubit</code>s).</p>"},{"location":"digital/examples/interop/noisy_ghz/#noise-model-implementations","title":"Noise model implementations\u00b6","text":"<p>For now, these noise models are implemented as <code>cirq.NoiseModel</code> classes, so that you can use with any circuit you build using <code>cirq</code>. They are part of the <code>bloqade.cirq_utils</code> submodule.</p> <p>Support for using these models with e.g. squin will follow in the future. However, you can already rely on interoperability with cirq in order to convert (noisy) circuits to squin kernels and use other parts of the compiler pipeline.</p>"},{"location":"digital/examples/interop/noisy_ghz/#ghz-preparation-and-noise","title":"GHZ preparation and noise\u00b6","text":"<p>Now, let's get started with the actual example.</p> <p>As a first step, we will define a function that builds a GHZ circuit in cirq that has a depth linear in the number of qubits.</p>"},{"location":"digital/examples/interop/noisy_ghz/#closer-look-at-a-basic-circuit","title":"Closer look at a basic circuit\u00b6","text":""},{"location":"digital/examples/interop/noisy_ghz/#studying-the-fidelity","title":"Studying the fidelity\u00b6","text":"<p>Now that we have got the basics down, we can compute the fidelity of noisy circuits with different qubit numbers. By fidelity, we simply mean the overlap of the final state with the perfect GHZ state expected from the noise-less version of the circuit.</p> <p>The corresponding density matrices are obtained using <code>cirq</code>'s simulator.</p> <p>We will do the simulation using two different noise models, the one-zone model used above and also the two-zone model.</p>"},{"location":"digital/examples/interop/noisy_ghz/#modifying-the-noise","title":"Modifying the noise\u00b6","text":"<p>There are a number of parameters that govern the effect a noise model introduces into a circuit. These can all be set independently to adapt the noise model to your specific application.</p> <p>In general, there are noise parameters for the following noise processes:</p> <ul> <li>Depolarization due to gate application.</li> <li>Depolarization due to movement, both applied to moving atoms and idle atoms (a.k.a. sitter errors).</li> <li>Atom loss errors.</li> </ul> <p>Atom loss</p> <p>     Please note, that atom loss is currently not supported, i.e. it's not considered in the noise models.     We plan to add that in the future. </p> <p>The noise processes are further split into local and global noise channels and separated by their cause.</p> <p>For a full list of noise parameters and a description of each one, please refer to the move noise model in <code>bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC</code></p> <p>We can use those parameters in order to modify the strength of the noise.</p> <p>For example, say you want to introduce an extra penalty for moving qubits around in order to study how you can reduce movements. To do so, let's re-use the fidelity calculation using the two-zone model from above, but modify movement errors. We can query the default move errors from the <code>cirq</code> noise model:</p>"},{"location":"digital/examples/interop/noisy_ghz/#interoperability-with-squin","title":"Interoperability with squin\u00b6","text":"<p>Finally, we want to point out that you can also use the generated noisy circuits to obtain a squin kernel function.</p> <p>This is useful if you want to use other features of the bloqade pipeline. For example, it would allow you to run the <code>pyqrack</code> simulator instead of <code>cirq</code>'s own, which can be more efficient.</p>"},{"location":"digital/examples/qasm2/ghz/","title":"GHZ State Preparation with Parallelism","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom kirin.dialects import ilist\n\nfrom bloqade import qasm2\n</pre> import math  from kirin.dialects import ilist  from bloqade import qasm2 In\u00a0[\u00a0]: Copied! <pre>def ghz_linear(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def ghz_linear_program():\n\n        qreg = qasm2.qreg(n_qubits)\n        # Apply a Hadamard on the first qubit\n        qasm2.h(qreg[0])\n        # Create a cascading sequence of CX gates\n        # necessary for quantum computers that\n        # only have nearest-neighbor connectivity between qubits\n        for i in range(1, n_qubits):\n            qasm2.cx(qreg[i - 1], qreg[i])\n\n    return ghz_linear_program\n</pre> def ghz_linear(n: int):     n_qubits = int(2**n)      @qasm2.extended     def ghz_linear_program():          qreg = qasm2.qreg(n_qubits)         # Apply a Hadamard on the first qubit         qasm2.h(qreg[0])         # Create a cascading sequence of CX gates         # necessary for quantum computers that         # only have nearest-neighbor connectivity between qubits         for i in range(1, n_qubits):             qasm2.cx(qreg[i - 1], qreg[i])      return ghz_linear_program <p>Circuit vs. Execution Depth</p> <p> Before going any further, it's worth distinguishing between the concept of circuit depth and circuit execution depth. For example, in the following implementation, each CX gate instruction inside the for-loop is executed in sequence. So even though the circuit depth is $log(N) = n$, the circuit execution depth is still $N$. </p> In\u00a0[\u00a0]: Copied! <pre>def ghz_log_depth(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer_of_cx(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n        for j in range(0, n_qubits, step):\n            qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer_of_cx(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_depth(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer_of_cx(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)         for j in range(0, n_qubits, step):             qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer_of_cx(i_layer=i, qreg=qreg)      return ghz_log_depth_program In\u00a0[\u00a0]: Copied! <pre>def ghz_log_simd(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n\n        def get_qubit(x: int):\n            return qreg[x]\n\n        ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))\n        targ_qubits = ilist.Map(\n            fn=get_qubit, collection=range(step // 2, n_qubits, step)\n        )\n\n        # Ry(-pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)\n\n        # CZ gates\n        qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)\n\n        # Ry(pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_simd(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)          def get_qubit(x: int):             return qreg[x]          ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))         targ_qubits = ilist.Map(             fn=get_qubit, collection=range(step // 2, n_qubits, step)         )          # Ry(-pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)          # CZ gates         qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)          # Ry(pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer(i_layer=i, qreg=qreg)      return ghz_log_depth_program <p>Using Closures to Capture Global Variables</p> <p> While bloqade.qasm2 permits a main program with arguments, standard QASM2 does not. To get around this, we need to put the program in a closure. Our Kirin compiler toolchain can capture the global variable inside the closure. In this case, the n_qubits will be captured upon calling the ghz_log_simd(n_qubits) python function. As a result, the returned QASM2 program will not have any arguments. </p> In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2(\n    allow_parallel=True,\n)\nast = target.emit(ghz_log_simd(4))\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2(     allow_parallel=True, ) ast = target.emit(ghz_log_simd(4)) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qasm2/ghz/#ghz-state-preparation-with-parallelism","title":"GHZ State Preparation with Parallelism\u00b6","text":"<p>In this example, we will implement a Greenberger-Horne-Zeilinger (GHZ) state preparation circuit with $N = 2^n$ qubits.</p> <p>First, we will present the standard linear-depth construction in Bloqade but later we will present a log-depth construction that achieves the same result. We then take this one step further and use the fact that Bloqade (and QuEra's neutral atom hardware!) support parallel gates, allowing for the application of the same gate across multiple qubits simultaneously. Combined with the fact that atom shuttling allows for arbitrary connectivity, we can also decrease the circuit execution depth from $N$ to just $n$.</p>"},{"location":"digital/examples/qasm2/ghz/#simple-linear-depth-implementation-of-a-ghz-state-preparation-circuit","title":"Simple Linear Depth Implementation of a GHZ State Preparation Circuit\u00b6","text":"<p>A simple GHZ state preparation circuit can be built with $N - 1$ CX gates and $1$ H gate. This gives the circuit an execution depth of $N$.</p>"},{"location":"digital/examples/qasm2/ghz/#log-depth-implementation-of-a-ghz-state-preparation-circuit","title":"Log-depth Implementation of a GHZ State Preparation Circuit\u00b6","text":"<p>Let's take a look how we can rewrite the circuit to take advantage of QuEra's hardware capabilities. We can achieve log(N) circuit depth by rearranging the CX gates (see Mooney, White, Hill, Hollenberg - 2021).</p>"},{"location":"digital/examples/qasm2/ghz/#our-native-gate-set-and-parallelism","title":"Our Native Gate Set and Parallelism\u00b6","text":"<p>By nature, our digital quantum computer can execute native gates in parallel in an single instruction/ execution cycle. The concept is very similar to the SIMD (Single Instruction, Multiple Data) in classical computing.</p> <p>On our hardware, there are two important factors to be considered:</p> <ol> <li>the native gate set allows for arbitrary (parallel) rotations and (parallel) CZ gates.</li> <li>Our atom shuttling architecture allows arbitrary qubit connectivity. This means that our parallel instruction is not limited to fixed connectivity (for example nearest neighbor connectivity).</li> </ol> <p>With this in mind, we can rewrite the <code>layer</code> subroutine to now use the <code>qasm2.parallel</code> dialect in Bloqade. We know that the CX gate can be decomposed into a CZ gate with two single-qubit gates $R_y(-\\pi/2)$ and $R_y(\\pi/2)$ acting on the target qubits. With this decomposition in mind, we can now using our parallel gate instructions <code>parallel.u</code> and <code>parallel.cz</code>. With the following modification, we can further reduce the circuit execution depth to just $n$ (log of the total number of qubits $N$)</p>"},{"location":"digital/examples/qasm2/pauli_exponentiation/","title":"Pauli Exponentiation for Quantum Simulation","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade import qasm2\n</pre> import math  from bloqade import qasm2 <p>First, we define the <code>zzzz_gadget</code> function which is a simple implementation of Pauli Z exponentiation with a parameterized angle <code>gamma</code>.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef zzzz_gadget(targets: tuple[qasm2.Qubit, ...], gamma: float):\n    for i in range(len(targets) - 1):\n        qasm2.cx(targets[i], targets[i + 1])\n\n    qasm2.rz(targets[-1], gamma)\n\n    for j in range(len(targets) - 1):\n        qasm2.cx(targets[-j - 1], targets[-j - 2])\n</pre> @qasm2.extended def zzzz_gadget(targets: tuple[qasm2.Qubit, ...], gamma: float):     for i in range(len(targets) - 1):         qasm2.cx(targets[i], targets[i + 1])      qasm2.rz(targets[-1], gamma)      for j in range(len(targets) - 1):         qasm2.cx(targets[-j - 1], targets[-j - 2]) <p>Next, we define the <code>pauli_basis_change</code> function which is a simple implementation of Pauli basis change with a parameterized start and end Pauli basis.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef pauli_basis_change(targets: tuple[qasm2.Qubit, ...], start: str, end: str):\n    # assert len(targets) == len(start)\n    # assert len(targets) == len(end)\n\n    # for qubit, start_pauli, end_pauli in zip(targets, start, end):\n    for i in range(len(targets)):\n        qubit = targets[i]\n        start_pauli = start[i]\n        end_pauli = end[i]\n\n        target = start_pauli + end_pauli\n        if target == \"ZX\":\n            qasm2.ry(qubit, math.pi / 2)\n        elif target == \"ZY\":\n            qasm2.rx(qubit, -math.pi / 2)\n        # elif target == \"ZZ\":\n        #     pass\n        # elif target == \"XX\":\n        #     pass\n        elif target == \"XY\":\n            qasm2.rz(qubit, math.pi / 2)\n        elif target == \"XZ\":\n            qasm2.ry(qubit, -math.pi / 2)\n        elif target == \"YX\":\n            qasm2.rz(qubit, -math.pi / 2)\n        # elif target == \"YY\":\n        #     pass\n        elif target == \"YZ\":\n            qasm2.rx(qubit, math.pi / 2)\n</pre> @qasm2.extended def pauli_basis_change(targets: tuple[qasm2.Qubit, ...], start: str, end: str):     # assert len(targets) == len(start)     # assert len(targets) == len(end)      # for qubit, start_pauli, end_pauli in zip(targets, start, end):     for i in range(len(targets)):         qubit = targets[i]         start_pauli = start[i]         end_pauli = end[i]          target = start_pauli + end_pauli         if target == \"ZX\":             qasm2.ry(qubit, math.pi / 2)         elif target == \"ZY\":             qasm2.rx(qubit, -math.pi / 2)         # elif target == \"ZZ\":         #     pass         # elif target == \"XX\":         #     pass         elif target == \"XY\":             qasm2.rz(qubit, math.pi / 2)         elif target == \"XZ\":             qasm2.ry(qubit, -math.pi / 2)         elif target == \"YX\":             qasm2.rz(qubit, -math.pi / 2)         # elif target == \"YY\":         #     pass         elif target == \"YZ\":             qasm2.rx(qubit, math.pi / 2) <p>Putting it all together, we define the <code>pauli_exponential</code> function which is a simple implementation of Pauli Exponentiation with a parameterized Pauli basis and angle <code>gamma</code>.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef pauli_exponential(targets: tuple[qasm2.Qubit, ...], pauli: str, gamma: float):\n    # assert len(targets) == len(pauli)\n\n    pauli_basis_change(targets=targets, start=\"Z\" * len(targets), end=pauli)\n    zzzz_gadget(targets=targets, gamma=gamma)\n    pauli_basis_change(targets=targets, start=pauli, end=\"Z\" * len(targets))\n</pre> @qasm2.extended def pauli_exponential(targets: tuple[qasm2.Qubit, ...], pauli: str, gamma: float):     # assert len(targets) == len(pauli)      pauli_basis_change(targets=targets, start=\"Z\" * len(targets), end=pauli)     zzzz_gadget(targets=targets, gamma=gamma)     pauli_basis_change(targets=targets, start=pauli, end=\"Z\" * len(targets)) <p>Finally, we define the <code>main</code> function as the entry point of the program.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    register = qasm2.qreg(4)\n    pauli_exponential((register[0], register[1], register[2]), \"ZXY\", 0.5)\n</pre> @qasm2.extended def main():     register = qasm2.qreg(4)     pauli_exponential((register[0], register[1], register[2]), \"ZXY\", 0.5) <p>we can now ask the compiler to emit the QASM2 code for the <code>main</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2()\nast = target.emit(main)\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2() ast = target.emit(main) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qasm2/pauli_exponentiation/#pauli-exponentiation-for-quantum-simulation","title":"Pauli Exponentiation for Quantum Simulation\u00b6","text":"<p>In this example, we will consider a simple Pauli Exponentiation circuit.</p>"},{"location":"digital/examples/qasm2/qaoa/","title":"QAOA","text":"<p>Lets do a simple example of a prototype circuit that benefits from parallelism: QAOA solving the MaxCut problem. For more details, see arXiv:1411.4028 and the considerable literature that has developed around this algorithm.</p> In\u00a0[\u00a0]: Copied! <pre>import math\nfrom typing import Any\n\nimport kirin\nimport networkx as nx\nfrom kirin.dialects import ilist\n\nfrom bloqade import qasm2\n\npi = math.pi\n</pre> import math from typing import Any  import kirin import networkx as nx from kirin.dialects import ilist  from bloqade import qasm2  pi = math.pi <p>MaxCut is a combinatorial graph problem that seeks to bi-partition the nodes of some graph G such that the number of edges between the two partitions is maximized. Here, we choose a random 3 regular graph with 32 nodes ref</p> In\u00a0[\u00a0]: Copied! <pre>N = 32\nG = nx.random_regular_graph(3, N, seed=42)\n</pre> N = 32 G = nx.random_regular_graph(3, N, seed=42) <p>To build the quantum program, we use a builder function and use closure to pass variables inside of the kernel function (kirin methods). In this case, the two variables that are passed inside are the edges and nodes of the graph.</p> <p>The QAOA first prepares the |+&gt; state as a superposition of all possible bitstrings, then repeats between the (diagonal) cost function and the mixer X with angles gamma and beta. It is parameterized by gamma and betas, which are each the p length lists of angles.</p> <p>Lets first implement the sequential version of the QAOA algorithm, which does not inform any parallelism to the compiler.</p> In\u00a0[\u00a0]: Copied! <pre>def qaoa_sequential(G: nx.Graph) -&gt; kirin.ir.Method:\n\n    edges = list(G.edges)\n    nodes = list(G.nodes)\n    N = len(nodes)\n\n    @qasm2.extended\n    def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):\n        # Initialize the register in the |+&gt; state\n        q = qasm2.qreg(N)\n        for i in range(N):  # structural control flow is native to the Kirin compiler\n            qasm2.h(q[i])\n\n        # Repeat the cost and mixer layers\n        for i in range(len(gamma)):\n            # The cost layer, which corresponds to a ZZ(phase) gate applied\n            # to each edge of the graph\n            for j in range(len(edges)):\n                edge = edges[j]\n                qasm2.cx(q[edge[0]], q[edge[1]])\n                qasm2.rz(q[edge[1]], gamma[i])\n                qasm2.cx(q[edge[0]], q[edge[1]])\n            # The mixer layer, which corresponds to a X(phase) gate applied\n            # to each node of the graph\n            for j in range(N):\n                qasm2.rx(q[j], beta[i])\n\n        return q\n\n    return kernel\n</pre> def qaoa_sequential(G: nx.Graph) -&gt; kirin.ir.Method:      edges = list(G.edges)     nodes = list(G.nodes)     N = len(nodes)      @qasm2.extended     def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):         # Initialize the register in the |+&gt; state         q = qasm2.qreg(N)         for i in range(N):  # structural control flow is native to the Kirin compiler             qasm2.h(q[i])          # Repeat the cost and mixer layers         for i in range(len(gamma)):             # The cost layer, which corresponds to a ZZ(phase) gate applied             # to each edge of the graph             for j in range(len(edges)):                 edge = edges[j]                 qasm2.cx(q[edge[0]], q[edge[1]])                 qasm2.rz(q[edge[1]], gamma[i])                 qasm2.cx(q[edge[0]], q[edge[1]])             # The mixer layer, which corresponds to a X(phase) gate applied             # to each node of the graph             for j in range(N):                 qasm2.rx(q[j], beta[i])          return q      return kernel <p>Next, lets implement a SIMD (Single Instruction, Multiple Data) version of the QAOA algorithm, which effectively represents the parallelism in the QAOA algorithm. This can be done by coloring the (commuting) ZZ(phase) gates into groups with non-overlapping sets of qubits, and then applying each of those groups in parallel. By Vizing's theorem the edges of a graph can efficiently be colored into $\\Delta+1$ colors, where $\\Delta$ is the maximum degree of the graph. Unfortunately, networkx does not have a native implementation of the algorithm so instead we use the lesser [Brooks' theorem]https://en.wikipedia.org/wiki/Brooks%27_theorem) to color the edges using an equitable coloring of the line graph.</p> In\u00a0[\u00a0]: Copied! <pre>def qaoa_simd(G: nx.Graph) -&gt; kirin.ir.Method:\n\n    nodes = list(G.nodes)\n\n    # Note that graph computation is happening /outside/ the kernel function:\n    # this is a computation that occurs on your laptop in Python when you generate\n    # a program, as opposed to on a piece of quantum hardware, which is what\n    # occurs inside of the kernel.\n    Gline = nx.line_graph(G)\n    colors = nx.algorithms.coloring.equitable_color(Gline, num_colors=5)\n    left_ids = ilist.IList(\n        [\n            ilist.IList([edge[0] for edge in G.edges if colors[edge] == i])\n            for i in range(5)\n        ]\n    )\n    right_ids = ilist.IList(\n        [\n            ilist.IList([edge[1] for edge in G.edges if colors[edge] == i])\n            for i in range(5)\n        ]\n    )\n    # We can use composition of kernel functions to simplify repeated code.\n    # Small snippets (say, the CX gate) can be written once and then called\n    # many times.\n\n    @qasm2.extended\n    def parallel_h(qargs: ilist.IList[qasm2.Qubit, Any]):\n        qasm2.parallel.u(qargs=qargs, theta=pi / 2, phi=0.0, lam=pi)\n\n    # A parallel CX gate is equivalently a parallel H gate, followed by a parallel CZ gate,\n    # followed by another parallel H. the CZ can be done in any order as they permute.\n    @qasm2.extended\n    def parallel_cx(\n        ctrls: ilist.IList[qasm2.Qubit, Any], qargs: ilist.IList[qasm2.Qubit, Any]\n    ):\n        parallel_h(qargs)\n        qasm2.parallel.cz(ctrls, qargs)\n        parallel_h(qargs)\n\n    @qasm2.extended\n    def parallel_cz_phase(\n        ctrls: ilist.IList[qasm2.Qubit, Any],\n        qargs: ilist.IList[qasm2.Qubit, Any],\n        gamma: float,\n    ):\n        parallel_cx(ctrls, qargs)\n        qasm2.parallel.rz(qargs, gamma)\n        parallel_cx(ctrls, qargs)\n\n    @qasm2.extended\n    def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):\n        # Declare the register and set it to the |+&gt; state\n        q = qasm2.qreg(len(nodes))\n        # qasm2.glob.u(theta=pi / 2, phi=0.0, lam=pi,registers=[q])\n\n        def get_qubit(x: int):\n            return q[x]\n\n        all_qubits = ilist.map(fn=get_qubit, collection=range(N))\n\n        parallel_h(all_qubits)\n\n        for i in range(len(gamma)):  # For each QAOA layer...\n            # Do the ZZ phase gates...\n            for cind in range(\n                5\n            ):  # by applying a parallel CZ phase gate in parallel for each color,\n                ctrls = ilist.map(fn=get_qubit, collection=left_ids[cind])\n                qargs = ilist.map(fn=get_qubit, collection=right_ids[cind])\n                parallel_cz_phase(ctrls, qargs, gamma[i])\n            # ...then, do an X phase gate. Observe that because this happens on every\n            # qubit, we can do a global rotation, which is higher fidelity than\n            # parallel local rotations.\n            # qasm2.glob.u(theta=beta[i],phi=0.0,lam=0.0,registers=[q])\n            qasm2.parallel.u(qargs=all_qubits, theta=beta[i], phi=0.0, lam=0.0)\n\n        return q\n\n    return kernel\n</pre> def qaoa_simd(G: nx.Graph) -&gt; kirin.ir.Method:      nodes = list(G.nodes)      # Note that graph computation is happening /outside/ the kernel function:     # this is a computation that occurs on your laptop in Python when you generate     # a program, as opposed to on a piece of quantum hardware, which is what     # occurs inside of the kernel.     Gline = nx.line_graph(G)     colors = nx.algorithms.coloring.equitable_color(Gline, num_colors=5)     left_ids = ilist.IList(         [             ilist.IList([edge[0] for edge in G.edges if colors[edge] == i])             for i in range(5)         ]     )     right_ids = ilist.IList(         [             ilist.IList([edge[1] for edge in G.edges if colors[edge] == i])             for i in range(5)         ]     )     # We can use composition of kernel functions to simplify repeated code.     # Small snippets (say, the CX gate) can be written once and then called     # many times.      @qasm2.extended     def parallel_h(qargs: ilist.IList[qasm2.Qubit, Any]):         qasm2.parallel.u(qargs=qargs, theta=pi / 2, phi=0.0, lam=pi)      # A parallel CX gate is equivalently a parallel H gate, followed by a parallel CZ gate,     # followed by another parallel H. the CZ can be done in any order as they permute.     @qasm2.extended     def parallel_cx(         ctrls: ilist.IList[qasm2.Qubit, Any], qargs: ilist.IList[qasm2.Qubit, Any]     ):         parallel_h(qargs)         qasm2.parallel.cz(ctrls, qargs)         parallel_h(qargs)      @qasm2.extended     def parallel_cz_phase(         ctrls: ilist.IList[qasm2.Qubit, Any],         qargs: ilist.IList[qasm2.Qubit, Any],         gamma: float,     ):         parallel_cx(ctrls, qargs)         qasm2.parallel.rz(qargs, gamma)         parallel_cx(ctrls, qargs)      @qasm2.extended     def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):         # Declare the register and set it to the |+&gt; state         q = qasm2.qreg(len(nodes))         # qasm2.glob.u(theta=pi / 2, phi=0.0, lam=pi,registers=[q])          def get_qubit(x: int):             return q[x]          all_qubits = ilist.map(fn=get_qubit, collection=range(N))          parallel_h(all_qubits)          for i in range(len(gamma)):  # For each QAOA layer...             # Do the ZZ phase gates...             for cind in range(                 5             ):  # by applying a parallel CZ phase gate in parallel for each color,                 ctrls = ilist.map(fn=get_qubit, collection=left_ids[cind])                 qargs = ilist.map(fn=get_qubit, collection=right_ids[cind])                 parallel_cz_phase(ctrls, qargs, gamma[i])             # ...then, do an X phase gate. Observe that because this happens on every             # qubit, we can do a global rotation, which is higher fidelity than             # parallel local rotations.             # qasm2.glob.u(theta=beta[i],phi=0.0,lam=0.0,registers=[q])             qasm2.parallel.u(qargs=all_qubits, theta=beta[i], phi=0.0, lam=0.0)          return q      return kernel In\u00a0[\u00a0]: Copied! <pre>print(\"--- Sequential ---\")\nqaoa_sequential(G).code.print()\n</pre> print(\"--- Sequential ---\") qaoa_sequential(G).code.print() In\u00a0[\u00a0]: Copied! <pre>kernel = qaoa_simd(G)\n\nprint(\"\\n\\n--- Simd ---\")\nkernel.print()\n</pre> kernel = qaoa_simd(G)  print(\"\\n\\n--- Simd ---\") kernel.print() In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    kernel([0.1, 0.2], [0.3, 0.4])\n</pre> @qasm2.extended def main():     kernel([0.1, 0.2], [0.3, 0.4]) In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2()\nast = target.emit(main)\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2() ast = target.emit(main) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qasm2/qft/","title":"Quantum Fourier Transform","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade.pyqrack import StackMemorySimulator\n\nfrom bloqade import qasm2\n</pre> import math  from bloqade.pyqrack import StackMemorySimulator  from bloqade import qasm2 <p>In the following, we will define the Quantum Fourier Transform (QFT) circuit using recursion inside a kernel function <code>qft</code>. The <code>qft</code> function takes two arguments: a quantum register <code>qreg</code> and an integer <code>n</code> representing the number of qubits we want to apply the QFT circuit to.</p> In\u00a0[\u00a0]: Copied! <pre>pi = math.pi\n\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int, k: int):\n    if k == n:\n        return qreg\n\n    qasm2.h(qreg[k])\n    for i in range(k + 1, n):\n        qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)\n    qft(qreg, n, k + 1)  # recursion\n    return qreg\n</pre> pi = math.pi   @qasm2.extended def qft(qreg: qasm2.QReg, n: int, k: int):     if k == n:         return qreg      qasm2.h(qreg[k])     for i in range(k + 1, n):         qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)     qft(qreg, n, k + 1)  # recursion     return qreg <p>Next, we will call this kernel function <code>qft</code> inside a <code>main</code> function to check if the QFT circuit is correctly implemented. We will use a quantum register of size 3.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    return qft(qasm2.qreg(3), 3, 0)\n</pre> @qasm2.extended def main():     return qft(qasm2.qreg(3), 3, 0) <p>Finally, we will run the <code>main</code> function on the <code>PyQrack</code> backend and print the quantum register to see the final state of the qubits after applying the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>device = StackMemorySimulator(min_qubits=3)\nqreg = device.run(main)\nprint(qreg)\n</pre> device = StackMemorySimulator(min_qubits=3) qreg = device.run(main) print(qreg) <p>we can also emit the QASM2 code for the <code>main</code> function and print it to see the QASM2 code that corresponds to the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.qasm2.emit import QASM2  # noqa: E402\nfrom bloqade.qasm2.parse import pprint  # noqa: E402\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</pre> from bloqade.qasm2.emit import QASM2  # noqa: E402 from bloqade.qasm2.parse import pprint  # noqa: E402  target = QASM2() ast = target.emit(main) pprint(ast)"},{"location":"digital/examples/qasm2/qft/#quantum-fourier-transform","title":"Quantum Fourier Transform\u00b6","text":"<p>In this example, we will explore the Quantum Fourier Transform (QFT) circuit using recursion and iteration -- a convenient way to implement the QFT circuit using our high-level programming features.</p> <p>To begin, we will import the <code>qasm2</code> module from the <code>bloqade</code> package and the <code>PyQrack</code> backend from the <code>bloqade.pyqrack</code> module.</p>"},{"location":"digital/examples/qasm2/repeat_until_success/","title":"Repeat Until Success with STAR Gadget","text":"In\u00a0[\u00a0]: Copied! <pre>from bloqade import qasm2\n</pre> from bloqade import qasm2 <p>This example highlights a few interesting capabilities of having a full kernel structure with runtime control flow. One example is the ability to dynamically allocate qubits, possibly based on previous run-time measurement outcomes.</p> <p>In this case, we prepare a resource state, which is a generalization of the T state with an arbitrary Z rotation $|0\\rangle + e^{i\\theta}|1\\rangle$.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef prep_resource_state(theta: float):\n    qreg = qasm2.qreg(1)\n    qubit = qreg[0]\n    qasm2.h(qubit)\n    qasm2.rz(qubit, theta)\n    return qubit\n</pre> @qasm2.extended def prep_resource_state(theta: float):     qreg = qasm2.qreg(1)     qubit = qreg[0]     qasm2.h(qubit)     qasm2.rz(qubit, theta)     return qubit <p>Using this resource state, we can teleport the Z phase gate to a target qubit using only Clifford gates, which are much easier to implement fault-tolerantly. This is implemented by first applying a CNOT gate controlled by the resource state on the target qubit, then measuring the target qubit in the computational basis. If the measurement outcome is 1 (which occurs with 50% probability), the gadget executed a Z(theta) gate on the target qubit and teleported it to the new resource state.</p> <p>However, if the measurement outcome is 0 (which occurs with 50% probability), we apply an X gate, and the gadget executed a Z(-theta) gate on the target qubit. In order to correct this gate, we must apply a Z(+2theta) gate on the new target state. Of course, we can apply this Z(+2theta) gate by applying the same gadget with twice the angle, and repeat until we get the correct outcome.</p> <p>The simplest way to implement the gadget is to simply post-select the correct measurement outcome using an assert statement. This is straightforward, but comes with an exponential overhead in the number of resource states: there is a 50% chance of success at each step, so there is only a $2^{-n}$ chance of success after $n$ Z phase gates.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_postselect(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:\n    ancilla = prep_resource_state(theta)\n    qasm2.cx(ancilla, target)\n    creg = qasm2.creg(1)\n    qasm2.measure(target, creg[0])\n    if creg[0] == 1:\n        qasm2.x(ancilla)\n    return ancilla\n</pre> @qasm2.extended def z_phase_gate_postselect(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:     ancilla = prep_resource_state(theta)     qasm2.cx(ancilla, target)     creg = qasm2.creg(1)     qasm2.measure(target, creg[0])     if creg[0] == 1:         qasm2.x(ancilla)     return ancilla <p>To (deterministically) implement the gate, we can recursively apply the gadget by correcting the angle of the Z gate by applying Z(+2*theta). Observe that, while it is efficient to represent this as a composition of kernels, there is no equivalent representation as a circuit, as the number of resource qubits and total number of gates is not known until runtime.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_recursive(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    ancilla = prep_resource_state(theta)\n    qasm2.cx(ancilla, target)\n    creg = qasm2.creg(1)\n    qasm2.measure(target, creg[0])\n    if creg[0] == 0:\n        return z_phase_gate_recursive(ancilla, 2 * theta)\n    if creg[0] == 1:\n        qasm2.x(ancilla)\n    return ancilla\n</pre> @qasm2.extended def z_phase_gate_recursive(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     ancilla = prep_resource_state(theta)     qasm2.cx(ancilla, target)     creg = qasm2.creg(1)     qasm2.measure(target, creg[0])     if creg[0] == 0:         return z_phase_gate_recursive(ancilla, 2 * theta)     if creg[0] == 1:         qasm2.x(ancilla)     return ancilla <p>An alternative representation uses control flow to implement the same gate. If the number of repeats is fixed, this can be represented as a static circuit, though it would require a large number of resource qubits and may still fail with a small probability $2^{-attempts}$.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_loop(target: qasm2.Qubit, theta: float, attempts: int):\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    creg = qasm2.creg(1)  # Implicitly initialized to 0, thanks qasm...\n    for ctr in range(attempts):\n        ancilla = prep_resource_state(theta * (2**ctr))\n        if creg[0] == 0:\n            qasm2.cx(ancilla, target)\n            qasm2.measure(target, creg[0])\n            target = ancilla\n    qasm2.x(target)\n</pre> @qasm2.extended def z_phase_gate_loop(target: qasm2.Qubit, theta: float, attempts: int):     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     creg = qasm2.creg(1)  # Implicitly initialized to 0, thanks qasm...     for ctr in range(attempts):         ancilla = prep_resource_state(theta * (2**ctr))         if creg[0] == 0:             qasm2.cx(ancilla, target)             qasm2.measure(target, creg[0])             target = ancilla     qasm2.x(target) <p>Before we analyze these circuits, we must declare a main function which takes no inputs, as qasm2 does not support parameterized circuits or subcircuits.</p> In\u00a0[\u00a0]: Copied! <pre>theta = 0.1  # Specify some Z rotation angle. Note that this is being defined\n</pre> theta = 0.1  # Specify some Z rotation angle. Note that this is being defined <p>outside the main function and being used inside the function via closure.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef postselect_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_postselect(target[0], theta)\n\n\n@qasm2.extended\ndef recursion_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_recursive(target[0], theta)\n\n\n@qasm2.extended\ndef loop_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_loop(target[0], theta, 5)\n</pre> @qasm2.extended def postselect_main():     target = qasm2.qreg(1)     z_phase_gate_postselect(target[0], theta)   @qasm2.extended def recursion_main():     target = qasm2.qreg(1)     z_phase_gate_recursive(target[0], theta)   @qasm2.extended def loop_main():     target = qasm2.qreg(1)     z_phase_gate_loop(target[0], theta, 5) <p>Now lets explore running some interpreters on these circuits. We support the quantum emulation backend PyQrack, which simulates quantum circuits using state vectors.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import PyQrack  # noqa: E402\n\ndevice = PyQrack()\ndevice.run(postselect_main)\n</pre> from bloqade.pyqrack import PyQrack  # noqa: E402  device = PyQrack() device.run(postselect_main)"},{"location":"digital/examples/qasm2/repeat_until_success/#repeat-until-success-with-star-gadget","title":"Repeat Until Success with STAR Gadget\u00b6","text":"<p>In this example, we will demonstrate a near-term fault tolerant gadget which is a repeat-until-success protocol to implement a Z phase gate using a resource state (similar to a T state), Pauli gates, and feed-forward measurement.</p> <p>For more information, see https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337, especially Fig. 7.</p>"},{"location":"digital/examples/squin/deutsch_squin/","title":"Deutsch-Jozsa Algorithm","text":"<p>We start by loading in some stuff and defining some parameters.</p> In\u00a0[\u00a0]: Copied! <pre>import random\nfrom typing import Any\n\nfrom bloqade.types import Qubit\nfrom kirin.dialects import ilist\nfrom bloqade.pyqrack import StackMemorySimulator\n\nfrom bloqade import squin\n\nn_bits = 2\n</pre> import random from typing import Any  from bloqade.types import Qubit from kirin.dialects import ilist from bloqade.pyqrack import StackMemorySimulator  from bloqade import squin  n_bits = 2 <p>Now, before we can implement the actual algorithm, we need to define the oracles, i.e. the functions we want to check for.</p> <p>The problem is defined as follows: Given a bit string of length $n$, $x \\in \\{0, 1\\}^\\otimes n$, we have a function that is either constant or balanced.</p> <p>A constant function is defined as $f_\\text{const}(x) = c \\forall x$, where $c \\in \\{0, 1\\}$ is some constant value.</p> <p>A balanced function, on the other hand, is defined by</p> <p>$f_\\text{balanced}(x) = \\begin{cases} 0 \\, \\forall x \\in S(x), \\\\ 1 \\text{ else,} \\end{cases}$</p> <p>where $S(x)$ is an arbitrarily chosen half of all possible bit strings, i.e. $|S(x)| = 2^{n-1}$.</p> <p>For our example, we will be using $n + 1$ qubits, where $n$ store the bitstring $x$ and the result is stored in the last qubit. We'll be writing our oracle functions as squin kernels, which we can then later use in the actual algorithm implementation.</p> <p>In order to define our oracle functions, we can simply choose for the constant function to always return $1$, which we achieve by flipping the final qubit using an $X$ gate.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef f_constant(q: ilist.IList[Qubit, Any]):\n    # flip the final (result) qubit -- every bit string is mapped to 1\n    squin.gate.x(q[-1])\n</pre> @squin.kernel def f_constant(q: ilist.IList[Qubit, Any]):     # flip the final (result) qubit -- every bit string is mapped to 1     squin.gate.x(q[-1]) <p>For the balanced oracle we use the following approach: we use the first qubit as control in a $CX$ gate, which is applied to the resulting qubit. This means that the result will be $1$ in exactly half the cases.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef f_balanced(q: ilist.IList[Qubit, Any]):\n    squin.gate.cx(q[0], q[-1])\n</pre> @squin.kernel def f_balanced(q: ilist.IList[Qubit, Any]):     squin.gate.cx(q[0], q[-1]) <p>Now, we define the actual algorithm as a kernel, which simply takes one of the other kernels as input. In the end, we can infer which function was provided by looking at the resulting measurement of the result qubit.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef deutsch_algorithm(f):\n    q = squin.qubit.new(n_qubits=n_bits + 1)\n    squin.gate.x(q[-1])\n\n    # broadcast for parallelism\n    h = squin.op.h()\n    squin.qubit.broadcast(h, q)\n\n    # apply the oracle function\n    f(q)\n\n    squin.qubit.broadcast(h, q[:-1])\n\n    return squin.qubit.measure(q[:-1])\n</pre> @squin.kernel def deutsch_algorithm(f):     q = squin.qubit.new(n_qubits=n_bits + 1)     squin.gate.x(q[-1])      # broadcast for parallelism     h = squin.op.h()     squin.qubit.broadcast(h, q)      # apply the oracle function     f(q)      squin.qubit.broadcast(h, q[:-1])      return squin.qubit.measure(q[:-1]) <p>Finally, we actually run the result. To do so, we use the <code>PyQrack</code> simulation backend in bloqade.</p> <p>To make things a bit more interesting, we randomly select which function we are running the algorithm with.</p> In\u00a0[\u00a0]: Copied! <pre>sim = StackMemorySimulator(min_qubits=n_bits + 1)\n\nf_choice_idx = random.randint(0, 1)\nf_choice = (f_constant, f_balanced)[f_choice_idx]\n\n# result = sim.run(deutsch_algorithm, args=(f_balanced, n))\nresult0 = 0.0\nn_shots = 100\nfor _ in range(n_shots):\n    res = sim.run(deutsch_algorithm, args=(f_choice,))\n    result0 += res[0] / n_shots\n\nprint(\n    \"Oh magic Deutsch-Jozsa algorithm, tell us if our function is constant or balanced:\"\n)\nprint(\"*drumroll*\")\nif result0 == 0:\n    print(\"It's constant!\")\n\n    # let's make sure we actually did the right thing here\n    assert f_choice_idx == 0\nelse:\n    print(\"It's balanced!\")\n\n    # let's make sure we actually did the right thing here\n    assert f_choice_idx == 1\n</pre> sim = StackMemorySimulator(min_qubits=n_bits + 1)  f_choice_idx = random.randint(0, 1) f_choice = (f_constant, f_balanced)[f_choice_idx]  # result = sim.run(deutsch_algorithm, args=(f_balanced, n)) result0 = 0.0 n_shots = 100 for _ in range(n_shots):     res = sim.run(deutsch_algorithm, args=(f_choice,))     result0 += res[0] / n_shots  print(     \"Oh magic Deutsch-Jozsa algorithm, tell us if our function is constant or balanced:\" ) print(\"*drumroll*\") if result0 == 0:     print(\"It's constant!\")      # let's make sure we actually did the right thing here     assert f_choice_idx == 0 else:     print(\"It's balanced!\")      # let's make sure we actually did the right thing here     assert f_choice_idx == 1"},{"location":"digital/examples/squin/deutsch_squin/#deutsch-jozsa-algorithm","title":"Deutsch-Jozsa Algorithm\u00b6","text":"<p>In this example, we will implement a version of the Deutsch-Josza algorithm using bloqade's squin dialect.</p>"},{"location":"digital/examples/squin/ghz/","title":"GHZ State Preparation with Squin","text":"<p>The circuit we will implement is displayed below:</p> <p></p> <p>Since this circuit is rather simple, we can stick to the Squin standard library in order to implement it. The gates are defined in the <code>squin.gate</code> submodule.</p> <p>Let's start by importing Squin and writing our circuit for an arbitrary number of qubits.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import StackMemorySimulator  # we'll need that later\n\nfrom bloqade import squin\n\n\n@squin.kernel\ndef ghz_linear(n: int):\n    q = squin.qubit.new(n)\n    squin.gate.h(q[0])\n    for i in range(1, n):\n        squin.gate.cx(q[i - 1], q[i])\n\n\nghz_linear.print()\n</pre> from bloqade.pyqrack import StackMemorySimulator  # we'll need that later  from bloqade import squin   @squin.kernel def ghz_linear(n: int):     q = squin.qubit.new(n)     squin.gate.h(q[0])     for i in range(1, n):         squin.gate.cx(q[i - 1], q[i])   ghz_linear.print() <p>As you can see, writing basic circuits in squin is rather straightforward.</p> In\u00a0[\u00a0]: Copied! <pre>sim = StackMemorySimulator(min_qubits=2)\nresult = sim.run(ghz_linear, args=(2,))\nprint(result)\n</pre> sim = StackMemorySimulator(min_qubits=2) result = sim.run(ghz_linear, args=(2,)) print(result) <p>As you can see, the result of our simulation is <code>None</code>. That is because we are not returning anything from the kernel function.</p> <p>Note, how we're passing in the arguments of the kernel function as a separate tuple in the call to <code>run</code>. This signature is required since <code>ghz_linear(2)</code> would not return another kernel function, but rather attempt to run the kernel function as a Python function. As the function is written in squin rather than Python, this would fail. To provide a little more detail here: the <code>PyQrack</code> backend in bloqade-circuit actually has its own method table which tells it how to interpret the statements encountered in the squin kernel function.</p> <p>Since we are only simulating the circuit, however, we are able to fetch information that would otherwise not be attainable. For example, you can obtain the state vector from the simulator:</p> In\u00a0[\u00a0]: Copied! <pre>print(sim.state_vector(ghz_linear, args=(2,)))\n</pre> print(sim.state_vector(ghz_linear, args=(2,))) <p>Looking at the output, we can see that we indeed prepared a two-qubit GHZ state (up to a global phase).</p> <p>Note, that you can also add a return value to the kernel, which is then returned by <code>sim.run</code>. Again, this is not generally possible when running on hardware, but only during simulation.</p> <p>A realistic kernel function will return (a list of) measurement results. That is precisely what we will do in the following.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef noisy_linear_ghz(n: int, p_single: float, p_paired: float):\n    q = squin.qubit.new(n)\n\n    # define the noise operator for the single qubit\n    single_qubit_noise = squin.noise.depolarize(p_single)\n\n    squin.gate.h(q[0])\n    squin.qubit.apply(single_qubit_noise, q[0])\n\n    # pair qubit noise operator\n    two_qubit_noise = squin.noise.depolarize2(p_paired)\n\n    for i in range(1, n):\n        squin.gate.cx(q[i - 1], q[i])\n        squin.qubit.apply(two_qubit_noise, q[i - 1], q[i])\n\n    return squin.qubit.measure(q)\n</pre> @squin.kernel def noisy_linear_ghz(n: int, p_single: float, p_paired: float):     q = squin.qubit.new(n)      # define the noise operator for the single qubit     single_qubit_noise = squin.noise.depolarize(p_single)      squin.gate.h(q[0])     squin.qubit.apply(single_qubit_noise, q[0])      # pair qubit noise operator     two_qubit_noise = squin.noise.depolarize2(p_paired)      for i in range(1, n):         squin.gate.cx(q[i - 1], q[i])         squin.qubit.apply(two_qubit_noise, q[i - 1], q[i])      return squin.qubit.measure(q) In\u00a0[\u00a0]: Copied! <pre>noisy_linear_ghz.print()\n</pre> noisy_linear_ghz.print() <p>Noise operators</p> <p>     As opposed to standard gates, there is no standard library for noise statements as of now.     While we plan to add that in the future, also note how it can be convenient to separate the operator     from the gate application: we define the paired noise operator only once and apply it to different     pairs of qubits in the loop. </p> <p>This kernel function can be simulated in the exact same way as before. The only difference is that we now need to provide additional arguments for the noise probabilities.</p> In\u00a0[\u00a0]: Copied! <pre>result = sim.run(noisy_linear_ghz, args=(2, 1e-2, 2e-2))\nprint(result)\n</pre> result = sim.run(noisy_linear_ghz, args=(2, 1e-2, 2e-2)) print(result) <p>Now that we actually return something, we also obtain a result from running the simulation. This result is just a list of measurement results (boolean values corresponding to 0 and 1). We can also obtain the bit string:</p> In\u00a0[\u00a0]: Copied! <pre>result_bitstring = [int(res) for res in result]\nprint(result_bitstring)\n</pre> result_bitstring = [int(res) for res in result] print(result_bitstring) <p>Ideally, the two values should always be correlated since we want to prepare a GHZ state. However, now that we've added noise, this is not always the case.</p> <p>We can actually use this fact to define a \"fidelity\" measure for the circuit: when repeatedly executing the circuit, uncorrelated results lower the fidelity.</p> <p>Mathematically, let's define the fidelity $F$ as</p> <p>$F = 1 - \\sum_{i=1}^n \\frac{\\text{err}(i)}{n}$,</p> <p>where $n$ is the number of shots we take and</p> <p>$ \\text{err}(i) = \\begin{cases} 0 \\text{ if run }i \\text{ is correct} \\\\ 1 \\text{ else } \\end{cases}$</p> <p>In this case, \"correct\" means the measurement outcome is fully correlated.</p> In\u00a0[\u00a0]: Copied! <pre>n_shots = 1000\nn_qubits = 4\np_single = 1e-2\np_paired = 2 * p_single\nfidelity = 1.0\nsim = StackMemorySimulator(min_qubits=n_qubits)\nfor _ in range(n_shots):\n    result = sim.run(noisy_linear_ghz, args=(n_qubits, p_single, p_paired))\n    measured_one_state = all(result)\n    measured_zero_state = not any(result)\n    is_correlated = measured_one_state or measured_zero_state\n    if not is_correlated:\n        fidelity -= 1 / n_shots\n\nprint(fidelity)\n</pre> n_shots = 1000 n_qubits = 4 p_single = 1e-2 p_paired = 2 * p_single fidelity = 1.0 sim = StackMemorySimulator(min_qubits=n_qubits) for _ in range(n_shots):     result = sim.run(noisy_linear_ghz, args=(n_qubits, p_single, p_paired))     measured_one_state = all(result)     measured_zero_state = not any(result)     is_correlated = measured_one_state or measured_zero_state     if not is_correlated:         fidelity -= 1 / n_shots  print(fidelity) <p>Note, that this is actually a poor measure for fidelity as it only counts fully correlated states and treats everything else as an equivalent error. If you have many qubits, you could argue that only flipping a single bit is a much lower error than flipping many, and that this should be weighed in here. Or, you can simply use the simulator to obtain the state vector and compute the overlap. Or, define whatever measure of fidelity you see fit here, but we'll end this tutorial here.</p>"},{"location":"digital/examples/squin/ghz/#ghz-state-preparation-with-squin","title":"GHZ State Preparation with Squin\u00b6","text":"<p>In this example, we will show (yet again) how to implement a program that prepares a GHZ state. We will do so with a simple linear algorithm and show how to manually insert noise.</p>"},{"location":"digital/examples/squin/ghz/#simulating-the-kernel","title":"Simulating the kernel\u00b6","text":"<p>You can simulate a kernel such as the above using bloqade's PyQrack backend.</p> <p>There are two basic simulators, that act like \"devices\" that you run your program on:</p> <ul> <li>The <code>StackMemorySimulator</code>, which initializes its memory with a fixed number of qubits. The number is either set via the <code>min_qubits</code> argument or inferred automatically. Note, that automatic inference is not always possible in which case you will be required to set the argument accordingly.</li> <li>The <code>DynamicMemorySimulator</code>, which, as the name suggests, allocates memory as required throughout the circuit. Generally, you should prefer the <code>StackMemorySimulator</code> over this one unless the number of qubits can only be known at runtime.</li> </ul> <p>Let's go ahead and use the <code>StackMemorySimulator</code> together with a fixed number of qubits to simulate our GHZ preparation program from above.</p>"},{"location":"digital/examples/squin/ghz/#inserting-noise","title":"Inserting noise\u00b6","text":"<p>The above is rather basic, so let's try to do something that is a little more interesting. Let's write the same program as before, but now we assume that noise processes occur whenever a gate is applied.</p> <p>We will make use of Squin's noise submodule in order to do that.</p> <p>Our \"noise model\" will be quite simple:</p> <ul> <li>Whenever a single-qubit gate is applied, that qubit undergoes a depolarization error with probability <code>p_single</code>.</li> <li>Whenever a two-qubit (controlled) gate is applied, both qubits undergo a joint depolarization error with probability <code>p_paired</code>.</li> </ul> <p>Note, that a depolarization error with probability $p$ on a single qubit means that randomly chosen Pauli operators (one of $X, Y, Z$) is applied to the qubit with probability $p$. Similarly, a two-qubit depolarization error applies one of the 15 operators $IX, IY, IZ, XI, XX, ...$ with a given probability.</p>"},{"location":"digital/simulator_device/simulator_device/","title":"Simulation devices","text":"<p>A simulation device can run a task, such as executing a kernel. It acts just like a device that is an actual hardware, but runs everything in a local simulation. As such, it can also be used to inspect the results of your program beyond what is possible on a QPU. For example, you can return the <code>state_vector</code> of the quantum register at the end of the task execution.</p> <p>Here's how you can use it in order to run a simple <code>qasm2.extended</code> kernel.</p> <pre><code>from bloqade.pyqrack import StackMemorySimulator\nfrom bloqade import qasm2\n\n@qasm2.extended\ndef main():\n    q = qasm2.qreg(2)\n\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n\n    return q\n\nsim = StackMemorySimulator(min_qubits=2)\n\n# get the state vector -- oohh entanglement\nstate = sim.state_vector(main)\n</code></pre>"},{"location":"digital/simulator_device/tasks/","title":"Tasks","text":"<p>Warning</p> <p>Sorry folks, still under construction.</p> <p>For now, please check the API reference.</p>"},{"location":"quick_start/analog/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/analog/#quick-start","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"quick_start/analog/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.analog.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade.analog import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"quick_start/analog/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade.analog import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"quick_start/analog/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade.analog import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"quick_start/analog/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"quick_start/analog/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade.analog import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"quick_start/analog/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"quick_start/analog/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"quick_start/analog/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"quick_start/analog/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade.analog import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"quick_start/analog/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade.analog import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade.analog import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"quick_start/analog/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade.analog import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade.analog import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"quick_start/circuits/","title":"Digital Quantum Computing with circuits","text":"<p>This section provides the quick start guide for developing quantum programs represented by circuits using Bloqade. Circuits are a general-purpose and powerful way of representing arbitrary computations. For a few examples please refer to our examples.</p>"},{"location":"quick_start/circuits/#open-quantum-assembly-language-qasm2-and-beyond","title":"Open Quantum Assembly Language (QASM2) and beyond","text":"<p>We have chosen to closely mirror the semantics of the Open Quantum Assembly Language (QASM2) in bloqade.circuits. The QASM2 dialect is a simple quantum assembly language that allows you to write quantum circuits in a human-readable format. However, one should note that QASM2 is a very restricted language and does not support all the features of a high-level language.</p> <p>For example, there is a separation of gate routines declared with <code>gate</code> and main program written as a sequence of gate applications. While the gate routine is similar to a function in many ways, it does not support high-level features such as recursion (due to lack of <code>if</code> statement support inside) or control flows.</p> <p>Indeed, bloqade.circuits is designed with the notion of kernels in mind by decorating functions with a <code>@qasm2.extended</code> decorator. The python code is interpreted and parsed by the Kirin compiler toolchain and lowered to an abstract representation of the program. These kernels can include classical computation and the usual programming structures-- if/else, for and while loops, function inputs, and the like, as one is used to in Python.</p> <p>Additionally, the QASM2 representations of bloqade.circuits have been extended to include a key advantage of reconfigurable neutral atom hardware: parallelism. For example, one can represent a CZ gate applied to many qubit pairs at once as</p> <p><pre><code>@qasm2.extended\ndef parallel_cz(controls:ilist[qasm2.Qubit],targets:ilist[qasm2.Qubit]):\n    for ctr in range(len(controls)):\n        qasm2.cz(ctrl=controls[0],qarg=controls[1])\n</code></pre> or equivalently use a SIMD (single instruction multiple data)-like instruction to explicitly flag the parallelism <pre><code>@qasm2.extended\ndef simd_cz(controls:ilist[qasm2.Qubit],targets:ilist[qasm2.Qubit]):\n    qasm2.parallel.cz(ctrls=controls,qargs=targets)\n</code></pre> Both will ultimately emit the exact same QASM code, but the latter snippet represents the kind of parallelism that can be leveraged by reconfigurable neutral atom hardware to more efficiently execute a program.</p> <p>While in our initial release we support QASM2 as the first eDSL, we plan to use it as a compilation target instead of a programming language for long-term development. We are working on a more expressive language that will be more suitable for quantum programming in the error-corrected era.</p>"},{"location":"quick_start/circuits/#quick-example","title":"Quick Example","text":"<p>You can program kernels and quantum programs using the <code>qasm2.extended</code> decorator, such as the following Quantum Fourier Transform (QFT) circuit:</p> <pre><code>import math\nfrom bloqade import qasm2\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int):\n    if n == 0:\n        return qreg\n\n    qasm2.h(qreg[0])\n    for i in range(1, n):\n        qasm2.cu1(qreg[i], qreg[0], 2 * math.pi / 2**i)\n    qft(qreg, n - 1)\n    return qreg\n</code></pre> <p>While the syntax is similar to Python, the <code>qasm2.extended</code> decorator actually compiles the <code>qft</code> function into lower-level intermediate representation (IR) code that can be later interpreted, analyzed, or executed on quantum hardware. Observe that this function cannot immediately compile down to QASM as it takes parametrized inputs, and is called recursively.</p> <p>You can inspect the initial IR code by calling the pretty printer:</p> <pre><code>qft.print()\n</code></pre> <p></p> <p>And emit QASM2 code</p> <pre><code>from bloqade.qasm2.emit import QASM2 # the QASM2 target\nfrom bloqade.qasm2.parse import pprint # the QASM2 pretty printer\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</code></pre> <p></p>"},{"location":"quick_start/circuits/#understanding-the-compilation-process","title":"Understanding the compilation process","text":"<p>The compilation process is divided into several stages:</p> <ol> <li>Lowering: the decorator <code>qasm2.extended</code> takes the Python Abstract Syntax Tree (AST) and lowers it into Kirin IR in the Static Single Assignment (SSA) form.</li> <li>Interpretation: when invoking the PyQrack backend, the IR code is interpreted via Kirin's IR interpreter (missing link) with the PyQrack runtime backend.</li> <li>Target code generation: when emitting QASM2 code:</li> <li>The IR code gets aggressively inlined and all constant expressions are evaluated.</li> <li>All loops and control flow are unrolled.</li> <li>All compatible Python expressions (e.g <code>sin</code>, arithmetics) are translated into QASM2 expression.</li> <li>The QASM2 code is emitted as QASM2 AST for pretty printing.</li> </ol>"},{"location":"quick_start/circuits/#progressive-compilation","title":"Progressive compilation","text":"<p>As well as writing circuit executions, you can also progressively transform and compile that circuit. For example, you may want to lower arbitrary single qubit unitaries into hardware-specific unitaries, as is done in this example. For more details on the kinds of circuit-level compiler passes and how to write your own, see here</p>"},{"location":"quick_start/circuits/#dialect-groups","title":"Dialect groups","text":"<p>Bloqade provides a set of dialects (missing link) for QASM2 and our custom extensions to model parallel gates in neutral atom architectures. The basic QASM2 functionality can be enabled via</p> <pre><code>pip install bloqade[qasm2]\n</code></pre>"},{"location":"quick_start/circuits/#extended-qasm","title":"Extended QASM","text":"<p>The decorator <code>qasm2.extended</code> is a group of smaller dialects:</p> <pre><code>extended = structural_no_opt.union(\n     [\n         inline,\n         uop,\n         glob,\n         noise,\n         parallel,\n         core,\n     ]\n )\n</code></pre> <p>where <code>structural_no_opt</code> is the base dialect group that provides the basic control flow, common Python expressions (but not all), then:</p> <ul> <li><code>core</code> provides the core QASM2 operations such as register allocation, measurement and reset.</li> <li><code>uop</code> provides the unary operations, such as standard Pauli gates, rotation gates, etc.</li> </ul> <p>The following dialects are specific to neutral atom quantum computing as an extension:</p> <ul> <li><code>glob</code> provides the global gates (Rydberg specific)</li> <li><code>noise</code> provides the noise channels</li> <li><code>parallel</code> provides the parallel gate support (Rydberg specific).</li> <li><code>inline</code> dialect provides the inline QASM string</li> </ul>"},{"location":"quick_start/circuits/#strict-qasm2-mode","title":"Strict QASM2 mode","text":"<p>While the <code>qasm2.extended</code> decorator provides a lot of high-level features as an extension of QASM2, you may want to program in strict QASM2 mode for compatibility reasons. You can do this by using the <code>qasm2.main</code> and <code>qasm2.gate</code> decorators:</p> <pre><code>@qasm2.main\ndef main():\n    qasm2.h(0)\n    qasm2.cx(0, 1)\n    qasm2.measure(0)\n    qasm2.measure(1)\n    return qasm2.qreg(2)\n</code></pre> <p>which corresponding to the following QASM2 code:</p> <pre><code>OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[2];\ncreg c[2];\n\nh q[0];\ncx q[0], q[1];\nmeasure q[0] -&gt; c[0];\nmeasure q[1] -&gt; c[1];\n</code></pre> <p>Note that the <code>return</code> values are all ignored due to lack of equivalent in QASM2.</p>"},{"location":"quick_start/circuits/API/qasm2_core/","title":"QASM2 Core","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/API/qasm2_inline_defunct/","title":"Qasm2 inline defunct","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p> <p>?? Merge with qasm2 core API to cut down on pages?</p>"},{"location":"quick_start/circuits/API/qasm2_noise/","title":"QASM2 Noise","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/API/qasm2_parallel/","title":"QASM2 Parallel","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/API/qasm2_uop/","title":"QASM2 Uop","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p> <p>?? Merge with qasm2 core API to cut down on pages?</p>"},{"location":"quick_start/circuits/compiler_passes/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/compiler_passes/asap_parallelism/","title":"ASAP Parallelism","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/compiler_passes/circuit_simplification/","title":"Circuit simplification","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/compiler_passes/native_gate_rewrite/","title":"Native gate rewrite","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/pyqrack_emulator/","title":"PyQrack emulator","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/pyqrack_emulator/#running-simulations","title":"Running simulations","text":"<p>The program can be executed via a simulator backend, e.g. PyQrack, you can install it for M-series Macs and other machines via:</p> <pre><code>pip install pyqrack\n</code></pre> <p>Warning</p> <p>If you are using a Mac with an Intel CPU you will need to instead install the following:</p> <pre><code>pip install pyqrack-cpu\n</code></pre> <p>Alternatively, if you have access to a GPU with CUDA support you can leverage that via:</p> <pre><code>pip install pyqrack-cuda\n</code></pre> <pre><code>from bloqade import qasm2\nfrom bloqade.pyqrack import PyQrack\n\n@qasm2.extended\ndef main():\n    return qft(qasm2.qreg(3), 3)\n\ndevice = PyQrack()\nqreg = device.run(main)\nprint(qreg)\n</code></pre>"},{"location":"quick_start/circuits/interpreters_and_analysis/qasm2_codegen/","title":"QASM2 Codegen","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/circuits/interpreters_and_analysis/qasm2_codegen/#emitting-qasm2-code","title":"Emitting QASM2 code","text":"<p>You can also emit QASM2 code from the IR code:</p> <pre><code>from bloqade.qasm2.emit import QASM2 # the QASM2 target\nfrom bloqade.qasm2.parse import pprint # the QASM2 pretty printer\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</code></pre> <p></p>"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2023/","title":"2023","text":""}]}