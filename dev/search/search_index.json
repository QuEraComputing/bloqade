{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Index","text":"the Software Development Kit for neutral atom quantum computers <p>Bloqade is QuEra Computing's software development kit (SDK) for neutral atom quantum computers. It is designed to be a hub of embedded domain-specific languages (eDSLs) for neutral atom quantum computing. Bloqade is built on top of Kirin, the Kernel Intermediate Representation Infrastructure.</p> <p>Warning</p> <p>Bloqade is currently in the early stages of development. The APIs and features are subject to change. While we do not promise stability and backward compatibility at the moment, we will try to minimize breaking changes as much as possible. If you are concerned about the stability of the APIs, consider pin the version of Bloqade in your project.</p> <p>Info</p> <p>The old version (&lt;= 0.15) of Bloqade is still available as a sub-package <code>bloqade-analog</code>. You can keep using it via <code>bloqade.analog</code> module. For example <code>from bloqade import start</code> becomes <code>from bloqade.analog import start</code>. See Installation for more information.</p>"},{"location":"#installation","title":"Installation","text":"<p>To install Bloqade, you can use the following command:</p> <pre><code>pip install bloqade\n</code></pre> <p>To install the extensions or extras for Bloqade and to setup the development environment, please refer to the installation guide.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To get started with Bloqade, you can refer to the following tutorials:</p> <ul> <li>Background: Background information on neutral atom quantum computing.</li> <li>Digital quick start: A quick start guide on writing digital circuits.</li> <li>Analog quick start: A quick start guide for the analog quantum computing eDSL (same as older <code>bloqade</code> versions).</li> </ul>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to Bloqade. Please refer to the contribution guide for more information.</p>"},{"location":"#license","title":"License","text":"<p>Bloqade is licensed under the Apache License 2.0.</p>"},{"location":"background/","title":"Background","text":""},{"location":"background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>A key feature of a quantum computer is the ability to physically represent qubits. In neutral atom computers, the qubit is represented in the electronic state of the valence electron of Rubidium 87. Arrays of individual atoms are held by laser tweezers, and quantum computations are executed by manipulating the electronic state of each atom using lasers and RF fields. Entanglement can be generated using the Rydberg state, which is a highly excited state that strongly interacts with adjacent atoms through a \\(R^{-6}\\) power law Van der Waals force.</p>"},{"location":"background/#analog-mode-quantum-computing","title":"Analog mode Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital. In analog mode, the qubit is represented as in a ground state and a Rydberg state of an atom. The atoms are placed in user-specified arbitrary positions in a 2d space, and quantum computations can be enacted by driving the atoms between the ground and Rydberg state. However, adjacent atoms in the Rydberg state are always interacting, so the computation is done through a time evolution of the atoms via the Schrodinger equation</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] <p>where \\(H\\) is a time-dependent \"Rydberg atom\" Hamiltonian.</p> \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p> <p>For a more nuanced read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing. For more details on QuEra's cloud-accessible analog mode computer Aquila, please check out the Aquila whitepaper.</p>"},{"location":"background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). The digital mode qubit is represented in the two hyperfine clock ground states of the Rubidium 87 atom. These two states are extremely weakly interactive with the environment and other adjacent atoms, which leads to a very long coherence time upwards of 1 second. Single-qubit gates can be executed through a Raman laser drive coupling the two states to enact arbitrary rotations.</p> <p>Unlike Analog mode where the Rydberg state is persistent as part of the qubit encoding into the electronic states, digital mode only temporarily excites the atoms to the Rydberg state in order to interact with adjacent qubits, a process which typically takes less than ~1usec. Thus, a neutral atom entangling gate is executed by bringing multiple atoms together within the Rydberg blockade radius, and then doing some time-dependent drive between the hyperfine ground states and the Rydberg state, so that the final state returns to the hyperfine ground states. Due to the Rydberg blockade, only one atom can be in the Rydberg state at a time, which creates entanglement between the atoms. For more details see this paper on a recent demonstration of high fidelity gates.</p> <p>A unique advantage of reconfigurable neutral atom architectures is parallelism: the same laser can effect many lasers by aiming it in the same plane as the atom array. A single global Raman laser can enact the same parallel single-qubit gate on all qubits at the same time, and a single Rydberg laser (technically, two counter-propagating) can enact the same parallel multi-qubit gate on all cliques of qubits in an entangling region of the array. For more details see this paper on a recent demonstration of reconfigurable architectures. For this reason, it is important to represent quantum executions and circuits to be as parallel as possible. In our qasm2 dialect, we have extended qasm to natively include parallelism-- for example, <code>qasm2.parallel.cx(controls, targets)</code> represents a parallel CNOT gate between a list of <code>controls</code> on a list of <code>targets</code>.</p>"},{"location":"background/#reconfigurable-architectures-and-all-to-all-connectivity","title":"Reconfigurable architectures and \"all to all\" connectivity","text":"<p>A second advantage of reconfigurable neutral atom architectures is reconfigurability: atoms can be moved in parallel between sites in the array. QuEra's devices will have a zoned architecture, with distinct storage and entanglement zones and the ability to move atoms between them using a set of dynamic crossed AOD laser tweezers. This mobility can be considered as an efficient parallel swap gate, where any qubit can easily be moved to be adjacent to any other to enact entangling gates. For this reason, reconfigurable neutral atoms do not have a \"connectivity graph\" in the traditional sense-- instead, they have an \"all-to-all\" connectivity. There are still some technical constraints on this connectivity due to restrictions on the crossed AOD which we will detail when we open-source a move level dialect set in the near future.</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contain pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not to create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for managing command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"install/","title":"Installation","text":"<p>Bloqade is compatible with Python 3.10+ and available on PyPI. You can install it via <code>pip</code> into your environment:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"install/#bloqade-and-its-friends","title":"Bloqade and its friends","text":"<p>Bloqade is a Python namespace package, we officially provide several sub-packages, each of which is an eDSL for neutral atom quantum computing. The following is a list of the sub-packages in Bloqade:</p> <p>Note</p> <p>If you have already installed Bloqade via the instructions above, all the following subpackages are already installed with the exception of the <code>stim</code> eDSL which is currently experimental.</p>"},{"location":"install/#bloqadeqasm2","title":"<code>bloqade.qasm2</code>","text":"<p>QASM2 and its extensions support for neutral atom quantum computing. Available via:</p> <pre><code>pip install bloqade[qasm2]\n</code></pre>"},{"location":"install/#bloqadeanalog","title":"<code>bloqade.analog</code>","text":"<p>Analog quantum computing eDSL for neutral atom quantum computing (previously <code>bloqade-python</code>). Available via:</p> <pre><code>pip install bloqade-analog\n</code></pre>"},{"location":"install/#bloqadeqbraid","title":"<code>bloqade.qbraid</code>","text":"<p>Support of the qBraid cloud service as a runtime backend for retrieving noise models and running circuits.</p> <pre><code>pip install bloqade[qbraid]\n</code></pre>"},{"location":"install/#bloqadestim-experimental","title":"<code>bloqade.stim</code> (Experimental)","text":"<p>Stim and its extensions support for neutral atom quantum computing. Available via:</p> <pre><code>pip install bloqade[stim]\n</code></pre>"},{"location":"install/#development","title":"Development","text":"<p>If you want to contribute to Bloqade, you can clone the repository from GitHub:</p> <pre><code>git clone https://github.com/QuEraComputing/bloqade.git\n</code></pre> <p>We use <code>uv</code> to manage the development environment.</p> <p>You can install <code>uv</code> via the following:</p> Linux and macOSWindows <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <pre><code>powershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Then you can install the development dependencies executing one of the following commands:</p> <pre><code># For contributing to code\nuv sync --group dev\n# For contributions to documentation\nuv sync --group doc\n# For just getting everything mentioned above\nuv sync --all-groups\n</code></pre> <p>Our code review requires that you pass the tests and linting checks. We recommend you install <code>pre-commit</code> to run the checks before you commit your changes.  <code>pre-commit</code> is already specified as a development dependency for bloqade and once installed,  you can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre>"},{"location":"manifesto/","title":"Bloqade Manifesto","text":"<p>The vision of Bloqade is to empower quantum scientists, from applications development to algorithmic co-design, to build hybrid quantum-classical programs that leverage the strength of neutral atom quantum computers and have a real chance of demonstrating quantum utility. Bloqade is built on top of Kirin, an open source compiler infrastructure designed for kernel functions and composable representations.</p>"},{"location":"manifesto/#composable-quantum-programming","title":"Composable quantum programming","text":"<p>Today Bloqade becomes a namespace package of multiple eDSLs (embedded domain-specific languages) around digital and analog quantum computation. <code>bloqade.analog</code> is the module for analog-mode neutral atom computers and includes several handy utilities ranging from building or analyzing analog programs, to emulation or executing on QuEra's cloud-accessible hardware \"Aquila\".</p> <p>Other submodules such as <code>bloqade.qasm2</code>, <code>bloqade.pyqrack</code> and <code>bloqade.stim</code> are the initial iteration to represent digital circuit execution using gate-based quantum computing on reconfigurable neutral atoms. It extends the QASM2 language to include extra annotation of circuits that is important for efficient execution, such as parallelism and global gates. As well as being able to construct quantum programs with the full convenience of typical classical programming within hardware kernels -- such as loops and control flow -- Bloqade also includes basic compiler transformation passes, emulation, and code generation.</p> <p>But Bloqade is not done with just these modules. We envision adding new modules (called \"dialects\") which help you write programs which are tuned for optimal performance in an error corrected era, and on neutral atom hardware. Stay tuned and help us build the future of quantum computing as we build out new components, such as QEC and atom moving dialects.</p>"},{"location":"manifesto/#hardware-oriented-programming-and-co-design","title":"Hardware-oriented programming and co-design","text":"<p>At its core, Bloqade strives to be the neutral atom SDK for getting the most out of today's and tomorrows' quantum hardware. It is clear that the circuit-level abstraction is not enough to program real quantum hardware; indeed, tomorrows' quantum demonstrations and applications must program at the hardware level and develop special tooling to compile higher-level abstractions to efficient implementations. We call this process \"co-design\": designing algorithms specialized to near-term hardware, with an eye on nontrivial demonstrations and scalable solutions. Ultimately, this co-design approach requires hardware-specific DSLs which explicitly represent the native executions on neutral atom hardware: in other words, Bloqade.</p>"},{"location":"manifesto/#hybrid-computing-beyond-circuits","title":"Hybrid computing beyond circuits","text":"<p>Many quantum algorithms are hybrid, requiring both classical and quantum resources to work together in a hybrid computation architecture. This could be anything from syndrome extraction and measurement-based computing to variational parameter updates in VQE methods and orbital fragmentation methods in molecular simulation. Through the use of the Kirin compiler infrastructure, Bloqade embraces this philosophy of heterogeneous compute. Kirin programs are written as (compositions of) kernels-- subroutines that are intended to run on particular hardware (such as QPUs), or orchestrated to run on heterogeneous compute (such as a real-time classical runtime plus a QPU). These subroutines-- plus the built-in hybrid representations-- enable many key primitives, such as error correction.</p> <p>Additionally, the ability to compose functions together and to use typical classical programming structures like <code>if</code> and recursion enables many simplifications in writing raw circuit executions. In fact, recursion and the ability to dynamically allocate new memory (which is not known until runtime) enables many powerful subroutines and is natively enabled with Bloqade's kernel-based representation; for example, see this implementation of a repeat-until-success program.</p>"},{"location":"manifesto/#analog-digital-logical-towards-real-quantum-utility","title":"Analog, digital, logical: towards real quantum utility","text":"<p>The first step in Bloqade was building out the analog mode SDK, designed to interface with QuEra\u2019s cloud-accessible analog-mode neutral-atom quantum computer Aquila, as well as enable analysis and scientific discovery in analog quantum computing. But the journey should not stop there: real quantum utility is error corrected and requires robust algorithmic exploration and design of quantum primitives, in-depth analysis of near-term hardware performance and benchmarking, and building pipelines and hybrid architectures that are intended not just for today\u2019s demonstrators but also for tomorrow\u2019s utility-scale hardware. By introducing the next generation of Bloqade, we hope to enable this exploration by adding in support for near-term digital and intermediate-term logical representations of hybrid quantum computations.</p>"},{"location":"manifesto/#join-us","title":"Join us!","text":"<p>If you are interested in contributing, please see the contribution page here. If you are interested in exploring more about neutral atom quantum computing, check out some analog tutorials here, and some circuit tutorials here. If you wish to work closer with QuEra, please feel free to reach out!</p>"},{"location":"analog/","title":"Index","text":"<p>Note</p> <p>Bloqade has been restructured to make room for new features and improvements. Please refer to the migration guide for more information.</p>"},{"location":"analog/#what-is-bloqade-analog","title":"What is Bloqade Analog?","text":"<p>Bloqade Analog is a Python SDK for QuEra's neutral atom quantum computer Aquila (check out our paper!). It's designed to make writing and analyzing the results of analog quantum programs on Aquila as easy as possible. It features custom atom geometries and flexible waveform definitions in both emulation and real hardware. Bloqade interfaces with the AWS Braket cloud service where Aquila  is hosted, enabling you to submit programs as well as retrieve and analyze real hardware results all-in-one.</p>"},{"location":"analog/#installation","title":"Installation","text":"<p>You can install the package with <code>pip</code> in your Python environment of choice via:</p> <pre><code>pip install bloqade\n</code></pre>"},{"location":"analog/#a-glimpse-of-bloqade-analog","title":"A Glimpse of Bloqade Analog","text":"<p>Let's try a simple example where we drive a Rabi oscillation on a single neutral atom. Don't worry if you're unfamiliar with neutral atom physics, (you can check out our Background for more information!) the goal here is to just give you a taste of what Bloqade can do.</p> <p>We start by defining where our atoms go, otherwise known as the atom geometry. In this particular example we will use a small Honeycomb lattice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\n</code></pre> <p>We can verify what the atom geometry looks like by <code>.show()</code>'ing it:</p> <pre><code>geometry.show()\n</code></pre> <p>We now define what the time evolution looks like using a pulse sequence. The pulse sequence here is the time profile of the Rabi Drive targeting the ground-Rydberg two level transition, which causes the Rabi oscillations. We choose a constant waveform with a value of \\(\\frac{\\pi}{2} \\text{rad}/\\text{us}\\) and a duration of \\(1.0 \\,\\text{us}\\). This produces a \\(\\frac{\\pi}{2}\\) rotation on the Bloch sphere meaning our final measurements should be split 50/50 between the ground and Rydberg state.</p> <pre><code>from math import pi\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\n</code></pre> <p>Here <code>rabi.amplitude</code> means exactly what it is, the Rabi amplitude term of the Hamiltonian. <code>uniform</code> refers to applying the waveform uniformly across all the atom locations.</p> <p>We can visualize what our program looks like again with <code>.show()</code>:</p> <p>We can now run the program through Bloqade's built-in emulator to get some results. We designate that we want the program to be run and measurements performed 100 times:</p> <pre><code>emulation_results = rabi_program.bloqade.python().run(100)\n</code></pre> <p>With the results we can generate a report object that contains a number of methods for analyzing our data, including the number of counts per unique bitstring:</p> <pre><code>bitstring_counts = emulation_results.report().counts()\n</code></pre> <p>Which gives us:</p> <pre><code>[OrderedDict([('0', 55), ('1', 45)])]\n</code></pre> <p>If we want to submit our program to hardware we'll need to adjust the waveform as there is a constraint the Rabi amplitude waveform must start and end at zero. This is easy to do as we can build off the atom geometry we saved previously but apply a piecewise linear waveform:</p> <pre><code>hardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\n\nhardware_rabi_program.show()\n</code></pre> <p>Now instead of using the built-in Bloqade emulator we submit the program to Aquila. You will need to use the AWS CLI to obtain credentials from your AWS account or set the proper environment variables before hand.</p> <pre><code>hardware_results = hardware_rabi_program.braket.aquila.run_async(100)\n</code></pre> <p><code>.run_async</code> is a non-blocking version of the standard <code>.run</code> method, allowing you to continue work while waiting for results from Aquila. <code>.run_async</code> immediately returns an object you can query for the status of your tasks in the queue as well.</p> <p>You can do the exact same analysis you do on emulation results with hardware results too:</p> <pre><code>hardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p>If you want to try the above at once, we collected the above steps into the snippet below:</p> <pre><code>from math import pi\nfrom bloqade.analog.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\nemulation_results = rabi_program.bloqade.python().run(100)\nbitstring_counts = emulation_results.report().counts()\n\nhardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nhardware_results = hardware_rabi_program.braket.aquila.run_async(100)\nhardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p> </p>"},{"location":"analog/#features","title":"Features","text":""},{"location":"analog/#customizable-atom-geometries","title":"Customizable Atom Geometries","text":"<p>You can easily explore a number of common geometric lattices with Bloqade's <code>atom_arrangement</code>'s:</p> <pre><code>from bloqade.analog.atom_arrangement import Lieb, Square, Chain, Kagome\n\ngeometry_1 = Lieb(3)\ngeometry_2 = Square(2)\ngeometry_3 = Chain(5)\ngeometry_4 = Kagome(3)\n</code></pre> <p>If you're not satisfied with the Bravais lattices we also allow you to modify existing Bravais lattices as follows:</p> <pre><code>geometry_5 = Kagome(3).add_position((10,11))\n</code></pre> <p>You can also build your geometry completely from scratch:</p> <pre><code>from bloqade import start\n\ngeometry = start.add_positions([(0,0), (6,0), (12,0)])\n</code></pre>"},{"location":"analog/#flexible-pulse-sequence-construction","title":"Flexible Pulse Sequence Construction","text":"<p>Define waveforms for pulse sequences any way you like by either building (and chaining!) them immediately as part of your program:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\ngeometry = Square(2)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\ncustom_rabi_amp_waveform = (\n  target_rabi_amplitude\n  .piecewise_linear(values=[0, 10, 10, 0], durations=[0.1, 3.5, 0.1])\n  .piecewise_linear(values=[0, 5, 3, 0], durations=[0.2, 2.0, 0.2])\n)\n</code></pre> <p>Or building them separately and applying them later:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Chain\n\ngeometry_1 = Square(3)\ngeometry_2 = Chain(5)\n\ntarget_rabi_amplitude = start.rydberg.rabi.amplitude.uniform\npulse_sequence = target_rabi_amplitude.uniform.constant(value=2.0, duration=1.5).parse_sequence()\n\nprogram_1 = geometry_1.apply(pulse_sequence)\nprogram_2 = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/#hardware-and-emulation-backends","title":"Hardware and Emulation Backends","text":"<p>Go from a fast and powerful emulator:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\nfrom math import pi\n\ngeometry = Square(3, lattice_spacing = 6.5)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nprogram = (\n  target_rabi_amplitude\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nemulation_results = program.bloqade.python().run(100)\n</code></pre> <p>To real quantum hardware in a snap:</p> <pre><code>hardware_results = program.braket.aquila().run_async(100)\n</code></pre>"},{"location":"analog/#simple-parameter-sweeps","title":"Simple Parameter Sweeps","text":"<p>Use variables to make parameter sweeps easy on both emulation and hardware:</p> <pre><code>from bloqade import start\nimport numpy as np\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_oscillation_program = (\n  target_rabi_amplitude\n  .piecewise_linear(durations = [0.06, \"run_time\", 0.06], values = [0, 15, 15, 0])\n)\nrabi_oscillation_job = rabi_oscillation_program.batch_assign(run_time=np.linspace(0, 3, 101))\n\nemulation_results = rabi_oscillation_job.bloqade.python().run(100)\nhardware_results = rabi_oscillation_job.braket.aquila().run(100)\n</code></pre> <pre><code>emulation_results.report().rydberg_densities()\n                0\ntask_number\n0            0.16\n1            0.35\n2            0.59\n3            0.78\n4            0.96\n...           ...\n96           0.01\n97           0.09\n98           0.24\n99           0.49\n100          0.68\n\n[101 rows x 1 columns]\n</code></pre>"},{"location":"analog/#quick-results-analysis","title":"Quick Results Analysis","text":"<p>Want to just see some plots of your results? <code>.show()</code> will show you the way!</p> <p><pre><code>from bloqade.analog.atom_arrangement import Square\n\nrabi_amplitude_values = [0.0, 15.8, 15.8, 0.0]\nrabi_detuning_values = [-16.33, -16.33, 42.66, 42.66]\ndurations = [0.8, 2.4, 0.8]\n\ngeometry = Square(3, lattice_spacing=5.9)\nrabi_amplitude_waveform = (\n  geometry\n  .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)\n)\nprogram = (\n  rabi_amplitude_waveform\n  .detuning.uniform.piecewise_linear(durations, rabi_detuning_values)\n)\nemulation_results = program.bloqade.python().run(100)\nemulation_results.report().show()\n</code></pre> </p>"},{"location":"analog/#contributing-to-bloqade","title":"Contributing to Bloqade","text":"<p>Bloqade is released under the Apache License, Version 2.0. If you'd like the chance to shape the future of neutral atom quantum computation, see our Contributing Guide for more info!</p>"},{"location":"analog/contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to the project! We welcome all contributions. There are many different ways to contribute to Bloqade, and we are always looking for more help. We accept contributions in the form of bug reports, feature requests, documentation improvements, and code contributions. For more information about how to contribute, please read the following sections.</p>"},{"location":"analog/contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Reporting a Bug </li> <li>Reporting Documentation Issues</li> <li>Feature Requests</li> <li>Developing Bloqade</li> <li>Design Philosophy and Architecture</li> <li>Community Slack</li> <li>Ask a Question</li> <li>Providing Feedback</li> </ul>"},{"location":"analog/contributing/asking-a-question/","title":"Ask a Question","text":"<p>If you're interested in contributing to Bloqade, or just want to discuss the project, join the discussion on GitHub Discussions at https://github.com/QuEraComputing/bloqade-analog/discussions</p>"},{"location":"analog/contributing/code-of-conduct/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"analog/contributing/code-of-conduct/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"analog/contributing/code-of-conduct/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"analog/contributing/code-of-conduct/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"analog/contributing/community-slack/","title":"Community Slack","text":"<p>You can join QuEra's Slack workspace with this link. Join the <code>#bloqade</code> channel to discuss anything related to Bloqade.</p>"},{"location":"analog/contributing/design-philosophy-and-architecture/","title":"Design Philosophy and Architecture","text":"<p>Given the heterogeneous nature of the hardware we target, We have decided to use a compiler-based approach to our software stack, allowing us to target different hardware backends with the same high-level language. Below is a diagram of the software stack in Bloqade.</p> <pre><code>graph TD\n    Builder[\"Builder Representation\"]\n    PythonAST[\"Bloqade AST Python\"]\n    JuliaAST[\"Bloqade AST Julia\"]\n\n    EmulatorPy[\"Emulator IR Python\"]\n    EmulatorJL[\"Emulator IR Julia\"]\n\n    QuEra[\"QuEra IR\"]\n    Braket[\"Braket IR\"]\n    JuliaEmulator[\"Bloqade.jl\"]\n    PythonEmulator[\"Python Emulator\"]\n\n    Aquila[\"Aquila\"]\n\n    Builder --&gt;|parse| PythonAST\n    PythonAST --&gt;|lower| EmulatorPy\n    PythonAST --&gt;|lower| QuEra\n    PythonAST --&gt;|lower| Braket\n    PythonAST --&gt;|transpile| JuliaAST\n\n    QuEra --&gt;|execute| Aquila\n    Braket --&gt;|execute| Aquila\n\n    JuliaAST --&gt;|lower| EmulatorJL\n    EmulatorPy --&gt;|execute| PythonEmulator\n    EmulatorJL --&gt;|execute| JuliaEmulator\n</code></pre>"},{"location":"analog/contributing/design-philosophy-and-architecture/#high-level-builder-representation","title":"High-Level Builder Representation","text":"<p>When programming Bloqade using the Python API, the user constructs a representation of an analog quantum circuit. This representation is a flattened version of the actual analog circuit. Flattened means that the user input is a linear sequence of operations where the context of neighboring nodes in the sequence of instructions can determine the program tree structure. The Bloqade AST describes the actual analog circuit.</p>"},{"location":"analog/contributing/design-philosophy-and-architecture/#bloqade-ast","title":"Bloqade AST","text":"<p>The Bloqade AST is a representation of a quantum analog circuit for neutral atom computing. It is a directed acyclic graph (DAG) with nodes for different hierarchical levels of the circuit. The base node is the <code>AnalogCircuit</code> which contains the geometry of the atoms stored as a <code>AtomArragment</code> or <code>ParallelRegister</code> objects. The other part of the circuit is the <code>Sequence</code>, which contains the waveforms that describe the drives for the Ryberg/Hyperfine transitions of each Rydberg atom. Each transition is represented by a <code>Pulse</code> including a <code>Field</code> for the drive's detuning, Rabi amplitude, and Rabi phase . A <code>Field</code> relates the spatial and temporal dependence of a drive. The spatial modulates the temporal dependence of the waveform. A DAG also describes the <code>Waveform</code> object. Finally, we have basic <code>Scalar</code> expressions as well for describing the syntax of real-valued continuous numbers.</p>"},{"location":"analog/contributing/design-philosophy-and-architecture/#bloqade-compilers-and-transpilers","title":"Bloqade Compilers and Transpilers","text":"<p>Given a user program expressed as the Bloqade AST, we can target various backends by transforming from the Bloqade AST to other kinds of IR. For example, when submitting a task to QuEra's hardware, we transform the Bloqade AST to the IR that describes a valid program for the hardware.</p> <p>This process is referred to as <code>lowering</code>, which in a general sense is a transformation that takes you from one IR to another where the target IR is specialized or has a smaller syntactical structure. <code>Transpiling</code> corresponds to a transformation that takes you from one language to equivalent expressions in another. For example, we can transpile from the Bloqade AST in Python to the Bloqade AST in Julia. The generic term for both of these types of transformation in Bloqade is Code Generation. You will find various code generation implementations in various <code>codegen</code> modules.</p>"},{"location":"analog/contributing/documentation-issues/","title":"Reporting a Documentation Issue","text":"<p>We are always looking to improve our documentation. If you find a typo or think something is unclear, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-analog/issues</p> <p>For typos or other minor problems, create an issue that contains a link to the specific page that includes the problem, along with a description of the problem and possibly a solution.</p> <p>For a request for new documentation content, please open up an issue and describe what you think is missing from the documentation.</p>"},{"location":"analog/contributing/feature-requests/","title":"Requesting new Features","text":"<p>Given that we are currently at the beginning of the development of the Bloqade python interface, we are open to suggestions about what features would be helpful to include in future package iterations. If you have a request for a new feature, please open an issue on our GitHub page: https://github.com/QuEraComputing/bloqade-analog/issues</p> <p>We ask that the feature requests be as specific as possible. Please include the following information in your feature request:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the feature, including your attempt to solve the problem with the current version of Bloqade.</p> </li> <li> <p>A minimal code example that demonstrates the need for the feature.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"analog/contributing/providing-feedback/","title":"Providing Feedback","text":"<p>While Github Issues are a great way for us to better understand any issues your having with Bloqade as well as provide us with feature requests, we're always looking for ways to collect more general feedback about what the user experience with Bloqade is like.</p> <p>To do that we have this form where you can provide your thoughts after using/experimenting/tinkering/hacking with Bloqade.</p> <p>Your feedback will help guide the future of Bloqade's design so be honest and know that you're contributing to the future of Quantum Computing with Neutral Atoms!</p>"},{"location":"analog/contributing/reporting-a-bug/","title":"Reporting a Bug","text":"<p>Bloqade is currently in the alpha phase of development, meaning bugs most likely exist in the current implementation. We are continuously striving to improve the stability of Bloqade. As such, we encourage our users to report all bugs they find. To do this, we ask you to submit an issue to our GitHub page: https://github.com/QuEraComputing/bloqade-analog/issues</p> <p>Please include the following information in your bug report:</p> <ol> <li> <p>A short, descriptive title.</p> </li> <li> <p>A detailed description of the bug, including the expected behavior and what happened.</p> </li> <li> <p>A minimal code example that reproduces the bug.</p> </li> <li> <p>The version of Bloqade you are using.</p> </li> <li> <p>The version of Python you are using.</p> </li> <li> <p>The version of your operating system.</p> </li> </ol>"},{"location":"analog/home/background/","title":"Background","text":""},{"location":"analog/home/background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>The qubits that QuEra's neutral atom computer Aquila and Bloqade are designed to emulate are based on neutral atoms. As the name implies they are atoms that are neutrally charged but are also capable of achieving a Rydberg state where a single electron can be excited to an incredibly high energy level without ionizing the atom.</p> <p>This incredibly excited electron energy level \\(|r\\rangle\\) and its default ground state \\(|g\\rangle\\) create a two-level system where superposition can occur. For enabling interaction between two or more qubits and achieving entanglement, when the neutral atoms are in the Rydberg state a phenomenon known as the Rydberg blockade can occur where an atom in the Rydberg state prevents a neighboring atom from also being excited to the same state.</p> <p>For a more nuanced and in-depth read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p>"},{"location":"analog/home/background/#analog-vs-digital-quantum-computing","title":"Analog vs Digital Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital.</p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing</p>"},{"location":"analog/home/background/#analog-mode","title":"Analog Mode","text":"<p>In the analog mode (supported by Bloqade and Aquila) you control your computation through the parameters of a time-dependent Hamiltonian that influences all the qubits at once. There are options for local control of the Hamiltonian on certain qubits however.</p>"},{"location":"analog/home/background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). For neutral atoms, this digital mode can be accomplished with the introduction of hyperfine coupling, enabling a quantum state to be stored for long periods of time while also allowing for multi-qubit gates.</p>"},{"location":"analog/home/background/#rydberg-many-body-hamiltonian","title":"Rydberg Many-Body Hamiltonian","text":"<p>When you emulate a program in Bloqade, you are emulating the time evolution of the Rydberg many-body Hamiltonian which looks like this:</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p>"},{"location":"analog/home/background/#local-control","title":"Local Control","text":"<p>The Rydberg Many-Body Hamiltonian already implies from its subscripts that you can also have local control over your atoms. In Bloqade this local control extends to any term in the Hamiltonian while on Aquila this is currently restricted to the \\(\\Delta_j\\) laser detuning term.</p> <p>Fields in Bloqade give you local (single-atom) control over the many-body Rydberg Hamiltonian.</p> <p>They are a sum of one or more spatial modulations, which allows you to scale the amplitude of the waveform across the different sites in the system:</p> \\[ F_{i}(t) = \\sum_{\\alpha} C_{i}^{\\alpha}f_{\\alpha}(t) \\] \\[ C_{i}^{\\alpha} \\in \\mathbb{R} \\] \\[ f_{\\alpha}(t) \\colon \\mathbb{R} \\to \\mathbb{R} \\] <p>The \\(i\\)-th component of the field is used to generate the drive at the \\(i\\)-th site.</p> <p>Note that the drive is only applied if the \\(i\\)-th site is filled with an atom.</p> <p>You build fields in Bloqade by first specifying the spatial modulation followed by the waveform it should be multiplied by.</p> <p>In the case of a uniform spatial modulation, it can be interpreted as a constant scaling factor where \\(C_{i}^{\\alpha} = 1.0\\).</p>"},{"location":"analog/home/emulation/","title":"Emulation","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/geometry/","title":"Geometry","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/gotchas/","title":"Bloqade Gotchas: Common Mistakes in Using Bloqade","text":"<p>It is tempting when coming from different quantum SDKs and frameworks to apply the same pattern of thought to Bloqade. However, a lot of practices from those prior tools end up being anti-patterns in Bloqade. While you can use those patterns and they can still work, it ends up causing you the developer to write unnecessarily verbose, complex, and hard-to-read code as well as preventing you from reaping the full benefits of what Bloqade has to offer.</p> <p>This page is dedicated to cataloguing those anti-patterns and what you can do instead to maximize the benefit Bloqade can offer you.</p>"},{"location":"analog/home/gotchas/#redefining-lattices-and-common-atom-arrangements","title":"Redefining Lattices and Common Atom Arrangements","text":"<p>You might be tempted to define lattice-based geometries through the following means:</p> <pre><code>from bloqade import start\n\nspacing = 4.0\ngeometry = start.add_positions(\n    [(i * spacing, j * spacing) for i in range(4) for j in range(4)]\n)\n</code></pre> <p>This is quite redundant and verbose, especially considering Bloqade offers a large number of pre-defined lattices you can customize the spacing of in <code>bloqade.atom_arrangement</code>. In the code above, we're just defining a 4x4 square lattice of atoms with 4.0 micrometers of spacing between them. This can be expressed as follows</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nspacing = 4.0\ngeometry = Square(4, lattice_spacing = spacing)\n</code></pre>"},{"location":"analog/home/gotchas/#copying-a-program-to-create-new-ones","title":"Copying a Program to create New Ones","text":"<p>Many gate-based SDKs rely on having a mutable object representing your circuit. This means if you want to build on top of some base circuit without mutating it, you have to copy it:</p> <pre><code>import copy\n\nbase_circuit = qubits.x(0)....\n# make copy of base circuit\ncustom_circuit_1 = copy(base_circuit)\n# build on top of copy of base circuit\ncustom_circuit_1.x(0).z(5)...\n# create a new circuit by copying the base again\ncustom_circuit_2 = copy(base_circuit)\n# build on top of that copy again\ncustom_circuit_2.y(5).cz(0,2)...\n</code></pre> <p>In Bloqade Python this is unnecessary because at every step of your program an immutable object is returned which means you can save it and not have to worry about mutating any internal state.</p> <pre><code>from bloqade import start\nbase_program = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n# Just recycle your base program! No `copy` needed!\nnew_program_1 = base_program.constant(duration=5.0, value=5.0)\nnew_program_2 = base_program.piecewise_linear(\n    durations=[5.0], values = [0.0, 5.0]\n)\n</code></pre>"},{"location":"analog/home/gotchas/#creating-new-programs-instead-of-using-batch_assign","title":"Creating New Programs Instead of Using <code>.batch_assign</code>","text":"<p>If you have a set of parameters you'd like to test your program on versus a single parameter, don't generate a new program for each value:</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\nprograms_with_different_rabi_values = []\n\nfor rabi_value in rabi_values:\n    program = start.add_position((0, 0)).rydberg.rabi.amplitude.uniform.constant(\n        duration=5.0, value=rabi_value\n    )\n    programs_with_different_rabi_values.append(program)\n\nresults = []\n\nfor program in programs_with_different_rabi_values:\n    result = program.bloqade.python().run(100)\n    results.append(result)\n</code></pre> <p>Instead take advantage of the fact Bloqade has facilities specifically designed to make trying out multiple values in your program without needing to make individual copies via <code>.batch_assign</code>. The results are also automatically handled for you so each value you test has its own set of results, but all collected in a singular dataframe versus the above where you'd have to keep track of individual results.</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\n# place a variable for the Rabi Value and then batch assign values to it\nprogram_with_rabi_values = start.add_position(\n    0, 0\n).rydberg.rabi.amplitude.uniform.constant(duration=5.0, value=\"rabi_value\")\nprogram_with_assignments = program_with_rabi_values.batch_assign(\n    rabi_value=rabi_values\n)\n\n# get your results in one dataframe versus having to keep track of a\n# bunch of individual programs and their individual results\nbatch = program_with_assignments.bloqade.python().run(100)\nresults_dataframe = batch.report().dataframe\n</code></pre>"},{"location":"analog/home/migration/","title":"Migrating to Bloqade Analog","text":""},{"location":"analog/home/migration/#introduction","title":"Introduction","text":"<p>In order to make room for more features inside the Bloqade ecosystem, we have created a new package to take the place of the old <code>bloqade</code> package. The new package is called <code>bloqade-analog</code>. The old package <code>bloqade</code> will house a namespace package for other features such as our new Bloqade Digital package with support for circuit-based quantum computers!</p>"},{"location":"analog/home/migration/#installation","title":"Installation","text":"<p>You can install the package with <code>pip</code> in your Python environment of choice via:</p> <pre><code>pip install bloqade-analog\n</code></pre>"},{"location":"analog/home/migration/#migration","title":"Migration","text":"<p>The new package is a drop-in replacement for the old one. You can simply replace <code>import bloqade</code> with <code>import bloqade.analog</code>  or <code>from bloqade.analog import ...</code> in your code. Everything else should work as before.</p>"},{"location":"analog/home/migration/#example","title":"Example","text":"<p>lets say your header of your python script looks like this:</p> <p><pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n...\n</code></pre> You can simply replace it with:</p> <pre><code>from bloqade.analog import var\nfrom bloqade.analog.atom_arrangement import Square\n...\n</code></pre>"},{"location":"analog/home/migration/#migrating-old-bloqade-json-files","title":"Migrating old bloqade JSON files","text":"<p>If you have old bloqade JSON files, you will not be able to directly deserialize them anymore because of the package restructuring. However, we have provided some tools to migrate those JSON files to be compatible with <code>bloqade-analog</code>. You can do this by running the following command in the command line for a one or more files:</p> <p><pre><code>python -m bloqade.analog.migrate &lt;path_to_old_json_file1&gt; &lt;path_to_old_json_file2&gt; ...\n</code></pre> With default arguments this will create a new file with the same name as the old file, but with <code>-analog</code> appended to the end of the filename. For example, if you have a file called <code>my_bloqade.json</code>, the new file will be called <code>my_bloqade-analog.json</code>. You can then use <code>load</code> to deserialize this file with the <code>bloqade-analog</code> package. There are other options for converting the file, such as setting the indent level for the output file or overwriting the old file. You can see all the options by running:</p> <pre><code>python -m bloqade.analog.migrate --help\n</code></pre> <p>Another option is to use the migration tool in a python script:</p> <p><pre><code>from bloqade.analog.migrate import migrate\n\n # set the indent level for the output file\nindent: int = ...\n# set to True if you want to overwrite the old file, otherwise the new file will be created with -analog appended to the end of the filename\noverwrite: bool = ...\nf\nor filename in [\"file1.json\", \"file2.json\", ...]:\n    migrate(filename, indent=indent, overwrite=overwrite)\n</code></pre> This will migrate all the files in the list to the new format.</p>"},{"location":"analog/home/migration/#having-trouble-comments-or-concerns","title":"Having trouble, comments, or concerns?","text":"<p>Please open an issue on our GitHub</p>"},{"location":"analog/home/quick_start/","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"analog/home/quick_start/#navigating-the-bloqade-api","title":"Navigating the Bloqade API","text":"<p>As you develop your Bloqade program, you are expected to rely on pop-up \"hints\" provided in your development environment to help you determine what the next part of your program should be.</p>"},{"location":"analog/home/quick_start/#vs-code","title":"VS Code","text":"<p>In VS Code this is automatic, just type the <code>.</code> and see what options pop up:</p> <p></p>"},{"location":"analog/home/quick_start/#jetbrains-pycharm","title":"JetBrains PyCharm","text":"<p>The same goes for JetBrains PyCharm:</p> <p></p>"},{"location":"analog/home/quick_start/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>In a Jupyter Notebook you'll need to type <code>.</code> and then hit tab for the hints to appear:</p> <p></p>"},{"location":"analog/home/quick_start/#ipython","title":"IPython","text":"<p>The same goes for IPython:</p> <p></p>"},{"location":"analog/home/quick_start/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"analog/home/quick_start/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"analog/home/quick_start/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"analog/home/quick_start/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"analog/home/quick_start/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/home/quick_start/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"analog/home/quick_start/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"analog/home/quick_start/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"analog/home/quick_start/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"analog/home/quick_start/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"analog/home/quick_start/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"analog/home/submission/","title":"Submission","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/visualization/","title":"Visualization","text":"<p>This page is a work in progress!</p>"},{"location":"analog/home/waveforms/","title":"Waveforms","text":"<p>This page is a work in progress!</p>"},{"location":"analog/reference/hardware-capabilities/","title":"Hardware Capabilities","text":"<p>During program development, it can be quite handy to know what true hardware capabilities are and incorporate that information programmatically. Bloqade offers the ability to do this via <code>get_capabilities()</code>.</p>"},{"location":"analog/reference/hardware-capabilities/#programmatic-access","title":"Programmatic Access","text":"<p><code>get_capabilities()</code> (importable directly from <code>bloqade</code>) returns a <code>QuEraCapabilities</code> object. This object contains all the hardware constraints in <code>Decimal</code> format for the Aquila machine, our publicly-accessible QPU on AWS Braket.</p> <p>An example of using <code>get_capabilities()</code> is presented below:</p> <pre><code>from bloqade import get_capabilities, piecewise_linear\n\n# get capabilities for Aquila\naquila_capabilities = get_capabilities()\n\n# obtain maximum Rabi frequency as Decimal\nmax_rabi = aquila_capabilities.capabilities.rydberg.global_.rabi_frequency_max\n\n# use that value in constructing a neat Rabi waveform\nrabi_wf = piecewise_linear(durations = [0.5, 1.0, 0.5], values = [0, max_rabi, max_rabi, 0])\n</code></pre> <p>The attribute names for each value have been provided below but will require you to provide the proper prefix like in the example above (e.g. the maximum number of qubits lives under the <code>number_qubits_max</code> attribute which can be navigated to via <code>*your_QuEra_Capabilities_Object*.lattice.number_qubits_max</code>).</p>"},{"location":"analog/reference/hardware-capabilities/#aquila-capabilities","title":"Aquila Capabilities","text":""},{"location":"analog/reference/hardware-capabilities/#task","title":"Task","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.task</code> for:<ul> <li>minimum number of shots</li> <li>maximum number of shots</li> </ul> </li> </ul> Capability Attribute Value Minimum Number of Shots <code>number_shots_min</code> 1 Maximum Number of Shots <code>number_shots_max</code> 1000"},{"location":"analog/reference/hardware-capabilities/#lattice-geometry","title":"Lattice Geometry","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.lattice</code> for:<ul> <li>maximum number of qubits</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.area</code> for:<ul> <li>maximum lattice area width</li> <li>maximum lattice area height</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.lattice.geometry</code> for:<ul> <li>maximum number of sites</li> <li>position resolution</li> <li>minimum radial spacing</li> <li>minimum vertical spacing</li> </ul> </li> </ul> Capability Attribute Value Maximum Number of Qubits <code>number_qubits_max</code> 256 Maximum Lattice Area Width <code>width</code> 75.0 \u00b5m Maximum Lattice Area Height <code>height</code> 76.0 \u00b5m Minimum Radial Spacing between Qubits <code>spacing_radial_min</code> 4.0 \u00b5m Minimum Vertical Spacing between Qubits <code>spacing_vertical_min</code> 4.0 \u00b5m Position Resolution <code>position_resolution</code> 0.1 \u00b5m Maximum Number of Sites <code>number_sites_max</code> 256"},{"location":"analog/reference/hardware-capabilities/#global-rydberg-values","title":"Global Rydberg Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg</code> for:<ul> <li>C6 Coefficient</li> </ul> </li> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.global_</code> for:<ul> <li>Everything else related to global (applied to all atom) capabilities</li> </ul> </li> </ul> Capability Attribute Value Rydberg Interaction Constant <code>c6_coefficient</code> 5.42\u00d710\u2076 rad/\u03bcs \u00d7 \u00b5m\u2076 Minimum Rabi Frequency <code>rabi_frequency_min</code> 0.00 rad/\u03bcs Maximum Rabi Frequency <code>rabi_frequency_max</code> 15.8 rad/\u03bcs Rabi Frequency Resolution <code>rabi_frequency_resolution</code> 0.0004 rad/\u03bcs Maximum Rabi Frequency Slew Rate <code>rabi_frequency_slew_rate_max</code> 250.0 rad/\u00b5s\u00b2 Minimum Detuning <code>detuning_min</code> -125.0 rad/\u03bcs Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Detuning Resolution <code>detuning_resolution</code> 2.0\u00d710\u207b\u2077 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 2500.0 rad/\u00b5s\u00b2 Minimum Phase <code>phase_min</code> -99.0 rad Maximum Phase <code>phase_max</code> 99.0 rad Phase Resolution <code>phase_resolution</code> 5.0\u00d710\u207b\u2077 rad Minimum Time <code>time_min</code> 0.0 \u00b5s Maximum Time <code>time_max</code> 4.0 \u00b5s Time Resolution <code>time_resolution</code> 0.001 \u00b5s Minimum \u0394t <code>time_delta_min</code> 0.05 \u00b5s"},{"location":"analog/reference/hardware-capabilities/#local-detuning-values","title":"Local Detuning Values","text":"<ul> <li>Use prefix <code>your_capabilities_object.capabilities.rydberg.local</code> for the following values:</li> </ul> Capability Attribute Value Maximum Detuning <code>detuning_max</code> 125.0 rad/\u03bcs Minimum Detuning <code>detuning_min</code> 0 rad/\u03bcs Maximum Detuning Slew Rate <code>detuning_slew_rate_max</code> 1256.0 rad/\u00b5s\u00b2 Maximum Number of Local Detuning Sites <code>number_local_detuning_sites</code> 200 Maximum Site Coefficient <code>site_coefficient_max</code> 1.0 Minimum Site Coefficient <code>site_ceofficient_min</code> 0.0 Minimum Radial Spacing <code>spacing_radial_min</code> 5 \u00b5m Minimum \u0394t <code>time_delta_min</code> 0.05 \u03bcs Time Resolution <code>time_resolution</code> 0.001 \u00b5s"},{"location":"analog/reference/overview/","title":"Builder Overview","text":"<p>You may have noticed from the Quick Start and Tutorials that Bloqade uses this interesting, dot-intensive syntax.</p> <p><pre><code>from bloqade import start\n\nprog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform.constant(1,1)\n</code></pre> Exhibit A: Lots of Dots</p> <p>In fact, it might look remniscent of what you see in some gate-based Quantum Computing SDKs:</p> <pre><code># this is strictly pseudocode\ncircuit = init_qubits(n_qubits)\n# note the dots!\ncircuit.x(0).z(1).cnot(0, 1)...\n</code></pre> <p>What's the deal with that?</p>"},{"location":"analog/reference/overview/#syntax-motivations","title":"Syntax Motivations","text":"<p>We call this syntax the builder or builder syntax and as its name implies, it is designed to let you build programs for Analog Hamiltonian Simulation hardware as easily and as straightforward as possible.</p> <p>The linear structure implies a natural hierarchy in how you think about targeting the various degrees of freedom (detuning, atom positions, Rabi amplitude, etc.) your program will have. In the beginning you have unrestricted access to all these degrees of freedom but in order to do something useful you need to:</p> <ol> <li>Narrow down and explicitly identify what you want to control</li> <li>Provide the instructions on how you want to control what your focused on</li> </ol> <p>Context is a strong component of the builder syntax, as you are both actively restricted from doing certain things that can introduce ambiguity based on where you are in your program and repeating the same action in different parts of the program yields different results.</p>"},{"location":"analog/reference/overview/#visual-guides","title":"Visual Guides","text":"<p>While we hope the Smart Documentation (the ability to instantly see all your next possible steps and their capabilities in your favorite IDE/IPython) is sufficient to get you where you need to go, we understand it's particularly beneficial to get a high-level overview of things before diving in.</p> <p>The Standard Representation is a nice flow chart that gives a high-level overview of the different steps and components in the builder syntax.</p>"},{"location":"analog/reference/standard/","title":"Build Workflow","text":"<pre><code>\nflowchart TD\n  ProgramStart([\"start\"])\n\n  Geometry(\"Geometry or Lattice\")\n\n  Coupling[\"Coupling\n  -----------\n  rydberg\n  hyperfine\"]\n\n  Detuning[\"detuning\"]\n  Rabi[\"rabi\"]\n\n  Amplitude[\"amplitude\"]\n  Phase[\"phase\"]\n\n  SpaceModulation(\"SpatialModulation\n  ----------------------\n  uniform\n  scale\n  location\n  \")\n  Waveform{\"Waveform\n  ------------\n  piecewise_linear\n  piecewise_constant\n  constant\n  linear\n  poly\n  fn\n  \"}\n\n  Options([\"Options\n  ---------\n  assign\n  batch_assign\n  args\n  parallelize\n  \"])\n\n  Services([\"Services\n  ----------\n  bloqade\n  quera\n  braket\"])\n\n  QuEraBackends([\"Backends\n  ------------\n  mock\n  cloud_mock\n  aquila\n  device\"])\n\n  BraketBackends([\"Backends\n  ------------\n  aquila\n  local_emulator\"])\n\n  BloqadeBackends([\"Backends\n  ------------\n  python\n  julia\"])\n\n  Execution(\"\n  Execution hardware only\n  -------------------------------\n  run_async()\n\n  Hardware and simulation\n  -------------------------------\n  run()\n  __call__\")\n\n  ProgramStart --&gt;|add_position| Geometry;\n  Geometry --&gt; Coupling;\n  ProgramStart --&gt; Coupling;\n\n  Coupling --&gt; Detuning;\n  Coupling --&gt; Rabi;\n\n  Rabi --&gt; Amplitude;\n  Rabi --&gt; Phase;\n\n  Detuning --&gt; SpaceModulation;\n  Amplitude --&gt; SpaceModulation;\n  Phase --&gt; SpaceModulation;\n\n  SpaceModulation --&gt; Waveform;\n\n  Waveform --&gt; Coupling;\n  Waveform --&gt; Services;\n  Waveform --&gt; Options;\n  Options --&gt; Services;\n\n  Services --&gt;|quera| QuEraBackends;\n  Services --&gt;|braket| BraketBackends;\n  Services --&gt;|bloqade| BloqadeBackends;\n  QuEraBackends --&gt; Execution;\n  BraketBackends --&gt; Execution;\n  BloqadeBackends --&gt; Execution;\n\n  click ProgramStart \"../bloqade/#bloqade.start\";\n  click Geometry \"../bloqade/atom_arrangement/\";\n  click Coupling \"../bloqade/builder/drive/\";\n  click Detuning \"../bloqade/builder/field/#bloqade.builder.field.Detuning\";\n  click Rabi \"../bloqade/builder/field/#bloqade.builder.field.Rabi\";\n  click Amplitude \"../bloqade/builder/field/#bloqade.builder.field.Amplitude\";\n  click Phase \"../bloqade/builder/field/#bloqade.builder.field.Phase\";\n  click SpaceModulation \"../bloqade/builder/spatial/\";\n  click Waveform \"../bloqade/builder/waveform/\";\n  click Options \"../bloqade/builder/pragmas/\";\n  click Services \"../bloqade/builder/backend/\";\n  click QuEraBackends \"../bloqade/builder/backend/quera/#bloqade.builder.backend.quera.QuEraDeviceRoute\";\n  click BraketBackends \"../bloqade/builder/backend/braket/#bloqade.builder.backend.braket.BraketDeviceRoute\";\n  click BloqadeBackends \"../bloqade/builder/backend/bloqade/#bloqade.builder.backend.bloqade.BloqadeBackend\";\n  click Execution \"../bloqade/ir/routine/braket/#bloqade.ir.routine.braket.BraketRoutine\";\n</code></pre>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorial optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#highlights","title":"Highlights","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n\nimport numpy as np\n\nadiabatic_durations = [0.4, 3.2, 0.4]\n\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\n    Square(3, \"lattice_spacing\")\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=adiabatic_durations,\n        values=[\n            -max_detuning, # scalar variables support direct arithmetic operations\n            -max_detuning,\n            max_detuning,\n            max_detuning,\n        ],\n    )\n    .assign(max_rabi=15.8, max_detuning=16.33)\n    .batch_assign(lattice_spacing=np.arange(4.0, 7.0, 0.5))\n)\n\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenomena/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/","title":"A new journey for Bloqade","text":"<p>In 2023 we were excited to introduce Bloqade, a python SDK for programming and interfacing with analog mode neutral atom hardware based off feedback from our community as well as a need to make conducting experiments on our hardware easier. Today, we introduce the next generation of Bloqade: as well as programming analog-mode computation, our new bloqade module enables programming gate-based computation, with an eye on near-term NISQ demonstrations and intermediate-term fault tolerant solutions. Don\u2019t worry; all of your favorite features of the previous generation of Bloqade are still there under the <code>bloqade.analog</code> namespace, but now you can explore digital-mode computation specialized to reconfigurable neutral atom architectures. Why have we built this new module? There are plenty of incredible quantum programming packages, such as Qiskit and Cirq, as well as an entire ecosystem of middleware providers with specialized pipelines to turn abstract problems into circuits. However, these packages may not be everything that is needed for efficient hardware execution on neutral atom hardware: a circuits-only representation of quantum executions may be an insufficient abstraction for effective hardware-level programs. This is a challenge: we want to enable everyone to maximally leverage the power of neutral atom quantum computers beyond abstract circuit representations. For this reason, we are building Bloqade to be a hardware-oriented SDK to represent hybrid executions on reconfigurable neutral atom hardware. In this way, Bloqade can be integrated into the larger ecosystem\u2014for example, code generation of QASM from a Bloqade program, but be an SDK specialized to our hardware: THE SDK for neutral atoms.</p> <p>The vision of Bloqade is to empower quantum scientists, working on things ranging from applications development to algorithmic co-design, to build hybrid quantum-classical programs that leverage the strength of neutral atom quantum computers and have a real chance of demonstrating quantum utility. Bloqade is built on top of Kirin, an open source compiler infrastructure designed for kernel functions and embedded Domain-Specific Language (eDSL) creation.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#composable-quantum-programming","title":"Composable quantum programming","text":"<p>As of today, Bloqade has two objectives: digital and analog quantum computing. <code>bloqade-analog</code> is the SDK for analog-mode neutral atom computers and includes several handy utilities ranging from building and analyzing analog programs, to emulation and execution on QuEra's cloud-accessible hardware \"Aquila\". <code>bloqade</code> is the initial iteration to represent digital circuit execution using gate-based quantum computing on reconfigurable neutral atom architecture. It extends the QASM2 language to include extra annotation of circuits that is important for efficient execution, such as parallelism and global gates. As well as being able to construct quantum programs with the full convenience of features found in classical programming languages - such as loops, control flows and closures - <code>bloqade</code> also includes basic compiler transformation passes, emulation, and code generation.</p> <p>But <code>bloqade</code> is not done with just these two components. We envision adding new components (called \"dialects\") which help you write programs which are tuned for optimal performance in an error corrected era of neutral atom hardware. Stay tuned and help us build the future of quantum computing as we build out new components targeting QEC and atom moving!</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#hardware-oriented-programming-and-co-design","title":"Hardware-oriented programming and co-design","text":"<p>At its core, Bloqade strives to be the neutral atom SDK for getting the most out of today's and tomorrows' quantum hardware. It is clear that the circuit-level abstraction is not enough to program real quantum hardware; indeed, tomorrows' quantum demonstrations and applications must program at the hardware level and develop special tooling to compile higher-level abstractions to efficient implementations. We call this process \"co-design\": designing algorithms specialized to near-term hardware, with an eye on nontrivial demonstrations and scalable solutions. Ultimately, this co-design approach requires hardware-specific DSLs which explicitly represent the native executions on neutral atom hardware: in other words, Bloqade.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#hybrid-computing-beyond-circuits","title":"Hybrid computing beyond circuits","text":"<p>Many quantum algorithms are hybrid, requiring both classical and quantum resources to work together in tandem. This could be anything from syndrome extraction and measurement-based computing to variational parameter updates in VQE methods and orbital fragmentation methods in molecular simulation. Through the use of the Kirin compiler infrastructure, Bloqade embraces this philosophy of heterogeneous compute. Kirin programs are written as (compositions of) kernels -- subroutines that are intended to run on particular hardware (such as QPUs), or orchestrated to run on heterogeneous compute (such as a real-time classical runtime plus a QPU). These subroutines -- plus the built-in hybrid representations-- enable many key primitives, such as error correction.</p> <p>Additionally, the ability to compose functions together and to use typical classical programming structures like <code>if</code> and recursions enables many simplifications in writing complex circuits. In fact, recursions and the ability to dynamically allocate new memory (which is not known until runtime) enables many powerful subroutines and is natively enabled with Bloqade's kernel-based representation; for example, see this implementation of a repeat-until-success program.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#analog-digital-logical-towards-real-quantum-utility","title":"Analog, digital, logical: towards real quantum utility","text":"<p>The first step in Bloqade's journey was building out the analog mode SDK, designed to interface with QuEra\u2019s cloud-accessible analog-mode neutral-atom quantum computer Aquila, as well as enable analysis and scientific discovery in analog quantum computing. But the journey should not stop there: real quantum utility is error corrected and requires robust algorithmic exploration and design of quantum primitives, in-depth analysis of near-term hardware performance and benchmarking, and building pipelines and hybrid architectures that are intended not just for today\u2019s demonstrations but also for tomorrow\u2019s utility-scale hardware. By introducing the next generation of Bloqade, we hope to enable this exploration by adding in support for near-term digital and intermediate-term logical representations of hybrid quantum computations.</p>"},{"location":"blog/2025/03/01/a-new-journey-for-bloqade/#learn-more","title":"Learn more","text":"<p>Bloqade is an open-source project and can be freely downloaded and modified; you can learn how to do so here. If you want to see how to write programs with the new <code>bloqade</code> package, check out our examples here. If you would like to learn more about QuEra Computing Inc., check out our webpage as well as discover our many academic publications and demonstrations.</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/","title":"Simulating noisy circuits for near-term quantum hardware","text":"<p>With recent experimental demonstrations of digital quantum circuits executed on neutral atom devices, a new era is beginning for this still-nascent technology. At QuEra, we have used our newly completed Gemini-class quantum computer to demonstrate a key building block of fault-tolerant quantum computation: logical magic state distillation. By both leveraging the universal quantum gate-set and all-to-all connectivity offered by our hardware, while also maximizing parallelism, this work demonstrates the potential of neutral atom QPUs. As the availability of Gemini-class machines increases in the near future, it is paramount to provide researchers with tools to develop quantum circuits that are well-suited for Gemini. With that goal in mind, we have released circuit-level noise models in bloqade that closely mimic the performance of the device for small system sizes, allowing for circuit optimization and feasibility checks.</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#motivation-for-gemini-class-digital-qpus","title":"Motivation for Gemini-class digital QPUs","text":"<p>Operating in an analog mode of quantum computation QuEra's Aquila quantum computer has opened exciting opportunities to leverage the flexibility of a neutral atom platform to explore the application forefront (such as optimization problems, and machine learning), as well as to address more scientifically oriented questions (preparation of exotic phases of matter).</p> <p>In our journey towards building useful quantum computers, however, we find that operating in an analog mode limits the range of problems that we can address, as we only have control of a handful of parameters of the underlying device Hamiltonian. This is where a fully programmable digital quantum computer comes into the picture. The promise of this mode of operation is the ability to encode non-native problems to the neutral atom platform. For instance, one of the envisioned and most exciting applications of quantum computers is the accurate simulation (in terms of estimating ground state energy) of electrons in molecules and materials. The fermionic statistics of the target particles to simulate stand in contrast to the bosonic nature of the Rubidium atoms that constitute the building blocks of our platform.</p> <p>Furthermore, we need full control in the quantum device to encode interactions and tunneling parameters between the fermionic modes that discretize our target molecules and materials. In our quest to reach this level of maturity in quantum hardware, we introduce Gemini-class devices, that incorporate digital programmability features into our neutral atom quantum computing platform.</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#circuit-level-compared-to-hardware-level-programming","title":"Circuit-level compared to hardware-level programming","text":"<p>Gemini-class devices are digital quantum computers. This allows the user to work on the circuit-level of abstraction rather than the hardware-level. While this opens many new classes of problems for study with our quantum hardware, in the current era of noisy intermediate scale quantum devices, it is imperative to consider potential noise processes when developing quantum programs.</p> <p>When writing a circuit, noise processes can be taken into account as channels that cause decoherence, thereby reducing the overall circuit fidelity. If the fidelity is too low, the results of the computation may include unwanted bias or the signal may be suppressed towards zero. Therefore, before executing a circuit it is critical to know whether this circuit will actually yield the desired results. This is where emulation comes in, which, in order to faithfully represent the results of Gemini, needs to account for noise.</p> <p>At the hardware level, quantum circuit design always needs to incorporate (or work around) the noise that is inherent to the QPU system. This comes at the loss of abstraction and subsequently high-level tooling. At the same time, however, it enables researchers to devise individual strategies in order to suppress noise in specific applications, which will oftentimes outperform today's general-use compilers. Here, we will focus on circuit-level programming, but please refer to bloqade-shuttle to learn more about our hardware-level programming capabilities.</p> <p>Even including noise channels, circuit-level programming remains abstract in that you do not have to consider the specific hardware you are running the circuit on. However, it is the very nature of the noise channels, where the details of the hardware come into play. To know whether a circuit will execute with a sufficiently high fidelity, the noise parameters and channels need to represent the infidelity of the gates executed on the particular hardware (in this case, Gemini).</p> <p>In order to provide users with the required set of tools, we have spent considerable time researching and implementing an easy-to-use framework that allows you to include Gemini's particular noise processes in a high-level circuit.</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#heuristic-approach-to-noise","title":"Heuristic approach to noise","text":"<p>The abstraction of noise to the circuit level allows all the noise sources on the device to be combined into \"effective\" Pauli noise channels. The effective channels are heuristic in nature, designed to capture the average behavior of atoms when the system performs certain circuit-level operations. The quantitative error probabilities are based on benchmarking experiments on Gemini hardware. They also take into account the dynamical decoupling that is needed to eliminate the effects of differential stark shifts during atom moves. Overall, the models can be expressed by six main noise channels:</p> <ol> <li>Global single qubit gate error<ul> <li>Depolarizing error applied to all qubits after a single qubit gate is applied to all qubits in parallel.</li> </ul> </li> <li>Local single qubit gate error<ul> <li>Depolarizing error applied to gated single qubits after a single qubit gate is applied to a subset of qubits.</li> </ul> </li> <li>CZ gate error<ul> <li>Pauli error channel that is biased towards phase errors applied to both qubits that are within the blockade radius   during a Rydberg pulse.</li> <li>Incorporates errors from the Rydberg pulse and dynamical decoupling.</li> </ul> </li> <li>Unpaired Rydberg error<ul> <li>Pauli error channel is biased towards phase errors applied to single qubits that experience a Rydberg pulse but do   not have a partner qubit within the blockade radius.</li> <li>Incorporates errors from the Rydberg pulse and dynamical decoupling.</li> </ul> </li> <li>Mover error<ul> <li>Pauli error channel that is also biased towards phase errors applied to qubits that must move during a circuit.</li> <li>Incorporates errors from transferring atoms from fixed tweezer traps to dynamical traps for moves, dynamical   decoupling, move errors, and idling errors.</li> </ul> </li> <li>Sitter error<ul> <li>Pauli error channel that is applied to atoms that are stationary while other atoms are moving.</li> <li>Incorporates errors from dynamical decoupling and idling errors.</li> </ul> </li> </ol>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#example-noise-in-the-ghz-state","title":"Example: Noise in the GHZ state","text":"<p>It is often most convenient to study an example in order to learn how to use a set of tools. To this end, we included a tutorial that shows how to annotate a GHZ preparation circuit using the different heuristic noise models. We'll discuss some underlying concepts and highlight interesting parts of the tutorial in this section. If you want all the details, please find the full example here.</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#flow-chart","title":"Flow chart","text":"<p>The intended workflow for using the circuit-level noise models is described in the flow chart below. The first step for a user interested in testing a specific quantum algorithm is to write an explicit circuit in Cirq. Once defined in Cirq, the circuit operations can be visualized with <code>print(circuit)</code>, which can be used to inspect the circuit after being passed through the various transformers within <code>bloqade</code>. Also, at any point, one may choose to simulate the result of the circuit with the tools provided by Cirq.</p> <p>By passing the circuit through the transformers in <code>parallelize.py</code>, within the <code>bloqade-circuit.cirq_utils</code> repository, the circuit structure can be brought closer to optimal for the neutral atom platform. Then, by using the transformers in <code>noise.transform.py</code>, Pauli error channels are locally added to the circuit. The function <code>transform_circuit</code> acts as a wrapper for the different noise models, which correspond to different modes of hardware operation.</p> <p>Finally, we maintain interoperability between Squin (Bloqade's circuit-level intermediate representation) and Cirq. Squin allows for simulation with different backends, including PyQrack, while also allowing for lowering to hardware-level programs for execution on Gemini.</p> <p></p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#annotated-circuit","title":"Annotated circuit","text":"<p>In practice, our heuristic noise models are used to annotate circuits with incoherent channels, with a \"coarse-grained\" awareness of hardware. As a simple example, let's consider the following that assumes noise annotation according to a two-zone layout using  the <code>GeminiTwoZoneNoiseModel</code> in <code>bloqade-circuit.cirq_utils.noise.models</code>:</p> <p></p> <p>In our annotation scheme, assume that we are iterating sequentially over the layers of a quantum circuit, and we encounter the layer depicted in a) on which we will add the noise channels. One important assumption in our two-zone model to keep in mind is that the qubits corresponding to the gates appearing in a given layer will be treated as being in the gate zone, and thus the rest of the qubits are assumed to be in the storage zone.</p> <p>To capture the cost of moves to reach a given configuration, we need to take a closer look at the layer that precedes our current target layer. In b), we explicitly show the layer that was annotated with noise in the previous iteration, with its corresponding qubit spatial layout below it. The move cost to reach the target qubit configuration before qubit execution is shown in c), and noise annotation is carried out according to three sequential stages: 1) qubits that need to be removed from the gate zone undergo move error (orange crosses), and the rest get sitter error, 2) similarly, qubits that need to be added to the gate zone get move error and the rest get sitter noise, and 3) additional move error to \"pair up\" qubits is added before gate execution (notice that more than one layer might be needed to account for this cost).</p> <p>Finally, noise is annotated after gates, where it is assumed that entangling gates are executed in hardware before single qubit gates. In doing so, qubits that are not participant in the entangling gates receive unpaired cz error (green pentagons).</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#ghz-data","title":"GHZ data","text":"<p>Now, let's look at some results of the example that compares the different noise processes.</p> <p>The different noise models lead to overall different infidelities of the circuit:</p> <p></p> <p>As you'd expect, the general trend is that fidelity decreases with a growing number of qubits. Depending on how many qubits you need, you may want to run the above simulation in order to decide whether you'd want to operate Gemini in a one-zone or a two-zone setup.</p> <p>On a more abstract level, you may also want to optimize the circuit that you use to obtain the result you want. The example uses a linear-depth GHZ algorithm, which is arguably not the best choice to prepare a GHZ state.</p> <p>Using our noise framework, you can explore and analyze different strategies to find the one best suited for your particular application.</p>"},{"location":"blog/2025/07/30/simulating-noisy-circuits-for-near-term-quantum-hardware/#learn-more","title":"Learn more","text":"<p>The future for Gemini is bright! Apart from demonstrating logical magic state distillation, Gemini-class QPUs also form the foundation of QuEra's participation in the Quantum for Bio program. QuEra will serve as the hardware provider for 2 of 6 of the teams that have advanced to the final phase of the challenge. With an eye towards general availability of Gemini-class devices, there's no better time for quantum developers to begin crafting circuits that are well-suited for Gemini. The documentation for Bloqade-circuit as well as our tutorial guides are a great place to start.</p>"},{"location":"digital/","title":"Index","text":"<p>Note</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"digital/#digital-bloqade","title":"Digital Bloqade","text":"<p>The digital submodule of Bloqade, called <code>bloqade-circuit</code> defines a set of embedded domain-specific languages (eDSLs) that can be used to define digital quantum programs. These programs are intended for both simulation and to be run on hardware. This package is open source and can be found on GitHub.</p> <p>Please refer to the Dialects and Kernels section of this documentation for an overview over the most important eDSLs. The infrastructure behind these compilers is built on top of Kirin.</p> <p>It is easiest to learn how to use this package by checking out the examples &amp; tutorials section, where we show how you can build and study different quantum programs written in different DSLs. You can also find the corresponding scripts in jupytext format at the bloqade repository under <code>docs/digital/examples/</code>.</p> <p>Finally, if you want the full details on the API, please refer to the API reference documentation.</p>"},{"location":"digital/#installation","title":"Installation","text":"<p>The package comes as a submodule of Bloqade, so you can just run</p> <pre><code>pip install bloqade\n</code></pre> <p>in order to obtain it.</p> <p>Sometimes, you may want to reduce the number of dependencies, in which case you can also only install the submodule</p> <pre><code>pip install bloqade-circuit\n</code></pre> <p>Note, that bloqade-circuit also has some optional dependencies, which you may want to install. For example</p> <pre><code>pip install bloqade-circuit[cirq,qasm2,stim]\n</code></pre>"},{"location":"digital/#tldr","title":"TL;DR","text":"<p>Here's a GHZ preparation circuit with a measurement at the end written in the <code>squin</code> dialect:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef ghz(n: int):\n    q = squin.qalloc(n)\n\n    squin.gate.h(q[0])\n\n    for i in range(1, n):\n        squin.gate.cx(q[i - 1], q[i])\n\n    return squin.qubit.measure(q)\n</code></pre> <p>Here are some more examples.</p>"},{"location":"digital/compilation/","title":"Understanding the compilation process","text":"<p>The compilation process is divided into several stages:</p> <ol> <li>Lowering: a decorator such as <code>qasm2.extended</code> takes the Python Abstract Syntax Tree (AST) and lowers it into Kirin's Intermediate Representation (IR) which follows Static Single Assignment (SSA) form.</li> <li>Interpretation: when invoking a backend, such as the PyQrack simulator, the IR code is interpreted by an interpreter featuring the corresponding method tables for the runtime evaluation of the dialect statements.</li> <li>Target code generation: when emitting code, several steps can be involved before the actual code emission, depending on the target. Similar to interpretation, each statement will be translated to one that fits the chosen target. For example, when emitting QASM2, the following steps occur:</li> <li>The IR code gets aggressively inlined and all constant expressions are evaluated.</li> <li>All loops and control flow are unrolled.</li> <li>All compatible Python expressions (e.g <code>sin</code>, arithmetics) are translated into QASM2 expressions.</li> <li>The QASM2 code is emitted as QASM2 AST for pretty printing.</li> </ol>"},{"location":"digital/compilation/#progressive-compilation","title":"Progressive compilation","text":"<p>As well as writing circuit executions, you can also progressively transform and compile that circuit. While it is possible to write your own compiler passes and optimizations - for that, please refer to the <code>kirin</code> documentation - <code>bloqade-circuit</code> also offers a number of different, pre-defined optimizations.</p> <p>Warning</p> <p>Compiler and optimization passes are currently under development. While quite a lot of them are used internally, they are not in a user-friendly state. Please proceed with caution!</p>"},{"location":"digital/compilation/#dialect-groups","title":"Dialect groups","text":"<p>Bloqade provides a set of dialects for QASM2 and our custom extensions to model parallel gates in neutral atom architectures. The basic QASM2 functionality can be enabled via</p> <pre><code>pip install bloqade[qasm2]\n</code></pre>"},{"location":"digital/compilation/#extended-qasm","title":"Extended QASM","text":"<p>The decorator <code>qasm2.extended</code> is a group of smaller dialects:</p> <pre><code>extended = structural_no_opt.union(\n     [\n         inline,\n         uop,\n         glob,\n         noise,\n         parallel,\n         core,\n     ]\n )\n</code></pre> <p>where <code>structural_no_opt</code> is the base dialect group (defined in <code>kirn</code>) that provides the basic control flow, common Python expressions (but not all), then:</p> <ul> <li><code>core</code> provides the core QASM2 operations such as register allocation, measurement and reset.</li> <li><code>uop</code> provides the unary operations, such as standard Pauli gates, rotation gates, etc.</li> </ul> <p>The following dialects are specific to neutral atom quantum computing as an extension:</p> <ul> <li><code>glob</code> provides the global gates (Rydberg specific)</li> <li><code>noise</code> provides the noise channels</li> <li><code>parallel</code> provides the parallel gate support (Rydberg specific).</li> <li><code>inline</code> provides the inline QASM string</li> </ul>"},{"location":"digital/compilation/#strict-qasm2-mode","title":"Strict QASM2 mode","text":"<p>While the <code>qasm2.extended</code> decorator provides a lot of high-level features as an extension of QASM2, you may want to program in strict QASM2 mode for compatibility reasons. You can do this by using the <code>qasm2.main</code> and <code>qasm2.gate</code> decorators. Note that <code>qasm2.main</code> features all standard QASM2 instructions, whereas <code>qasm2.gate</code> adds the functionality for defining custom gate subroutines.</p> <pre><code>@qasm2.main\ndef main():\n    qasm2.h(0)\n    qasm2.cx(0, 1)\n    qasm2.measure(0)\n    qasm2.measure(1)\n    return qasm2.qreg(2)\n</code></pre> <p>which corresponds to the following QASM2 code:</p> <pre><code>OPENQASM 2.0;\ninclude \"qelib1.inc\";\n\nqreg q[2];\ncreg c[2];\n\nh q[0];\ncx q[0], q[1];\nmeasure q[0] -&gt; c[0];\nmeasure q[1] -&gt; c[1];\n</code></pre> <p>Note that <code>return</code> is not supported in QASM2 and are therefore omitted in the code above.</p>"},{"location":"digital/cirq_interop/","title":"Interoperability with cirq","text":"<p>The Cirq framework is a powerful tool for writing quantum circuits targeting near-term devices. Instead of reinventing the wheel, Bloqade offers convenient interoperability with Cirq that allows you to jointly use both libraries in order to develop your quantum program.</p> <p>Specifically, you can turn a <code>cirq.Circuit</code> object into a squin kernel function and vice versa.</p> <p>For details on each of these, please see the documentation pages below:</p> <ul> <li>Obtaining a squin kernel function from a <code>cirq.Circuit</code></li> <li>Emitting a <code>cirq.Circuit</code> from a squin kernel</li> </ul> <p>For the API reference, please see the <code>cirq_utils</code> submodule in the API reference, specifically here and here.</p>"},{"location":"digital/cirq_interop/#tldr","title":"TL;DR","text":"<p>Here's a short example:</p> <pre><code>from bloqade import cirq_utils\nimport cirq\n\nq = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(q[0]),\n    cirq.CX(q[0], q[1])\n)\nprint(circuit)\n\nmain = cirq_utils.load_circuit(circuit)\nmain.print()\n\nroundtrip_circuit = cirq_utils.emit_circuit(main)\nprint(roundtrip_circuit)\n</code></pre>"},{"location":"digital/cirq_interop/cirq_to_squin/","title":"Converting cirq to squin","text":"<p>If you want to obtain a squin kernel from a circuit, you can use the <code>load_circuit</code> method in the <code>cirq_utils</code> submodule. What you're effectively doing is lowering a circuit to a squin IR. This IR can then be further lowered to eventually run on hardware.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#basic-examples","title":"Basic examples","text":"<p>Here are some basic usage examples to help you get started.</p> <pre><code>from bloqade import squin, cirq_utils\nimport cirq\n\nqubits = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    cirq.CX(qubits[0], qubits[1]),\n    cirq.measure(qubits)\n)\n\n# let's have a look\nprint(circuit)\n\nmain_loaded = cirq_utils.load_circuit(circuit, kernel_name=\"main_loaded\")\n</code></pre> <p>The above is equivalent to writing the following kernel function yourself:</p> <pre><code>@squin.kernel\ndef main():\n    q = squin.qalloc(2)\n    squin.h(q[0])\n    squin.cx(q[0], q[1])\n    squin.qubit.measure(q)\n</code></pre> <p>You can further inspect the lowered kernel as usual, e.g. by printing the IR. Let's compare the manually written version and the loaded version:</p> <pre><code>main.print()\nmain_loaded.print()\n</code></pre> <p>The resulting IR is equivalent, yet the loaded is a bit longer since the automated loading can make fewer assumptions about the code. Still, you can use the kernel as any other, e.g. by calling it from another kernel or running it via a simulator.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#noise","title":"Noise","text":"<p>Lowering a noisy circuit to squin is also supported. All common channels in cirq will be lowered to an equivalent noise statement in squin.</p> <pre><code>from bloqade import cirq_utils\nimport cirq\n\nqubits = cirq.LineQubit.range(2)\nnoisy_circuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    cirq.CX(qubits[0], qubits[1]),\n    cirq.depolarize(p=0.01).on_each(qubits),\n)\n\n# let's have a look\nprint(noisy_circuit)\n\nnoisy_kernel = cirq_utils.load_circuit(noisy_circuit)\nnoisy_kernel.print()\n</code></pre> <p>This becomes especially useful when used together with a <code>cirq.NoiseModel</code> that automatically adds noise to a circuit via <code>circuit.with_noise(model)</code>.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#composability-of-kernels","title":"Composability of kernels","text":"<p>You may also run into a situation, where you define a circuit that is used as part of a larger one, maybe even multiple times. In order to allow you to do something similar here, you can pass in and / or return the qubit register in a loaded kernel. Both these options are controlled by simple keyword arguments.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#qubits-as-argument-to-the-kernel-function","title":"Qubits as argument to the kernel function","text":"<p>Setting <code>register_as_argument=True</code> when loading a kernel, will result in a squin kernel function that accepts (and requires) a single argument of type <code>IList[Qubit]</code>. This means you can use a loaded circuit as part of another kernel function. Check it out:</p> <pre><code>from bloqade import squin, cirq_utils\nimport cirq\n\nqubits = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(\n    cirq.H(qubits[0]),\n    cirq.CX(qubits[0], qubits[1]),\n)\n\nsub_kernel = cirq_utils.load_circuit(circuit, register_as_argument=True, kernel_name=\"sub_kernel\")\n\n\n@squin.kernel\ndef main():\n    q = squin.qalloc(4)\n\n    # entangle qubits 1 and 2\n    sub_kernel([q[0], q[1]])\n\n    # entangle qubits 3 and 4\n    sub_kernel([q[2], q[3]])\n\n\nmain.print()\n</code></pre> <p>Looking at the IR of the resulting kernel, you can see that there is are <code>invoke sub_kernel</code> statements present, which call the lowered circuit with the given arguments.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#qubits-as-return-value-from-the-kernel","title":"Qubits as return value from the kernel","text":"<p>Similarly to above, you may also want to return a list of qubits from a loaded kernel. Let's adapt the above to instantiate and return a pair of entangled qubits using the same circuit:</p> <pre><code>sub_kernel = cirq_utils.load_circuit(circuit, return_register=True, kernel_name=\"sub_kernel\")\n\n@squin.kernel\ndef main():\n    # instantiate and entangle a list of two qubits\n    q1 = sub_kernel()\n\n    # do it again, to get another set\n    q2 = sub_kernel()\n\n    # now we have 4 qubits to work with\n    ...\n\nmain.print()\n</code></pre> <p>Note</p> <p>You can also mix both options by setting <code>register_as_argument = True</code> and <code>return_register = True</code> in order to obtain a kernel function that both accepts and returns a list of qubits.</p>"},{"location":"digital/cirq_interop/cirq_to_squin/#limitations","title":"Limitations","text":"<p>There are some limitations when loading circuits. One, for example, is that custom gates are not supported as you can't generally know how to lower them to a squin statement.</p> <p>If you find a missing feature, please feel free to open a GitHub issue.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/","title":"Converting squin to Cirq","text":"<p>You can convert a squin kernel function to a <code>cirq.Circuit</code> object. The output circuit will feature gates that most closely resemble the kernel you put in.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/#basic-usage","title":"Basic usage","text":"<p>You can obtain a circuit using the <code>cirq_utils.emit_circuit</code> function.</p> <pre><code>from bloqade import squin, cirq_utils\n\n@squin.kernel\ndef main():\n    q = squin.qalloc(2)\n    h = squin.op.h()\n    squin.qubit.apply(h, q[0])\n    cx = squin.op.cx()\n    squin.qubit.apply(cx, q[0], q[1])\n    squin.qubit.measure(q)\n\ncircuit = cirq_utils.emit_circuit(main)\nprint(circuit)\n</code></pre> <p>There is one crucial difference between a squin kernel and a cirq circuit: the qubits are defined inside a kernel, whereas for a circuit they are defined outside.</p> <p>The default behavior here is to emit a set of <code>cirq.LineQubit</code>, which is of the correct length. They will be sorted by their <code>Qid</code> (position) according to the order they appear in the kernel.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/#customizing-qubits","title":"Customizing qubits","text":"<p>By default, a set of <code>cirq.LineQubit</code>s of the appropriate size is created internally, on which the resulting circuit operates. This may be undesirable sometimes, e.g. when you want to combine multiple circuits or if you want to have qubits of a different type.</p> <p>To allow modifications here, you can simply pass in a list of qubits (a sequence of <code>cirq.Qid</code>s) into the emit function.</p> <pre><code>import cirq\n\nqubits = cirq.GridQubit.rect(rows=1, cols=2)\ncircuit = cirq_utils.emit_circuit(main, qubits=qubits)\nprint(circuit)\n</code></pre> <p>Note, that the qubits will be used in the resulting circuit in the order they appear in <code>squin.qalloc</code> statements.</p> <p>Warning</p> <p>When passing in a list of qubits, you need to make sure there is sufficiently many qubits. Otherwise, you may get indexing errors.</p>"},{"location":"digital/cirq_interop/squin_to_cirq/#limitations","title":"Limitations","text":"<p>Please note that there are some limitations, especially regarding control flow. Using <code>if</code> statements or loops inside a kernel function may lead to errors.</p> <p>If you run into an issue that you think should be supported, please report an issue on the GitHub repository.</p>"},{"location":"digital/dialects_and_kernels/","title":"Dialects and kernels","text":"<p>Bloqade provides a set of pre-defined domain specific languages (DSLs), with which you can write your programs and circuits. We call these DSLs dialects. For a list of available dialects see blow.</p> <p>Once you have defined your kernel, you can inspect their Intermediate Representation (IR), apply different optimizations using compiler passes, or run them on a (simulator) device.</p> <p>Kernels &amp; dialects in a nutshell</p> <p>A kernel function is a piece of code that runs on specialized hardware such as a quantum computer or a GPU.</p> <p>A dialect is a domain-specific language (DSL) with which you can write such a kernel. Each dialect comes with a specific set of statements and instructions you can use in order to write your program.</p> <p>When running code that targets a specialized execution environment, there are typically several layers involved. At the surface, the programmer writes functions in a syntax that may resemble a host language (e.g., Python), but is actually expressed in a dialect \u2014 a domain-specific variant with its own semantics. A decorator marks these functions so they can be intercepted before normal host-language execution. All dialects can be used by decorating a function.</p> <p>Primer on Python decorators</p> <p>A decorator in Python is simply a function (or any callable really) that takes in another function as argument and returns yet another function (callable). Usually, the returned function will be a modified version of the input. Decorators are used with the <code>@</code> syntax.</p> <p>Instead of running directly, the kernel function body is parsed and translated (lowered) into an intermediate representation (IR). This IR can be manipulated (e.g. to perform optimizations) and can later be executed by an interpreter that understands the dialect's semantics. The interpreter uses an internal instruction set to execute the code on the intended backend, which may be a simulator, virtual machine, or physical device. This separation lets developers write high-level, expressive code while the interpreter ensures it runs correctly in the target environment. QuEra's Kirin provides the infrastructure that allows us to define custom dialects tailored towards the needs of programming neutral atom quantum computers in Bloqade While the dialects are not Python syntax, Kirin still uses the Python interpreter to execute the code.</p> <p>Note</p> <p>It is important to understand that when you are writing a kernel function in a dialect you are generally not writing Python code, even though it looks a lot like it. Therefore, kernel functions are not (usually) directly callable. Think of this as trying to execute another programming language with the Python interpreter: of course, that will error.</p>"},{"location":"digital/dialects_and_kernels/#available-dialects","title":"Available dialects","text":"<p>Bloqade offers a few different dialects with which you can write your programs. All dialects have some advantages for particular applications.</p> <p>If you are unsure which dialect best suits your needs, have a look at the high-level overview of the (non-exhaustive) list of use cases below. Also, we recommend having a look at the Structural QUantum INstructions (SQUIN) dialect as it is the most general purpose dialect available and is centrally used in the compilation pipeline.</p> <p>While the documentation in this section provides some information on the background and a high-level overview, it is also often convenient to learn from examples. Have a look at the (growing) examples collection, where you can find different implementations of quantum programs using different dialects.</p>"},{"location":"digital/dialects_and_kernels/#squin","title":"squin","text":"<p>This is the central dialect of bloqade-circuit, with which you can write your quantum programs. Rather than just defining circuits in terms of gates and qubits, this dialect also makes it possible to use control flow. Have a look at the dedicated documentation page and the corresponding API reference.</p> <p>Use cases:</p> <ul> <li>Writing a program that represents a circuit.</li> <li>If you require control flow (loops and if-statements, ...) and composability (function definitions, recursion, ...).</li> <li>Simulation including noise.</li> </ul>"},{"location":"digital/dialects_and_kernels/#qasm2","title":"qasm2","text":"<p>There are a number of dialects with which you can write kernels that represent programs in the Quantum Assembly Language (QASM2). More details can be found here. Also, have a look at the full qasm2 API reference</p> <p>Use cases:</p> <ul> <li>Write circuits using the QASM2 standard.</li> <li>Composability with other tools that integrate with QASM2, but not with bloqade directly.</li> <li>Control flow via the extended dialect (not always compatible with native QASM2).</li> </ul>"},{"location":"digital/dialects_and_kernels/#stim","title":"stim","text":"<p>For quantum error correction applications, you may want to use this dialect. See this documentation page for more details. The full API documentation is available here.</p> <p>Use cases:</p> <ul> <li>Quantum error correction.</li> <li>Stabilizer codes.</li> </ul>"},{"location":"digital/dialects_and_kernels/qasm2/","title":"Open Quantum Assembly Language and beyond","text":"<p>We have chosen to closely mirror the semantics of the Open Quantum Assembly Language (QASM2) in bloqade-circuits. For details on the language, see the specification.</p>"},{"location":"digital/dialects_and_kernels/qasm2/#qasm2main","title":"qasm2.main","text":"<p>This dialect allows you to write native QASM2 programs, with all its features and restricitions. As such, it includes definitions for gates, measurements and registers (quantum and classical), which are part of the QASM2 specification.</p> <p>Here's an example kernel</p> <pre><code>from bloqade import qasm2\n\n@qasm2.main\ndef main():\n    q = qasm2.qreg(2)\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n\n    c = qasm2.creg(2)\n    qasm2.measure(q, c)\n    return c\n</code></pre> <p>You can also look at the QASM2 program this kernel represents by emitting QASM2 code from it:</p> <pre><code>from bloqade.qasm2.emit import QASM2\nfrom bloqade.qasm2.parse import pprint\n\n\ntarget = QASM2()\nqasm2_program = target.emit(main)\npprint(qasm2_program)\n</code></pre>"},{"location":"digital/dialects_and_kernels/qasm2/#qasm2extended","title":"qasm2.extended","text":"<p>The QASM2 dialect is a simple quantum assembly language that allows you to write quantum circuits in a human-readable format. However, one should note that QASM2 is a very restricted language and does not support all the features of a high-level language.</p> <p>For example, there is a separation of gate routines declared with <code>gate</code> and main program written as a sequence of gate applications. While the gate routine is similar to a function in many ways, it does not support high-level features such as recursion (due to lack of <code>if</code> statement support inside) or control flows.</p> <p>Indeed, <code>bloqade-circuit</code> is designed with the notion of kernels in mind by decorating functions with a <code>@qasm2.extended</code> decorator. The Python code is interpreted and parsed by the Kirin compiler toolchain and lowered to an abstract representation of the program. These kernels can include classical computation and the usual programming structures-- if/else, for and while loops, function inputs, and the like, as one is used to in Python.</p> <p>Additionally, the QASM2 representations of bloqade-circuits have been extended to include a key advantage of reconfigurable neutral atom hardware: parallelism. For example, one can represent a CZ gate applied to many qubit pairs at once as</p> <pre><code>from bloqade import qasm2\nfrom kirin.dialects import ilist\nfrom typing import Any\n\n@qasm2.extended\ndef parallel_cz(controls: ilist.IList[qasm2.Qubit, Any], targets: ilist.IList[qasm2.Qubit, Any]):\n    for ctr in range(len(controls)):\n        qasm2.cz(ctrl=controls[0],qarg=targets[1])\n</code></pre> <p>or equivalently use a SIMD (Single Instruction Multiple Data)-like instruction to explicitly flag the parallelism</p> <pre><code>@qasm2.extended\ndef simd_cz(controls: ilist.IList[qasm2.Qubit, Any], targets: ilist.IList[qasm2.Qubit, Any]):\n    qasm2.parallel.cz(ctrls=controls,qargs=targets)\n</code></pre> <p>Both will ultimately emit the exact same QASM code, but the latter snippet represents the kind of parallelism that can be leveraged by reconfigurable neutral atom hardware to more efficiently execute a program.</p> <p>Warning</p> <p>Since <code>qasm2.extended</code> has more advanced features that QASM2 in general, it is not always possible to emit a valid QASM2 program from a <code>qasm2.extended</code> kernel. You have to make sure that the control flow is simple enough it can be unrolled. See below for an example of such a case. Alternatively, a sure-fire, but restrictive, way is to stick to writing your kernel using <code>qasm2.main</code>.</p>"},{"location":"digital/dialects_and_kernels/qasm2/#quick-example","title":"Quick Example","text":"<p>You can program kernels and quantum programs using the <code>qasm2.extended</code> decorator, such as the following Quantum Fourier Transform (QFT) circuit:</p> <pre><code>import math\nfrom bloqade import qasm2\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int, k: int):\n    if k == n:\n        return qreg\n\n    qasm2.h(qreg[k])\n    for i in range(k + 1, n):\n        qasm2.cu1(qreg[i], qreg[k], math.pi / 2**i)\n    qft(qreg, n, k + 1)  # recursion\n    return qreg\n\nqft.print()\n</code></pre> <p>While the syntax is similar to Python, the <code>qasm2.extended</code> decorator actually compiles the <code>qft</code> function into lower-level Intermediate Representation (IR) code that can be later interpreted, analyzed, or executed on quantum hardware. Observe that this function cannot immediately compile down to QASM as it takes parametrized inputs, and is called recursively.</p> <p>You can inspect the initial IR code by calling the pretty printer:</p> <pre><code>qft.print()\n</code></pre> <p></p> <p>We can also emit QASM2 code from it. Note that native QASM2 does not support arguments or return values. Therefore, we wrap the <code>qft</code> kernel from above in another one, that simply invokes <code>qft</code> for a specific set of arguments. Then, we emit this new kernel as a QASM2 program.</p> <pre><code>from bloqade.qasm2.emit import QASM2 # the QASM2 target\nfrom bloqade.qasm2.parse import pprint # the QASM2 pretty printer\n\n# NOTE: we wrap the qft kernel calling it with a set of arguments\n@qasm2.extended\ndef main():\n    n = 3\n    q = qasm2.qreg(n)\n    qft(q, n, 0)\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</code></pre> <p></p>"},{"location":"digital/dialects_and_kernels/qasm2/#noise","title":"Noise","text":"<p>You can represent different noise processes in your QASM2 kernel. As of now, there are essentially two different noise channels:</p> <ul> <li>A Pauli noise channel, which can represent different types of decoherence.</li> <li>An atomic loss channel, which can be used to model effects of losing a qubit during the execution of a program.</li> </ul> <p>Usually, you don't want to write noise statements directly. Instead, use a NoisePass in order to inject noise statements automatically according to a specific noise model.</p> <p>Note</p> <p>Only the <code>qasm2.extended</code> dialect supports noise.</p> <p>For example, you may want to do something like this:</p> <pre><code>from bloqade import qasm2\nfrom bloqade.qasm2.passes import NoisePass\n\n@qasm2.extended\ndef main():\n    n = 2\n    q = qasm2.qreg(n)\n\n    for i in range(n):\n        qasm2.h(q[i])\n\n    qasm2.cx(q[0], q[1])\n    c = qasm2.creg(n)\n    qasm2.measure(q, c)\n    return c\n\n# Define the noise pass you want to use\nnoise_pass = NoisePass(main.dialects)  # just use the default noise model for now\n\n# Inject the noise - note that the main method will be updated in-place\nnoise_pass(main)\n\n# Look at the IR and all the glorious noise in there\nmain.print()\n</code></pre>"},{"location":"digital/dialects_and_kernels/squin/","title":"Structural Quantum Instructions dialect","text":"<p>This dialect constitutes the central domain-specific language used in bloqade-circuit. It allows you define your program in terms of gates applied to qubits, adding powerful control flow, such as <code>for</code> loops.</p>"},{"location":"digital/dialects_and_kernels/squin/#squin-overview","title":"Squin overview","text":"<p>The SQUIN DSL consists of three sub-groups of dialects:</p> <ul> <li><code>squin.qubit</code>, which can be used for manipulating qubits via gate applications and measurements.</li> <li><code>squin.gate</code>, which defines a set of gates that can be applied to qubits.</li> <li><code>squin.noise</code>, which defines noise channels applied to qubits.</li> </ul>"},{"location":"digital/dialects_and_kernels/squin/#standard-library-for-gate-applications","title":"Standard library for gate applications","text":"<p>Gates are exported using a standard library directly under the <code>squin</code> namespace. This allows you to write programs in a concise way. Here's a short example:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef main():\n    q = squin.qalloc(2)\n    squin.h(q[0])\n    squin.cx(q[0], q[1])\n    return squin.qubit.measure(q)\n\n# have a look at the IR\nmain.print()\n</code></pre> <p>The resulting IR looks like this:</p> <p></p> <p>As you can see, calls such as <code>squin.h(q[0])</code> are lowered as <code>func.invoke</code> statements, i.e. to function calls into the standard library of SQUIN.</p> <p>For a complete list of all available gates, please see the API reference.</p>"},{"location":"digital/dialects_and_kernels/squin/#using-control-flow","title":"Using control flow","text":"<p>One of the central aspects of SQUIN is that you are also able to use standard control flow such as for loops.</p> <p>For example, we can generalize the two-qubit GHZ kernel function from above to an arbitrary numbers of qubits:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef ghz(n: int):\n    q = squin.qalloc(n)\n\n    squin.h(q[0])\n    for i in range(n - 1):\n        squin.cx(q[i], q[i + 1])\n</code></pre> <p>Note that the fact that gate applications are represented by <code>func.invoke</code> also shows that it's possible to call user-defined kernel functions in SQUIN!</p> <p>For example, we could split the above program into two steps</p> <pre><code>from bloqade import squin\nfrom bloqade.types import Qubit\n\nfrom kirin.dialects import ilist\nfrom typing import Any\n\n@squin.kernel\ndef allocate_qubits_for_ghz(n: int) -&gt; ilist.IList[Qubit, Any]:\n    q = squin.qalloc(n)\n    squin.h(q[0])\n    return q\n\n@squin.kernel\ndef ghz_split(n: int):\n    q = allocate_qubits_for_ghz(n)\n    for i in range(n - 1):\n        squin.cx(q[i], q[i + 1])\n</code></pre>"},{"location":"digital/dialects_and_kernels/squin/#noise","title":"Noise","text":"<p>The squin dialect also includes noise, with a fixed set of noise channels defined. Just like gates, they are exported under the <code>squin</code> namespace.</p> <p>For example, we can use this to add noise into the simple kernel from before, which entangles two qubits:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef main_noisy():\n    q = squin.qalloc(2)\n\n    squin.h(q[0])\n    squin.depolarize(p=0.1, qubit=q[0])\n\n    squin.cx(q[0], q[1])\n    squin.depolarize2(0.05, q[0], q[1])\n\n    return squin.qubit.measure(q)\n\n# have a look at the IR\nmain_noisy.print()\n</code></pre> <p>The result looks like this:</p> <p></p> <p>Note, that you could equivalently write the depolarization error in the above as</p> <pre><code>dpl = squin.noise.depolarize(p=0.1)\nsquin.qubit.apply(dpl, q[0])\n</code></pre> <p>A full list of available noise channels can be found in the API reference.</p>"},{"location":"digital/dialects_and_kernels/squin/#parallelizing-gate-applications","title":"Parallelizing gate applications","text":"<p>There is also a standard library available for broadcasting gates, i.e. applying a gate to multiple qubits in parallel. For example, the following kernel functions apply the same operations to qubits:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef sequential():\n    q = squin.qalloc(2)\n    squin.h(q[0])\n    squin.h(q[1])\n\n\n@squin.kernel\ndef parallel():\n    q = squin.qalloc(2)\n    squin.broadcast.h(q)\n</code></pre> <p>Note that noise can also be parallelized, e.g. by calling <code>squin.broadcast.depolarize(0.1, q)</code>.</p> <p>See the API reference for broadcast for all the available functionality. Note that it will be precisely the same functions as for the standard gate application, but applied to lists of qubits rather than single ones.</p>"},{"location":"digital/dialects_and_kernels/squin/#see-also","title":"See also","text":"<ul> <li>Tutorial: Circuits with Bloqade</li> <li>SQUIN API reference</li> <li>Examples &amp; Tutorials</li> </ul>"},{"location":"digital/dialects_and_kernels/stim/","title":"Stim","text":"<p>Stim is a library for simulating and analyzing quantum stabilizer codes and quantum error correction circuits. The corresponding dialect allows you to write kernels that can then be emitted as native Stim code.</p> <p>Here is a short example:</p> <pre><code>from bloqade import stim\nfrom bloqade.stim.emit import EmitStimMain\n\n@stim.main\ndef main():\n    stim.x(targets=(0,2))\n    stim.cx(controls=(0,3), targets=(1,3))\n\nmain.print()\n\ntarget = EmitStimMain()\ntarget.run(main, args=())\nstim_program = target.get_output()\nprint(stim_program)\n</code></pre> <p>See also the stim API reference</p>"},{"location":"digital/examples/","title":"Tutorials on digital circuits","text":"<p>In this section you will find a number of tutorials and examples that show how you can use the digital bloqade subpackage, <code>bloqade-circuit</code>, in order to write quantum programs. The examples are split into sub-sections featuring the different dialects and submodules.</p>"},{"location":"digital/examples/#general-tutorials","title":"General tutorials","text":"<ul> <li> <p>Circuits with Bloqade</p> <p>Learn how to use <code>bloqade-circuit</code> to write your quantum programs.</p> </li> </ul>"},{"location":"digital/examples/#squin","title":"Squin","text":"<p>Squin is bloqade-circuits central dialect used to build circuits and run them on simulators and hardware.</p> <ul> <li> <p>Deutsch-Jozsa Algorithm</p> <p>See how you can implement the fundamental Deutsch-Jozsa algorithm with a Squin kernel function.</p> </li> <li> <p>GHZ state preparation and noise</p> <p>Inject noise manually in a simple squin kernel.</p> </li> </ul>"},{"location":"digital/examples/#interoperability-with-other-sdks","title":"Interoperability with other SDKs","text":"<p>While bloqade-circuit provides a number of different dialects (eDSLs), it may also be convenient to transpile circuits written using other SDKs.</p> <ul> <li> <p>Heuristic noise models applied to GHZ state preparation</p> <p>Learn how to apply our heuristic noise models built to work with the cirq SDK.</p> </li> </ul>"},{"location":"digital/examples/#qasm2","title":"QASM2","text":"<p>One of the most central languages used to define quantum programs is QASM2. You can also write your quantum programs using the QASM2 dialect directly in bloqade-circuit.</p> <p>Warning</p> <p>Some of the examples below use the <code>qasm2.extended</code> dialect, which adds more advanced language features, such as control flow. However, this dialect is deprecated and we recommend using <code>squin</code> instead.</p> <ul> <li> <p>Quantum Fourier Transform</p> <p>An example showing how to implement the well-known Quantum Fourier Transform (QFT).</p> </li> <li> <p>GHZ Preparation and Parallelism</p> <p>Learn how to use parallelism to reduce the circuit (execution) depth.</p> </li> <li> <p>Pauli Exponentiation for Quantum Simulation</p> <p>Simulating Hamiltonian dynamics by exponentiating Pauli operators.</p> </li> <li> <p>Repeat until success with STAR gadget</p> <p>Here's how to implement a Z phase gate with the repeat-until-success protocol.</p> </li> </ul>"},{"location":"digital/examples/interop/noisy_ghz/","title":"GHZ State preparation and noise","text":"In\u00a0[\u00a0]: Copied! <pre>import cirq\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom bloqade.cirq_utils import noise, transpile, load_circuit\n\n\ndef ghz_circuit(n: int) -&gt; cirq.Circuit:\n    qubits = cirq.LineQubit.range(n)\n\n    # Step 1: Hadamard on the first qubit\n    circuit = cirq.Circuit(cirq.H(qubits[0]))\n\n    # Step 2: CNOT chain from qubit i to i+1\n    for i in range(n - 1):\n        circuit.append(cirq.CNOT(qubits[i], qubits[i + 1]))\n\n    return circuit\n</pre> import cirq import numpy as np import matplotlib.pyplot as plt from bloqade.cirq_utils import noise, transpile, load_circuit   def ghz_circuit(n: int) -&gt; cirq.Circuit:     qubits = cirq.LineQubit.range(n)      # Step 1: Hadamard on the first qubit     circuit = cirq.Circuit(cirq.H(qubits[0]))      # Step 2: CNOT chain from qubit i to i+1     for i in range(n - 1):         circuit.append(cirq.CNOT(qubits[i], qubits[i + 1]))      return circuit <p>Here's what this circuit looks like for <code>n=3</code> qubits:</p> In\u00a0[\u00a0]: Copied! <pre>ghz_circuit_3 = ghz_circuit(3)\nprint(ghz_circuit_3)\n</pre> ghz_circuit_3 = ghz_circuit(3) print(ghz_circuit_3) <p>So far so good. Now, we will convert the circuit above to a noisy one using bloqade's <code>cirq_utils</code> submodule.</p> <p>Specifically, we can use the <code>noise.transform_circuit</code> utility function with a noise model of our choice.</p> In\u00a0[\u00a0]: Copied! <pre>noise_model = noise.GeminiOneZoneNoiseModel()\nnoisy_ghz_circuit_3 = noise.transform_circuit(ghz_circuit_3, model=noise_model)\nprint(noisy_ghz_circuit_3)\n</pre> noise_model = noise.GeminiOneZoneNoiseModel() noisy_ghz_circuit_3 = noise.transform_circuit(ghz_circuit_3, model=noise_model) print(noisy_ghz_circuit_3) <p>As you can see, we have successfully added noise. However, the circuit also looks very different in terms of its gates.</p> <p>This is because <code>noise.transform_circuit</code> does actually two things:</p> <ol> <li>Since we want to consider a circuit that is compatible with the Gemini architecture, we need to transform it to the native gate set first. This set consists of (phased) X gates and CZ gates only.</li> <li>Once we have a native circuit, noise is injected according to the chosen noise model.</li> </ol> <p>To clarify, here is how you would convert the circuit without using the <code>noise.transform_circuit</code> utility function:</p> In\u00a0[\u00a0]: Copied! <pre>native_ghz_3 = transpile(ghz_circuit_3)\nprint(native_ghz_3)\n</pre> native_ghz_3 = transpile(ghz_circuit_3) print(native_ghz_3) <p>Note that <code>transpile</code> basically just wraps cirq's own <code>cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())</code>, with some additional benefits (such as filtering out empty moments).</p> <p>Using this native circuit, we can obtain the same noisy circuit as before by simply using cirq's <code>cirq.Circuit.with_noise</code> method.</p> In\u00a0[\u00a0]: Copied! <pre>noisy_ghz_circuit_3 = native_ghz_3.with_noise(noise_model)\nprint(noisy_ghz_circuit_3)\n</pre> noisy_ghz_circuit_3 = native_ghz_3.with_noise(noise_model) print(noisy_ghz_circuit_3) <p>Fidelity calculation</p> <p>     In the following, we will simply use the expectation value of the noisy density matrix computed against the noiseless one as a proxy for fidelity.     This is a suboptimal choice, but we wanted to keep the example simple.     Feel free to substitute the fidelity calculation by the fidelity of your choice (e.g. the Uhlmann fidelity) </p> In\u00a0[\u00a0]: Copied! <pre>qubits = range(3, 9)\n\none_zone_model = noise.GeminiOneZoneNoiseModel()\ntwo_zone_model = noise.GeminiTwoZoneNoiseModel()\nsimulator = cirq.DensityMatrixSimulator()\n\nfidelities_one_zone = []\nfidelities_two_zone = []\nfor n in qubits:\n    circuit = ghz_circuit(n)\n    one_zone_circuit = noise.transform_circuit(circuit, model=one_zone_model)\n    two_zone_circuit = noise.transform_circuit(circuit, model=two_zone_model)\n\n    rho = simulator.simulate(circuit).final_density_matrix\n    rho_one_zone = simulator.simulate(one_zone_circuit).final_density_matrix\n    rho_two_zone = simulator.simulate(two_zone_circuit).final_density_matrix\n\n    fidelity_one_zone = np.trace(rho @ rho_one_zone)\n    fidelity_two_zone = np.trace(rho @ rho_two_zone)\n\n    fidelities_one_zone.append(fidelity_one_zone)\n    fidelities_two_zone.append(fidelity_two_zone)\n</pre> qubits = range(3, 9)  one_zone_model = noise.GeminiOneZoneNoiseModel() two_zone_model = noise.GeminiTwoZoneNoiseModel() simulator = cirq.DensityMatrixSimulator()  fidelities_one_zone = [] fidelities_two_zone = [] for n in qubits:     circuit = ghz_circuit(n)     one_zone_circuit = noise.transform_circuit(circuit, model=one_zone_model)     two_zone_circuit = noise.transform_circuit(circuit, model=two_zone_model)      rho = simulator.simulate(circuit).final_density_matrix     rho_one_zone = simulator.simulate(one_zone_circuit).final_density_matrix     rho_two_zone = simulator.simulate(two_zone_circuit).final_density_matrix      fidelity_one_zone = np.trace(rho @ rho_one_zone)     fidelity_two_zone = np.trace(rho @ rho_two_zone)      fidelities_one_zone.append(fidelity_one_zone)     fidelities_two_zone.append(fidelity_two_zone) <p>Now, let's have a look at the results.</p> In\u00a0[\u00a0]: Copied! <pre>plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\")\nplt.plot(qubits, fidelities_two_zone, \"x\", label=\"two-zone model\")\nplt.xlabel(\"Number of qubits\")\nplt.ylabel(\"Fidelity\")\nplt.legend()\n</pre> plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\") plt.plot(qubits, fidelities_two_zone, \"x\", label=\"two-zone model\") plt.xlabel(\"Number of qubits\") plt.ylabel(\"Fidelity\") plt.legend() <p>We can see that in both cases the fidelity goes down when increasing the number of qubits.</p> <p>Interestingly, there is a cross-over point where the two-zone model starts to exhibit a better fidelity. This is because as the number of qubits grows, the error introduced on idle qubits inside the gate zone is larger in the one-zone model since all qubits are always inside the gate zone. Whereas, in the two-zone model, qubits are moved between the gate and storage zones.</p> <p>You could now think about how to optimize the circuits in order to reduce their sensitivity to noise. For example, you can reduce the circuit depth</p> In\u00a0[\u00a0]: Copied! <pre>default_model = noise.GeminiTwoZoneNoiseModel()\npx, py, pz = default_model.mover_px, default_model.mover_py, default_model.mover_pz\nprint(\n    f\"The noise Pauli channel associated with moving atoms is (px, py, pz) = ({px,py,pz}).\"\n)\n</pre> default_model = noise.GeminiTwoZoneNoiseModel() px, py, pz = default_model.mover_px, default_model.mover_py, default_model.mover_pz print(     f\"The noise Pauli channel associated with moving atoms is (px, py, pz) = ({px,py,pz}).\" ) <p>Then we can instantiate a noise model with modified parameters:</p> In\u00a0[\u00a0]: Copied! <pre>modified_two_zone_model = noise.GeminiTwoZoneNoiseModel(\n    mover_px=2e-3,\n    mover_py=2e-3,\n    mover_pz=3e-3,\n)\nfidelities_modified_two_zone = []\nfor n in qubits:\n    circuit = ghz_circuit(n)\n    noisy_circuit = noise.transform_circuit(circuit, model=modified_two_zone_model)\n    rho = simulator.simulate(circuit).final_density_matrix\n    rho_noisy = simulator.simulate(noisy_circuit).final_density_matrix\n    fidelities_modified_two_zone.append(np.trace(rho @ rho_noisy))\n</pre> modified_two_zone_model = noise.GeminiTwoZoneNoiseModel(     mover_px=2e-3,     mover_py=2e-3,     mover_pz=3e-3, ) fidelities_modified_two_zone = [] for n in qubits:     circuit = ghz_circuit(n)     noisy_circuit = noise.transform_circuit(circuit, model=modified_two_zone_model)     rho = simulator.simulate(circuit).final_density_matrix     rho_noisy = simulator.simulate(noisy_circuit).final_density_matrix     fidelities_modified_two_zone.append(np.trace(rho @ rho_noisy)) In\u00a0[\u00a0]: Copied! <pre>plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\")\nplt.plot(qubits, fidelities_modified_two_zone, \"x\", label=\"modified two-zone model\")\nplt.xlabel(\"Number of qubits\")\nplt.ylabel(\"Fidelity\")\nplt.legend()\n</pre> plt.plot(qubits, fidelities_one_zone, \"o\", label=\"one-zone model\") plt.plot(qubits, fidelities_modified_two_zone, \"x\", label=\"modified two-zone model\") plt.xlabel(\"Number of qubits\") plt.ylabel(\"Fidelity\") plt.legend() <p>As you can see, the fidelities no longer cross over since the increased movement noise now eliminates the advantage of the two-zone model for the considered numbers of qubits.</p> In\u00a0[\u00a0]: Copied! <pre>circuit = ghz_circuit(5)\nnoisy_circuit = noise.transform_circuit(circuit, model=noise.GeminiOneZoneNoiseModel())\n</pre> circuit = ghz_circuit(5) noisy_circuit = noise.transform_circuit(circuit, model=noise.GeminiOneZoneNoiseModel()) In\u00a0[\u00a0]: Copied! <pre>kernel = load_circuit(circuit, kernel_name=\"kernel\")\nnoisy_kernel = load_circuit(noisy_circuit, kernel_name=\"noisy_kernel\")\nkernel.print()\n</pre> kernel = load_circuit(circuit, kernel_name=\"kernel\") noisy_kernel = load_circuit(noisy_circuit, kernel_name=\"noisy_kernel\") kernel.print()"},{"location":"digital/examples/interop/noisy_ghz/#ghz-state-preparation-and-noise","title":"GHZ State preparation and noise\u00b6","text":"<p>In this example, we will illustrate how to work with <code>bloqade</code>'s heuristic noise models of Gemini class digital quantum processors by applying them to a circuit that prepares a GHZ state.</p>"},{"location":"digital/examples/interop/noisy_ghz/#primer-on-gemini-noise-models","title":"Primer on Gemini noise models\u00b6","text":"<p>In <code>bloqade</code>, there are two classes of heuristic noise models: one-zone models such as <code>GeminiOneZoneNoiseModel</code> and a two-zone model <code>GeminiTwoZoneNoiseModel</code>. These are inspired by two distinct approaches to implement a quantum circuit on hardware and are designed to get a sense of the influence of noise on Gemini class hardware.</p> <p>On the one hand, the one-zone model assumes a single-zone layout where qubits remain in the gate zone throughout the computation. On the other hand, the two-zone model incorporates a storage zone and assumes that qubits are transported between gate and storage regions.</p> <p>Both models are informed by benchmark data on the device but are intentionally conservative. Specifically, they tend to overestimate noise due to the lack of knowledge about optimized move schedules, which leads to overestimating move-induced errors.</p> <p>At this stage, we recommend interpreting the two models as providing a range for expected noise levels on Gemini-class devices, rather than precise predictions. They are useful for gaining intuition about noise sensitivity and for benchmarking algorithmic robustness to errors, using hardware-informed but simplistic assumptions.</p> <p>Note that there are actually two additional one-zone noise models, <code>GeminiOneZoneNoiseModelCorrelated</code> and <code>GeminiOneZoneNoiseModelConflictGraphMoves</code>. As the names suggest, the former also takes into account correlated noise, whereas the latter takes into account more realistic move schedules. In the following example, we will not be considering these two, but they are interchangeable with the used noise models (up to the fact, that the conflict graph moves require you to specify qubits as <code>cirq.GridQubit</code>s).</p>"},{"location":"digital/examples/interop/noisy_ghz/#noise-model-implementations","title":"Noise model implementations\u00b6","text":"<p>For now, these noise models are implemented as <code>cirq.NoiseModel</code> classes, so that you can use with any circuit you build using <code>cirq</code>. They are part of the <code>bloqade.cirq_utils</code> submodule.</p> <p>Support for using these models with e.g. squin will follow in the future. However, you can already rely on interoperability with cirq in order to convert (noisy) circuits to squin kernels and use other parts of the compiler pipeline.</p>"},{"location":"digital/examples/interop/noisy_ghz/#ghz-preparation-and-noise","title":"GHZ preparation and noise\u00b6","text":"<p>Now, let's get started with the actual example.</p> <p>As a first step, we will define a function that builds a GHZ circuit in cirq that has a depth linear in the number of qubits.</p>"},{"location":"digital/examples/interop/noisy_ghz/#closer-look-at-a-basic-circuit","title":"Closer look at a basic circuit\u00b6","text":""},{"location":"digital/examples/interop/noisy_ghz/#studying-the-fidelity","title":"Studying the fidelity\u00b6","text":"<p>Now that we have got the basics down, we can compute the fidelity of noisy circuits with different qubit numbers. By fidelity, we simply mean the overlap of the final state with the perfect GHZ state expected from the noise-less version of the circuit.</p> <p>The corresponding density matrices are obtained using <code>cirq</code>'s simulator.</p> <p>We will do the simulation using two different noise models, the one-zone model used above and also the two-zone model.</p>"},{"location":"digital/examples/interop/noisy_ghz/#modifying-the-noise","title":"Modifying the noise\u00b6","text":"<p>There are a number of parameters that govern the effect a noise model introduces into a circuit. These can all be set independently to adapt the noise model to your specific application.</p> <p>In general, there are noise parameters for the following noise processes:</p> <ul> <li>Depolarization due to gate application.</li> <li>Depolarization due to movement, both applied to moving atoms and idle atoms (a.k.a. sitter errors).</li> <li>Atom loss errors.</li> </ul> <p>Atom loss</p> <p>     Please note that atom loss is currently not supported, i.e. it's not considered in the noise models.     We plan to add that in the future. </p> <p>The noise processes are further split into local and global noise channels and separated by their cause.</p> <p>For a full list of noise parameters and a description of each one, please refer to the move noise model in <code>bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC</code></p> <p>We can use those parameters in order to modify the strength of the noise.</p> <p>For example, say you want to introduce an extra penalty for moving qubits around in order to study how you can reduce movements. To do so, let's re-use the fidelity calculation using the two-zone model from above, but modify movement errors. We can query the default move errors from the <code>cirq</code> noise model:</p>"},{"location":"digital/examples/interop/noisy_ghz/#interoperability-with-squin","title":"Interoperability with squin\u00b6","text":"<p>Finally, we want to point out that you can also use the generated noisy circuits to obtain a squin kernel function.</p> <p>This is useful if you want to use other features of the bloqade pipeline. For example, it would allow you to run the <code>pyqrack</code> simulator instead of <code>cirq</code>'s own, which can be more efficient.</p>"},{"location":"digital/examples/qasm2/ghz/","title":"GHZ State Preparation with Parallelism","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom kirin.dialects import ilist\n\nfrom bloqade import qasm2\n</pre> import math  from kirin.dialects import ilist  from bloqade import qasm2 In\u00a0[\u00a0]: Copied! <pre>def ghz_linear(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def ghz_linear_program():\n\n        qreg = qasm2.qreg(n_qubits)\n        # Apply a Hadamard on the first qubit\n        qasm2.h(qreg[0])\n        # Create a cascading sequence of CX gates\n        # necessary for quantum computers that\n        # only have nearest-neighbor connectivity between qubits\n        for i in range(1, n_qubits):\n            qasm2.cx(qreg[i - 1], qreg[i])\n\n    return ghz_linear_program\n</pre> def ghz_linear(n: int):     n_qubits = int(2**n)      @qasm2.extended     def ghz_linear_program():          qreg = qasm2.qreg(n_qubits)         # Apply a Hadamard on the first qubit         qasm2.h(qreg[0])         # Create a cascading sequence of CX gates         # necessary for quantum computers that         # only have nearest-neighbor connectivity between qubits         for i in range(1, n_qubits):             qasm2.cx(qreg[i - 1], qreg[i])      return ghz_linear_program <p>Circuit vs. Execution Depth</p> <p> Before going any further, it's worth distinguishing between the concept of circuit depth and circuit execution depth. For example, in the following implementation, each CX gate instruction inside the for-loop is executed in sequence. So even though the circuit depth is $log(N) = n$, the circuit execution depth is still $N$. </p> In\u00a0[\u00a0]: Copied! <pre>def ghz_log_depth(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer_of_cx(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n        for j in range(0, n_qubits, step):\n            qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer_of_cx(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_depth(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer_of_cx(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)         for j in range(0, n_qubits, step):             qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer_of_cx(i_layer=i, qreg=qreg)      return ghz_log_depth_program In\u00a0[\u00a0]: Copied! <pre>def ghz_log_simd(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n\n        def get_qubit(x: int):\n            return qreg[x]\n\n        ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))\n        targ_qubits = ilist.Map(\n            fn=get_qubit, collection=range(step // 2, n_qubits, step)\n        )\n\n        # Ry(-pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)\n\n        # CZ gates\n        qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)\n\n        # Ry(pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_simd(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)          def get_qubit(x: int):             return qreg[x]          ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))         targ_qubits = ilist.Map(             fn=get_qubit, collection=range(step // 2, n_qubits, step)         )          # Ry(-pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)          # CZ gates         qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)          # Ry(pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer(i_layer=i, qreg=qreg)      return ghz_log_depth_program <p>Using Closures to Capture Global Variables</p> <p> While bloqade.qasm2 permits a main program with arguments, standard QASM2 does not. To get around this, we need to put the program in a closure. Our Kirin compiler toolchain can capture the global variable inside the closure. In this case, the n_qubits will be captured upon calling the ghz_log_simd(n_qubits) python function. As a result, the returned QASM2 program will not have any arguments. </p> In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2(\n    allow_parallel=True,\n)\nast = target.emit(ghz_log_simd(4))\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2(     allow_parallel=True, ) ast = target.emit(ghz_log_simd(4)) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qasm2/ghz/#ghz-state-preparation-with-parallelism","title":"GHZ State Preparation with Parallelism\u00b6","text":"<p>In this example, we will implement a Greenberger-Horne-Zeilinger (GHZ) state preparation circuit with $N = 2^n$ qubits.</p> <p>First, we will present the standard linear-depth construction in Bloqade but later we will present a log-depth construction that achieves the same result. We then take this one step further and use the fact that Bloqade (and QuEra's neutral atom hardware!) support parallel gates, allowing for the application of the same gate across multiple qubits simultaneously. Combined with the fact that atom shuttling allows for arbitrary connectivity, we can also decrease the circuit execution depth from $N$ to just $n$.</p>"},{"location":"digital/examples/qasm2/ghz/#simple-linear-depth-implementation-of-a-ghz-state-preparation-circuit","title":"Simple Linear Depth Implementation of a GHZ State Preparation Circuit\u00b6","text":"<p>A simple GHZ state preparation circuit can be built with $N - 1$ CX gates and $1$ H gate. This gives the circuit an execution depth of $N$.</p>"},{"location":"digital/examples/qasm2/ghz/#log-depth-implementation-of-a-ghz-state-preparation-circuit","title":"Log-depth Implementation of a GHZ State Preparation Circuit\u00b6","text":"<p>Let's take a look how we can rewrite the circuit to take advantage of QuEra's hardware capabilities. We can achieve log(N) circuit depth by rearranging the CX gates (see Mooney, White, Hill, Hollenberg - 2021).</p>"},{"location":"digital/examples/qasm2/ghz/#our-native-gate-set-and-parallelism","title":"Our Native Gate Set and Parallelism\u00b6","text":"<p>By nature, our digital quantum computer can execute native gates in parallel in an single instruction/ execution cycle. The concept is very similar to the SIMD (Single Instruction, Multiple Data) in classical computing.</p> <p>On our hardware, there are two important factors to be considered:</p> <ol> <li>the native gate set allows for arbitrary (parallel) rotations and (parallel) CZ gates.</li> <li>Our atom shuttling architecture allows arbitrary qubit connectivity. This means that our parallel instruction is not limited to fixed connectivity (for example nearest neighbor connectivity).</li> </ol> <p>With this in mind, we can rewrite the <code>layer</code> subroutine to now use the <code>qasm2.parallel</code> dialect in Bloqade. We know that the CX gate can be decomposed into a CZ gate with two single-qubit gates $R_y(-\\pi/2)$ and $R_y(\\pi/2)$ acting on the target qubits. With this decomposition in mind, we can now using our parallel gate instructions <code>parallel.u</code> and <code>parallel.cz</code>. With the following modification, we can further reduce the circuit execution depth to just $n$ (log of the total number of qubits $N$)</p>"},{"location":"digital/examples/qasm2/pauli_exponentiation/","title":"Pauli Exponentiation for Quantum Simulation","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade import qasm2\n</pre> import math  from bloqade import qasm2 <p>First, we define the <code>zzzz_gadget</code> function which is a simple implementation of Pauli Z exponentiation with a parameterized angle <code>gamma</code>.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef zzzz_gadget(targets: tuple[qasm2.Qubit, ...], gamma: float):\n    for i in range(len(targets) - 1):\n        qasm2.cx(targets[i], targets[i + 1])\n\n    qasm2.rz(targets[-1], gamma)\n\n    for j in range(len(targets) - 1):\n        qasm2.cx(targets[-j - 1], targets[-j - 2])\n</pre> @qasm2.extended def zzzz_gadget(targets: tuple[qasm2.Qubit, ...], gamma: float):     for i in range(len(targets) - 1):         qasm2.cx(targets[i], targets[i + 1])      qasm2.rz(targets[-1], gamma)      for j in range(len(targets) - 1):         qasm2.cx(targets[-j - 1], targets[-j - 2]) <p>Next, we define the <code>pauli_basis_change</code> function which is a simple implementation of Pauli basis change with a parameterized start and end Pauli basis.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef pauli_basis_change(targets: tuple[qasm2.Qubit, ...], start: str, end: str):\n    # assert len(targets) == len(start)\n    # assert len(targets) == len(end)\n\n    # for qubit, start_pauli, end_pauli in zip(targets, start, end):\n    for i in range(len(targets)):\n        qubit = targets[i]\n        start_pauli = start[i]\n        end_pauli = end[i]\n\n        target = start_pauli + end_pauli\n        if target == \"ZX\":\n            qasm2.ry(qubit, math.pi / 2)\n        elif target == \"ZY\":\n            qasm2.rx(qubit, -math.pi / 2)\n        # elif target == \"ZZ\":\n        #     pass\n        # elif target == \"XX\":\n        #     pass\n        elif target == \"XY\":\n            qasm2.rz(qubit, math.pi / 2)\n        elif target == \"XZ\":\n            qasm2.ry(qubit, -math.pi / 2)\n        elif target == \"YX\":\n            qasm2.rz(qubit, -math.pi / 2)\n        # elif target == \"YY\":\n        #     pass\n        elif target == \"YZ\":\n            qasm2.rx(qubit, math.pi / 2)\n</pre> @qasm2.extended def pauli_basis_change(targets: tuple[qasm2.Qubit, ...], start: str, end: str):     # assert len(targets) == len(start)     # assert len(targets) == len(end)      # for qubit, start_pauli, end_pauli in zip(targets, start, end):     for i in range(len(targets)):         qubit = targets[i]         start_pauli = start[i]         end_pauli = end[i]          target = start_pauli + end_pauli         if target == \"ZX\":             qasm2.ry(qubit, math.pi / 2)         elif target == \"ZY\":             qasm2.rx(qubit, -math.pi / 2)         # elif target == \"ZZ\":         #     pass         # elif target == \"XX\":         #     pass         elif target == \"XY\":             qasm2.rz(qubit, math.pi / 2)         elif target == \"XZ\":             qasm2.ry(qubit, -math.pi / 2)         elif target == \"YX\":             qasm2.rz(qubit, -math.pi / 2)         # elif target == \"YY\":         #     pass         elif target == \"YZ\":             qasm2.rx(qubit, math.pi / 2) <p>Putting it all together, we define the <code>pauli_exponential</code> function which is a simple implementation of Pauli Exponentiation with a parameterized Pauli basis and angle <code>gamma</code>.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef pauli_exponential(targets: tuple[qasm2.Qubit, ...], pauli: str, gamma: float):\n    # assert len(targets) == len(pauli)\n\n    pauli_basis_change(targets=targets, start=\"Z\" * len(targets), end=pauli)\n    zzzz_gadget(targets=targets, gamma=gamma)\n    pauli_basis_change(targets=targets, start=pauli, end=\"Z\" * len(targets))\n</pre> @qasm2.extended def pauli_exponential(targets: tuple[qasm2.Qubit, ...], pauli: str, gamma: float):     # assert len(targets) == len(pauli)      pauli_basis_change(targets=targets, start=\"Z\" * len(targets), end=pauli)     zzzz_gadget(targets=targets, gamma=gamma)     pauli_basis_change(targets=targets, start=pauli, end=\"Z\" * len(targets)) <p>Finally, we define the <code>main</code> function as the entry point of the program.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    register = qasm2.qreg(4)\n    pauli_exponential((register[0], register[1], register[2]), \"ZXY\", 0.5)\n</pre> @qasm2.extended def main():     register = qasm2.qreg(4)     pauli_exponential((register[0], register[1], register[2]), \"ZXY\", 0.5) <p>we can now ask the compiler to emit the QASM2 code for the <code>main</code> function.</p> In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2()\nast = target.emit(main)\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2() ast = target.emit(main) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qasm2/pauli_exponentiation/#pauli-exponentiation-for-quantum-simulation","title":"Pauli Exponentiation for Quantum Simulation\u00b6","text":"<p>In this example, we will consider a simple Pauli Exponentiation circuit.</p>"},{"location":"digital/examples/qasm2/qaoa/","title":"QAOA","text":"<p>Lets do a simple example of a prototype circuit that benefits from parallelism: QAOA solving the MaxCut problem. For more details, see arXiv:1411.4028 and the considerable literature that has developed around this algorithm.</p> In\u00a0[\u00a0]: Copied! <pre>import math\nfrom typing import Any\n\nimport kirin\nimport networkx as nx\nfrom kirin.dialects import ilist\n\nfrom bloqade import qasm2\n\npi = math.pi\n</pre> import math from typing import Any  import kirin import networkx as nx from kirin.dialects import ilist  from bloqade import qasm2  pi = math.pi <p>MaxCut is a combinatorial graph problem that seeks to bi-partition the nodes of some graph G such that the number of edges between the two partitions is maximized. Here, we choose a random 3 regular graph with 32 nodes ref</p> In\u00a0[\u00a0]: Copied! <pre>N = 32\nG = nx.random_regular_graph(3, N, seed=42)\n</pre> N = 32 G = nx.random_regular_graph(3, N, seed=42) <p>To build the quantum program, we use a builder function and use closure to pass variables inside of the kernel function (kirin methods). In this case, the two variables that are passed inside are the edges and nodes of the graph.</p> <p>The QAOA first prepares the |+&gt; state as a superposition of all possible bitstrings, then repeats between the (diagonal) cost function and the mixer X with angles gamma and beta. It is parameterized by gamma and betas, which are each the p length lists of angles.</p> <p>Lets first implement the sequential version of the QAOA algorithm, which does not inform any parallelism to the compiler.</p> In\u00a0[\u00a0]: Copied! <pre>def qaoa_sequential(G: nx.Graph) -&gt; kirin.ir.Method:\n\n    edges = list(G.edges)\n    nodes = list(G.nodes)\n    N = len(nodes)\n\n    @qasm2.extended\n    def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):\n        # Initialize the register in the |+&gt; state\n        q = qasm2.qreg(N)\n        for i in range(N):  # structural control flow is native to the Kirin compiler\n            qasm2.h(q[i])\n\n        # Repeat the cost and mixer layers\n        for i in range(len(gamma)):\n            # The cost layer, which corresponds to a ZZ(phase) gate applied\n            # to each edge of the graph\n            for j in range(len(edges)):\n                edge = edges[j]\n                qasm2.cx(q[edge[0]], q[edge[1]])\n                qasm2.rz(q[edge[1]], gamma[i])\n                qasm2.cx(q[edge[0]], q[edge[1]])\n            # The mixer layer, which corresponds to a X(phase) gate applied\n            # to each node of the graph\n            for j in range(N):\n                qasm2.rx(q[j], beta[i])\n\n        return q\n\n    return kernel\n</pre> def qaoa_sequential(G: nx.Graph) -&gt; kirin.ir.Method:      edges = list(G.edges)     nodes = list(G.nodes)     N = len(nodes)      @qasm2.extended     def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):         # Initialize the register in the |+&gt; state         q = qasm2.qreg(N)         for i in range(N):  # structural control flow is native to the Kirin compiler             qasm2.h(q[i])          # Repeat the cost and mixer layers         for i in range(len(gamma)):             # The cost layer, which corresponds to a ZZ(phase) gate applied             # to each edge of the graph             for j in range(len(edges)):                 edge = edges[j]                 qasm2.cx(q[edge[0]], q[edge[1]])                 qasm2.rz(q[edge[1]], gamma[i])                 qasm2.cx(q[edge[0]], q[edge[1]])             # The mixer layer, which corresponds to a X(phase) gate applied             # to each node of the graph             for j in range(N):                 qasm2.rx(q[j], beta[i])          return q      return kernel <p>Next, lets implement a SIMD (Single Instruction, Multiple Data) version of the QAOA algorithm, which effectively represents the parallelism in the QAOA algorithm. This can be done by coloring the (commuting) ZZ(phase) gates into groups with non-overlapping sets of qubits, and then applying each of those groups in parallel. By Vizing's theorem the edges of a graph can efficiently be colored into $\\Delta+1$ colors, where $\\Delta$ is the maximum degree of the graph. Unfortunately, networkx does not have a native implementation of the algorithm so instead we use the lesser [Brooks' theorem]https://en.wikipedia.org/wiki/Brooks%27_theorem) to color the edges using an equitable coloring of the line graph.</p> In\u00a0[\u00a0]: Copied! <pre>def qaoa_simd(G: nx.Graph) -&gt; kirin.ir.Method:\n\n    nodes = list(G.nodes)\n\n    # Note that graph computation is happening /outside/ the kernel function:\n    # this is a computation that occurs on your laptop in Python when you generate\n    # a program, as opposed to on a piece of quantum hardware, which is what\n    # occurs inside of the kernel.\n    Gline = nx.line_graph(G)\n    colors = nx.algorithms.coloring.equitable_color(Gline, num_colors=5)\n    left_ids = ilist.IList(\n        [\n            ilist.IList([edge[0] for edge in G.edges if colors[edge] == i])\n            for i in range(5)\n        ]\n    )\n    right_ids = ilist.IList(\n        [\n            ilist.IList([edge[1] for edge in G.edges if colors[edge] == i])\n            for i in range(5)\n        ]\n    )\n    # We can use composition of kernel functions to simplify repeated code.\n    # Small snippets (say, the CX gate) can be written once and then called\n    # many times.\n\n    @qasm2.extended\n    def parallel_h(qargs: ilist.IList[qasm2.Qubit, Any]):\n        qasm2.parallel.u(qargs=qargs, theta=pi / 2, phi=0.0, lam=pi)\n\n    # A parallel CX gate is equivalently a parallel H gate, followed by a parallel CZ gate,\n    # followed by another parallel H. the CZ can be done in any order as they permute.\n    @qasm2.extended\n    def parallel_cx(\n        ctrls: ilist.IList[qasm2.Qubit, Any], qargs: ilist.IList[qasm2.Qubit, Any]\n    ):\n        parallel_h(qargs)\n        qasm2.parallel.cz(ctrls, qargs)\n        parallel_h(qargs)\n\n    @qasm2.extended\n    def parallel_cz_phase(\n        ctrls: ilist.IList[qasm2.Qubit, Any],\n        qargs: ilist.IList[qasm2.Qubit, Any],\n        gamma: float,\n    ):\n        parallel_cx(ctrls, qargs)\n        qasm2.parallel.rz(qargs, gamma)\n        parallel_cx(ctrls, qargs)\n\n    @qasm2.extended\n    def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):\n        # Declare the register and set it to the |+&gt; state\n        q = qasm2.qreg(len(nodes))\n        # qasm2.glob.u(theta=pi / 2, phi=0.0, lam=pi,registers=[q])\n\n        def get_qubit(x: int):\n            return q[x]\n\n        all_qubits = ilist.map(fn=get_qubit, collection=range(N))\n\n        parallel_h(all_qubits)\n\n        for i in range(len(gamma)):  # For each QAOA layer...\n            # Do the ZZ phase gates...\n            for cind in range(\n                5\n            ):  # by applying a parallel CZ phase gate in parallel for each color,\n                ctrls = ilist.map(fn=get_qubit, collection=left_ids[cind])\n                qargs = ilist.map(fn=get_qubit, collection=right_ids[cind])\n                parallel_cz_phase(ctrls, qargs, gamma[i])\n            # ...then, do an X phase gate. Observe that because this happens on every\n            # qubit, we can do a global rotation, which is higher fidelity than\n            # parallel local rotations.\n            # qasm2.glob.u(theta=beta[i],phi=0.0,lam=0.0,registers=[q])\n            qasm2.parallel.u(qargs=all_qubits, theta=beta[i], phi=0.0, lam=0.0)\n\n        return q\n\n    return kernel\n</pre> def qaoa_simd(G: nx.Graph) -&gt; kirin.ir.Method:      nodes = list(G.nodes)      # Note that graph computation is happening /outside/ the kernel function:     # this is a computation that occurs on your laptop in Python when you generate     # a program, as opposed to on a piece of quantum hardware, which is what     # occurs inside of the kernel.     Gline = nx.line_graph(G)     colors = nx.algorithms.coloring.equitable_color(Gline, num_colors=5)     left_ids = ilist.IList(         [             ilist.IList([edge[0] for edge in G.edges if colors[edge] == i])             for i in range(5)         ]     )     right_ids = ilist.IList(         [             ilist.IList([edge[1] for edge in G.edges if colors[edge] == i])             for i in range(5)         ]     )     # We can use composition of kernel functions to simplify repeated code.     # Small snippets (say, the CX gate) can be written once and then called     # many times.      @qasm2.extended     def parallel_h(qargs: ilist.IList[qasm2.Qubit, Any]):         qasm2.parallel.u(qargs=qargs, theta=pi / 2, phi=0.0, lam=pi)      # A parallel CX gate is equivalently a parallel H gate, followed by a parallel CZ gate,     # followed by another parallel H. the CZ can be done in any order as they permute.     @qasm2.extended     def parallel_cx(         ctrls: ilist.IList[qasm2.Qubit, Any], qargs: ilist.IList[qasm2.Qubit, Any]     ):         parallel_h(qargs)         qasm2.parallel.cz(ctrls, qargs)         parallel_h(qargs)      @qasm2.extended     def parallel_cz_phase(         ctrls: ilist.IList[qasm2.Qubit, Any],         qargs: ilist.IList[qasm2.Qubit, Any],         gamma: float,     ):         parallel_cx(ctrls, qargs)         qasm2.parallel.rz(qargs, gamma)         parallel_cx(ctrls, qargs)      @qasm2.extended     def kernel(gamma: ilist.IList[float, Any], beta: ilist.IList[float, Any]):         # Declare the register and set it to the |+&gt; state         q = qasm2.qreg(len(nodes))         # qasm2.glob.u(theta=pi / 2, phi=0.0, lam=pi,registers=[q])          def get_qubit(x: int):             return q[x]          all_qubits = ilist.map(fn=get_qubit, collection=range(N))          parallel_h(all_qubits)          for i in range(len(gamma)):  # For each QAOA layer...             # Do the ZZ phase gates...             for cind in range(                 5             ):  # by applying a parallel CZ phase gate in parallel for each color,                 ctrls = ilist.map(fn=get_qubit, collection=left_ids[cind])                 qargs = ilist.map(fn=get_qubit, collection=right_ids[cind])                 parallel_cz_phase(ctrls, qargs, gamma[i])             # ...then, do an X phase gate. Observe that because this happens on every             # qubit, we can do a global rotation, which is higher fidelity than             # parallel local rotations.             # qasm2.glob.u(theta=beta[i],phi=0.0,lam=0.0,registers=[q])             qasm2.parallel.u(qargs=all_qubits, theta=beta[i], phi=0.0, lam=0.0)          return q      return kernel In\u00a0[\u00a0]: Copied! <pre>print(\"--- Sequential ---\")\nqaoa_sequential(G).code.print()\n</pre> print(\"--- Sequential ---\") qaoa_sequential(G).code.print() In\u00a0[\u00a0]: Copied! <pre>kernel = qaoa_simd(G)\n\nprint(\"\\n\\n--- Simd ---\")\nkernel.print()\n</pre> kernel = qaoa_simd(G)  print(\"\\n\\n--- Simd ---\") kernel.print() In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    kernel([0.1, 0.2], [0.3, 0.4])\n</pre> @qasm2.extended def main():     kernel([0.1, 0.2], [0.3, 0.4]) In\u00a0[\u00a0]: Copied! <pre>target = qasm2.emit.QASM2()\nast = target.emit(main)\nqasm2.parse.pprint(ast)\n</pre> target = qasm2.emit.QASM2() ast = target.emit(main) qasm2.parse.pprint(ast)"},{"location":"digital/examples/qasm2/qft/","title":"Quantum Fourier Transform","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade.pyqrack import StackMemorySimulator\n\nfrom bloqade import qasm2\n</pre> import math  from bloqade.pyqrack import StackMemorySimulator  from bloqade import qasm2 <p>In the following, we will define the Quantum Fourier Transform (QFT) circuit using recursion inside a kernel function <code>qft</code>. The <code>qft</code> function takes two arguments: a quantum register <code>qreg</code> and an integer <code>n</code> representing the number of qubits we want to apply the QFT circuit to.</p> In\u00a0[\u00a0]: Copied! <pre>pi = math.pi\n\n\n@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int, k: int):\n    if k != n:\n        qasm2.h(qreg[k])\n        for i in range(k + 1, n):\n            qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)\n        qft(qreg, n, k + 1)  # recursion\n    return qreg\n</pre> pi = math.pi   @qasm2.extended def qft(qreg: qasm2.QReg, n: int, k: int):     if k != n:         qasm2.h(qreg[k])         for i in range(k + 1, n):             qasm2.cu1(qreg[i], qreg[k], 2 * math.pi / 2**i)         qft(qreg, n, k + 1)  # recursion     return qreg <p>Next, we will call this kernel function <code>qft</code> inside a <code>main</code> function to check if the QFT circuit is correctly implemented. We will use a quantum register of size 3.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    return qft(qasm2.qreg(3), 3, 0)\n</pre> @qasm2.extended def main():     return qft(qasm2.qreg(3), 3, 0) <p>Finally, we will run the <code>main</code> function on the <code>PyQrack</code> backend and print the quantum register to see the final state of the qubits after applying the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>device = StackMemorySimulator(min_qubits=3)\nqreg = device.run(main)\nprint(qreg)\n</pre> device = StackMemorySimulator(min_qubits=3) qreg = device.run(main) print(qreg) <p>we can also emit the QASM2 code for the <code>main</code> function and print it to see the QASM2 code that corresponds to the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.qasm2.emit import QASM2  # noqa: E402\nfrom bloqade.qasm2.parse import pprint  # noqa: E402\n\ntarget = QASM2()\nast = target.emit(main)\npprint(ast)\n</pre> from bloqade.qasm2.emit import QASM2  # noqa: E402 from bloqade.qasm2.parse import pprint  # noqa: E402  target = QASM2() ast = target.emit(main) pprint(ast)"},{"location":"digital/examples/qasm2/qft/#quantum-fourier-transform","title":"Quantum Fourier Transform\u00b6","text":"<p>In this example, we will explore the Quantum Fourier Transform (QFT) circuit using recursion and iteration -- a convenient way to implement the QFT circuit using our high-level programming features.</p> <p>To begin, we will import the <code>qasm2</code> module from the <code>bloqade</code> package and the <code>PyQrack</code> backend from the <code>bloqade.pyqrack</code> module.</p>"},{"location":"digital/examples/qasm2/repeat_until_success/","title":"Repeat Until Success with STAR Gadget","text":"In\u00a0[\u00a0]: Copied! <pre>from bloqade import qasm2\n</pre> from bloqade import qasm2 <p>This example highlights a few interesting capabilities of having a full kernel structure with runtime control flow. One example is the ability to dynamically allocate qubits, possibly based on previous run-time measurement outcomes.</p> <p>In this case, we prepare a resource state, which is a generalization of the T state with an arbitrary Z rotation $|0\\rangle + e^{i\\theta}|1\\rangle$.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef prep_resource_state(theta: float):\n    qreg = qasm2.qreg(1)\n    qubit = qreg[0]\n    qasm2.h(qubit)\n    qasm2.rz(qubit, theta)\n    return qubit\n</pre> @qasm2.extended def prep_resource_state(theta: float):     qreg = qasm2.qreg(1)     qubit = qreg[0]     qasm2.h(qubit)     qasm2.rz(qubit, theta)     return qubit <p>Using this resource state, we can teleport the Z phase gate to a target qubit using only Clifford gates, which are much easier to implement fault-tolerantly. This is implemented by first applying a CNOT gate controlled by the resource state on the target qubit, then measuring the target qubit in the computational basis. If the measurement outcome is 1 (which occurs with 50% probability), the gadget executed a Z(theta) gate on the target qubit and teleported it to the new resource state.</p> <p>However, if the measurement outcome is 0 (which occurs with 50% probability), we apply an X gate, and the gadget executed a Z(-theta) gate on the target qubit. In order to correct this gate, we must apply a Z(+2theta) gate on the new target state. Of course, we can apply this Z(+2theta) gate by applying the same gadget with twice the angle, and repeat until we get the correct outcome.</p> <p>The simplest way to implement the gadget is to simply post-select the correct measurement outcome using an assert statement. This is straightforward, but comes with an exponential overhead in the number of resource states: there is a 50% chance of success at each step, so there is only a $2^{-n}$ chance of success after $n$ Z phase gates.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_postselect(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:\n    ancilla = prep_resource_state(theta)\n    qasm2.cx(ancilla, target)\n    creg = qasm2.creg(1)\n    qasm2.measure(target, creg[0])\n    if creg[0]:\n        qasm2.x(ancilla)\n    return ancilla\n</pre> @qasm2.extended def z_phase_gate_postselect(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:     ancilla = prep_resource_state(theta)     qasm2.cx(ancilla, target)     creg = qasm2.creg(1)     qasm2.measure(target, creg[0])     if creg[0]:         qasm2.x(ancilla)     return ancilla <p>To (deterministically) implement the gate, we can recursively apply the gadget by correcting the angle of the Z gate by applying Z(+2*theta). Observe that, while it is efficient to represent this as a composition of kernels, there is no equivalent representation as a circuit, as the number of resource qubits and total number of gates is not known until runtime.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_recursive(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    ancilla = prep_resource_state(theta)\n    qasm2.cx(ancilla, target)\n    creg = qasm2.creg(1)\n    qasm2.measure(target, creg[0])\n    if creg[0]:\n        qasm2.x(ancilla)\n    else:\n        ancilla = z_phase_gate_recursive(ancilla, 2 * theta)\n    return ancilla\n</pre> @qasm2.extended def z_phase_gate_recursive(target: qasm2.Qubit, theta: float) -&gt; qasm2.Qubit:     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     ancilla = prep_resource_state(theta)     qasm2.cx(ancilla, target)     creg = qasm2.creg(1)     qasm2.measure(target, creg[0])     if creg[0]:         qasm2.x(ancilla)     else:         ancilla = z_phase_gate_recursive(ancilla, 2 * theta)     return ancilla <p>An alternative representation uses control flow to implement the same gate. If the number of repeats is fixed, this can be represented as a static circuit, though it would require a large number of resource qubits and may still fail with a small probability $2^{-attempts}$.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef z_phase_gate_loop(target: qasm2.Qubit, theta: float, attempts: int):\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    creg = qasm2.creg(1)  # Implicitly initialized to 0, thanks qasm...\n    for ctr in range(attempts):\n        ancilla = prep_resource_state(theta * (2**ctr))\n        if not creg[0]:\n            qasm2.cx(ancilla, target)\n            qasm2.measure(target, creg[0])\n            target = ancilla\n    qasm2.x(target)\n</pre> @qasm2.extended def z_phase_gate_loop(target: qasm2.Qubit, theta: float, attempts: int):     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     creg = qasm2.creg(1)  # Implicitly initialized to 0, thanks qasm...     for ctr in range(attempts):         ancilla = prep_resource_state(theta * (2**ctr))         if not creg[0]:             qasm2.cx(ancilla, target)             qasm2.measure(target, creg[0])             target = ancilla     qasm2.x(target) <p>Before we analyze these circuits, we must declare a main function which takes no inputs, as qasm2 does not support parameterized circuits or subcircuits.</p> In\u00a0[\u00a0]: Copied! <pre>theta = 0.1  # Specify some Z rotation angle. Note that this is being defined\n</pre> theta = 0.1  # Specify some Z rotation angle. Note that this is being defined <p>outside the main function and being used inside the function via closure.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef postselect_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_postselect(target[0], theta)\n\n\n@qasm2.extended\ndef recursion_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_recursive(target[0], theta)\n\n\n@qasm2.extended\ndef loop_main():\n    target = qasm2.qreg(1)\n    z_phase_gate_loop(target[0], theta, 5)\n</pre> @qasm2.extended def postselect_main():     target = qasm2.qreg(1)     z_phase_gate_postselect(target[0], theta)   @qasm2.extended def recursion_main():     target = qasm2.qreg(1)     z_phase_gate_recursive(target[0], theta)   @qasm2.extended def loop_main():     target = qasm2.qreg(1)     z_phase_gate_loop(target[0], theta, 5) <p>Now lets explore running some interpreters on these circuits. We support the quantum emulation backend PyQrack, which simulates quantum circuits using state vectors.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import PyQrack  # noqa: E402\n\ndevice = PyQrack()\ndevice.run(postselect_main)\n</pre> from bloqade.pyqrack import PyQrack  # noqa: E402  device = PyQrack() device.run(postselect_main)"},{"location":"digital/examples/qasm2/repeat_until_success/#repeat-until-success-with-star-gadget","title":"Repeat Until Success with STAR Gadget\u00b6","text":"<p>In this example, we will demonstrate a near-term fault tolerant gadget which is a repeat-until-success protocol to implement a Z phase gate using a resource state (similar to a T state), Pauli gates, and feed-forward measurement.</p> <p>For more information, see https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337, especially Fig. 7.</p>"},{"location":"digital/examples/squin/deutsch_squin/","title":"Deutsch-Jozsa Algorithm","text":"<p>We start by loading in some stuff and defining some parameters.</p> In\u00a0[\u00a0]: Copied! <pre>import random\nfrom typing import Any\n\nfrom bloqade.types import Qubit\nfrom kirin.dialects import ilist\nfrom bloqade.pyqrack import StackMemorySimulator\n\nfrom bloqade import squin\n\nn_bits = 2\n</pre> import random from typing import Any  from bloqade.types import Qubit from kirin.dialects import ilist from bloqade.pyqrack import StackMemorySimulator  from bloqade import squin  n_bits = 2 <p>Now, before we can implement the actual algorithm, we need to define the oracles, i.e. the functions we want to check for.</p> <p>The problem is defined as follows: Given a bit string of length $n$, $x \\in \\{0, 1\\}^\\otimes n$, we have a function that is either constant or balanced.</p> <p>A constant function is defined as $f_\\text{const}(x) = c \\forall x$, where $c \\in \\{0, 1\\}$ is some constant value.</p> <p>A balanced function, on the other hand, is defined by</p> <p>$f_\\text{balanced}(x) = \\begin{cases} 0 \\, \\forall x \\in S(x), \\\\ 1 \\text{ else,} \\end{cases}$</p> <p>where $S(x)$ is an arbitrarily chosen half of all possible bit strings, i.e. $|S(x)| = 2^{n-1}$.</p> <p>For our example, we will be using $n + 1$ qubits, where $n$ store the bitstring $x$ and the result is stored in the last qubit. We'll be writing our oracle functions as squin kernels, which we can then later use in the actual algorithm implementation.</p> <p>In order to define our oracle functions, we can simply choose for the constant function to always return $1$, which we achieve by flipping the final qubit using an $X$ gate.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef f_constant(q: ilist.IList[Qubit, Any]):\n    # flip the final (result) qubit -- every bit string is mapped to 1\n    squin.x(q[-1])\n</pre> @squin.kernel def f_constant(q: ilist.IList[Qubit, Any]):     # flip the final (result) qubit -- every bit string is mapped to 1     squin.x(q[-1]) <p>For the balanced oracle we use the following approach: we use the first qubit as control in a $CX$ gate, which is applied to the resulting qubit. This means that the result will be $1$ in exactly half the cases.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef f_balanced(q: ilist.IList[Qubit, Any]):\n    squin.cx(q[0], q[-1])\n</pre> @squin.kernel def f_balanced(q: ilist.IList[Qubit, Any]):     squin.cx(q[0], q[-1]) <p>Now, we define the actual algorithm as a kernel, which simply takes one of the other kernels as input. In the end, we can infer which function was provided by looking at the resulting measurement of the result qubit.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef deutsch_algorithm(f):\n    q = squin.qalloc(n_qubits=n_bits + 1)\n    squin.x(q[-1])\n\n    # broadcast for parallelism\n    squin.broadcast.h(q)\n\n    # apply the oracle function\n    f(q)\n\n    squin.broadcast.h(q[:-1])\n\n    return squin.broadcast.measure(q[:-1])\n</pre> @squin.kernel def deutsch_algorithm(f):     q = squin.qalloc(n_qubits=n_bits + 1)     squin.x(q[-1])      # broadcast for parallelism     squin.broadcast.h(q)      # apply the oracle function     f(q)      squin.broadcast.h(q[:-1])      return squin.broadcast.measure(q[:-1]) <p>Finally, we actually run the result. To do so, we use the <code>PyQrack</code> simulation backend in bloqade.</p> <p>To make things a bit more interesting, we randomly select which function we are running the algorithm with.</p> In\u00a0[\u00a0]: Copied! <pre>sim = StackMemorySimulator(min_qubits=n_bits + 1)\n\nf_choice_idx = random.randint(0, 1)\nf_choice = (f_constant, f_balanced)[f_choice_idx]\n\n# result = sim.run(deutsch_algorithm, args=(f_balanced, n))\nresult0 = 0.0\nn_shots = 100\nfor _ in range(n_shots):\n    res = sim.run(deutsch_algorithm, args=(f_choice,))\n    result0 += res[0] / n_shots\n\nprint(\n    \"Oh magic Deutsch-Jozsa algorithm, tell us if our function is constant or balanced:\"\n)\nprint(\"*drumroll*\")\nif result0 == 0:\n    print(\"It's constant!\")\n\n    # let's make sure we actually did the right thing here\n    assert f_choice_idx == 0\nelse:\n    print(\"It's balanced!\")\n\n    # let's make sure we actually did the right thing here\n    assert f_choice_idx == 1\n</pre> sim = StackMemorySimulator(min_qubits=n_bits + 1)  f_choice_idx = random.randint(0, 1) f_choice = (f_constant, f_balanced)[f_choice_idx]  # result = sim.run(deutsch_algorithm, args=(f_balanced, n)) result0 = 0.0 n_shots = 100 for _ in range(n_shots):     res = sim.run(deutsch_algorithm, args=(f_choice,))     result0 += res[0] / n_shots  print(     \"Oh magic Deutsch-Jozsa algorithm, tell us if our function is constant or balanced:\" ) print(\"*drumroll*\") if result0 == 0:     print(\"It's constant!\")      # let's make sure we actually did the right thing here     assert f_choice_idx == 0 else:     print(\"It's balanced!\")      # let's make sure we actually did the right thing here     assert f_choice_idx == 1"},{"location":"digital/examples/squin/deutsch_squin/#deutsch-jozsa-algorithm","title":"Deutsch-Jozsa Algorithm\u00b6","text":"<p>In this example, we will implement a version of the Deutsch-Josza algorithm using bloqade's squin dialect.</p>"},{"location":"digital/examples/squin/ghz/","title":"GHZ State Preparation with Squin","text":"<p>The circuit we will implement is displayed below:</p> <p></p> <p>Let's start by importing Squin and writing our circuit for an arbitrary number of qubits.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import StackMemorySimulator  # we'll need that later\n\nfrom bloqade import squin\n\n\n@squin.kernel\ndef ghz_linear(n: int):\n    q = squin.qalloc(n)\n    squin.h(q[0])\n    for i in range(1, n):\n        squin.cx(q[i - 1], q[i])\n\n\nghz_linear.print()\n</pre> from bloqade.pyqrack import StackMemorySimulator  # we'll need that later  from bloqade import squin   @squin.kernel def ghz_linear(n: int):     q = squin.qalloc(n)     squin.h(q[0])     for i in range(1, n):         squin.cx(q[i - 1], q[i])   ghz_linear.print() <p>As you can see, writing basic circuits in squin is rather straightforward.</p> In\u00a0[\u00a0]: Copied! <pre>sim = StackMemorySimulator(min_qubits=2)\nresult = sim.run(ghz_linear, args=(2,))\nprint(result)\n</pre> sim = StackMemorySimulator(min_qubits=2) result = sim.run(ghz_linear, args=(2,)) print(result) <p>As you can see, the result of our simulation is <code>None</code>. That is because we are not returning anything from the kernel function.</p> <p>Note, how we're passing in the arguments of the kernel function as a separate tuple in the call to <code>run</code>. This signature is required since <code>ghz_linear(2)</code> would not return another kernel function, but rather attempt to run the kernel function as a Python function. As the function is written in squin rather than Python, this would fail. To provide a little more detail here: the <code>PyQrack</code> backend in bloqade-circuit actually has its own method table which tells it how to interpret the statements encountered in the squin kernel function.</p> <p>Since we are only simulating the circuit, however, we are able to fetch information that would otherwise not be attainable. For example, you can obtain the state vector from the simulator:</p> In\u00a0[\u00a0]: Copied! <pre>print(sim.state_vector(ghz_linear, args=(2,)))\n</pre> print(sim.state_vector(ghz_linear, args=(2,))) <p>Looking at the output, we can see that we indeed prepared a two-qubit GHZ state (up to a global phase).</p> <p>Note, that you can also add a return value to the kernel, which is then returned by <code>sim.run</code>. Again, this is not generally possible when running on hardware, but only during simulation.</p> <p>A realistic kernel function will return (a list of) measurement results. That is precisely what we will do in the following.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef noisy_linear_ghz(n: int, p_single: float, p_paired: float):\n    q = squin.qalloc(n)\n\n    squin.h(q[0])\n    squin.depolarize(p_single, q[0])\n\n    for i in range(1, n):\n        squin.cx(q[i - 1], q[i])\n        squin.depolarize2(p_paired, q[i - 1], q[i])\n\n    return squin.broadcast.measure(q)\n</pre> @squin.kernel def noisy_linear_ghz(n: int, p_single: float, p_paired: float):     q = squin.qalloc(n)      squin.h(q[0])     squin.depolarize(p_single, q[0])      for i in range(1, n):         squin.cx(q[i - 1], q[i])         squin.depolarize2(p_paired, q[i - 1], q[i])      return squin.broadcast.measure(q) In\u00a0[\u00a0]: Copied! <pre>noisy_linear_ghz.print()\n</pre> noisy_linear_ghz.print() <p>Noise operators</p> <p>     As opposed to standard gates, there is no standard library for noise statements as of now.     While we plan to add that in the future, also note how it can be convenient to separate the operator     from the gate application: we define the paired noise operator only once and apply it to different     pairs of qubits in the loop. </p> <p>This kernel function can be simulated in the exact same way as before. The only difference is that we now need to provide additional arguments for the noise probabilities.</p> In\u00a0[\u00a0]: Copied! <pre>result = sim.run(noisy_linear_ghz, args=(2, 1e-2, 2e-2))\nprint(result)\n</pre> result = sim.run(noisy_linear_ghz, args=(2, 1e-2, 2e-2)) print(result) <p>Now that we actually return something, we also obtain a result from running the simulation. This result is just a list of measurement results (boolean values corresponding to 0 and 1). We can also obtain the bit string:</p> In\u00a0[\u00a0]: Copied! <pre>result_bitstring = [int(res) for res in result]\nprint(result_bitstring)\n</pre> result_bitstring = [int(res) for res in result] print(result_bitstring) <p>Ideally, the two values should always be correlated since we want to prepare a GHZ state. However, now that we've added noise, this is not always the case.</p> <p>We can actually use this fact to define a \"fidelity\" measure for the circuit: when repeatedly executing the circuit, uncorrelated results lower the fidelity.</p> <p>Mathematically, let's define the fidelity $F$ as</p> <p>$F = 1 - \\sum_{i=1}^n \\frac{\\text{err}(i)}{n}$,</p> <p>where $n$ is the number of shots we take and</p> <p>$ \\text{err}(i) = \\begin{cases} 0 \\text{ if run }i \\text{ is correct} \\\\ 1 \\text{ else } \\end{cases}$</p> <p>In this case, \"correct\" means the measurement outcome is fully correlated.</p> In\u00a0[\u00a0]: Copied! <pre>n_shots = 1000\nn_qubits = 4\np_single = 1e-2\np_paired = 2 * p_single\nfidelity = 1.0\nsim = StackMemorySimulator(min_qubits=n_qubits)\nfor _ in range(n_shots):\n    result = sim.run(noisy_linear_ghz, args=(n_qubits, p_single, p_paired))\n    measured_one_state = all(result)\n    measured_zero_state = not any(result)\n    is_correlated = measured_one_state or measured_zero_state\n    if not is_correlated:\n        fidelity -= 1 / n_shots\n\nprint(fidelity)\n</pre> n_shots = 1000 n_qubits = 4 p_single = 1e-2 p_paired = 2 * p_single fidelity = 1.0 sim = StackMemorySimulator(min_qubits=n_qubits) for _ in range(n_shots):     result = sim.run(noisy_linear_ghz, args=(n_qubits, p_single, p_paired))     measured_one_state = all(result)     measured_zero_state = not any(result)     is_correlated = measured_one_state or measured_zero_state     if not is_correlated:         fidelity -= 1 / n_shots  print(fidelity) <p>Note, that this is actually a poor measure for fidelity as it only counts fully correlated states and treats everything else as an equivalent error. If you have many qubits, you could argue that only flipping a single bit is a much lower error than flipping many, and that this should be weighed in here. Or, you can simply use the simulator to obtain the state vector and compute the overlap. Or, define whatever measure of fidelity you see fit here, but we'll end this tutorial here.</p>"},{"location":"digital/examples/squin/ghz/#ghz-state-preparation-with-squin","title":"GHZ State Preparation with Squin\u00b6","text":"<p>In this example, we will show (yet again) how to implement a program that prepares a GHZ state. We will do so with a simple linear algorithm and show how to manually insert noise.</p>"},{"location":"digital/examples/squin/ghz/#simulating-the-kernel","title":"Simulating the kernel\u00b6","text":"<p>You can simulate a kernel such as the above using bloqade's PyQrack backend.</p> <p>There are two basic simulators, that act like \"devices\" that you run your program on:</p> <ul> <li>The <code>StackMemorySimulator</code>, which initializes its memory with a fixed number of qubits. The number is either set via the <code>min_qubits</code> argument or inferred automatically. Note, that automatic inference is not always possible in which case you will be required to set the argument accordingly.</li> <li>The <code>DynamicMemorySimulator</code>, which, as the name suggests, allocates memory as required throughout the circuit. Generally, you should prefer the <code>StackMemorySimulator</code> over this one unless the number of qubits can only be known at runtime.</li> </ul> <p>Let's go ahead and use the <code>StackMemorySimulator</code> together with a fixed number of qubits to simulate our GHZ preparation program from above.</p>"},{"location":"digital/examples/squin/ghz/#inserting-noise","title":"Inserting noise\u00b6","text":"<p>The above is rather basic, so let's try to do something that is a little more interesting. Let's write the same program as before, but now we assume that noise processes occur whenever a gate is applied.</p> <p>We will make use of Squin's noise submodule in order to do that.</p> <p>Our \"noise model\" will be quite simple:</p> <ul> <li>Whenever a single-qubit gate is applied, that qubit undergoes a depolarization error with probability <code>p_single</code>.</li> <li>Whenever a two-qubit (controlled) gate is applied, both qubits undergo a joint depolarization error with probability <code>p_paired</code>.</li> </ul> <p>Note, that a depolarization error with probability $p$ on a single qubit means that randomly chosen Pauli operators (one of $X, Y, Z$) is applied to the qubit with probability $p$. Similarly, a two-qubit depolarization error applies one of the 15 operators $IX, IY, IZ, XI, XX, ...$ with a given probability.</p>"},{"location":"digital/simulator_device/simulator_device/","title":"Simulation devices","text":"<p>A simulation device can run a task, such as executing a kernel. It acts just like a device that is an actual hardware, but runs everything in a local simulation. As such, it can also be used to inspect the results of your program beyond what is possible on a QPU. For example, you can return the <code>state_vector</code> of the quantum register at the end of the task execution.</p> <p>Here's how you can use it in order to run a simple <code>qasm2.extended</code> kernel.</p> <pre><code>from bloqade.pyqrack import StackMemorySimulator\nfrom bloqade import qasm2\n\n@qasm2.extended\ndef main():\n    q = qasm2.qreg(2)\n\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n\n    return q\n\nsim = StackMemorySimulator(min_qubits=2)\n\n# get the state vector -- oohh entanglement\nstate = sim.state_vector(main)\n</code></pre>"},{"location":"digital/simulator_device/tasks/","title":"Tasks","text":"<p>Tasks are generally executed by devices. A task can be run locally or remotely. On the one hand, when running locally, your local machine will execute the task at hand and wait for the result. On the other hand, when a task is submitted to be executed on a remote device, you will obtain an object similar to a future object in async programming, which can await the result (or not).</p> <p>In order to interact with a task, you'll usually want to instantiate a device and create a new task on that device. For example,</p> <pre><code>from bloqade.pyqrack import StackMemorySimulator\nfrom bloqade import squin\n\n@squin.kernel\ndef main():\n    q = squin.qalloc(2)\n\n    squin.gate.h(q[0])\n    squin.gate.cx(q[0], q[1])\n\n    return q\n\nsim = StackMemorySimulator(min_qubits=2)\ntask = sim.task(main)\nresult = task.run()\n</code></pre> <p>Info</p> <p>Most methods that directly execute a kernel on a device are just wrappers for the above: a new task is created internally and then run on the device.</p> <p>Note</p> <p>Currently, there are only local simulation devices available. However, in the near future, you will also be able to submit tasks to a remote machine and even actual quantum hardware.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/","title":"Circuits with Bloqade","text":"In\u00a0[\u00a0]: Copied! <pre>from typing import Any\n\nimport numpy as np\nimport bloqade.types\nfrom kirin.ir import Method\nfrom bloqade.types import Qubit, MeasurementResult\n\n# Some types we will use, useful for type hints\nfrom kirin.dialects.ilist import IList\n\nfrom bloqade import squin\n\nRegister = IList[Qubit, Any]\n</pre> from typing import Any  import numpy as np import bloqade.types from kirin.ir import Method from bloqade.types import Qubit, MeasurementResult  # Some types we will use, useful for type hints from kirin.dialects.ilist import IList  from bloqade import squin  Register = IList[Qubit, Any] In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef hello_world(theta: float) -&gt; IList[MeasurementResult, Any]:\n    \"\"\"\n    Prepare a Bell state and measure in a basis that might have a Bell violation\n    \"\"\"\n    qubits = squin.qalloc(2)\n    squin.h(qubits[0])\n    squin.cx(qubits[0], qubits[1])\n    squin.rx(theta, qubits[0])\n    bits = squin.qubit.measure(qubits)\n    return bits\n\n\n# [kernel].print() prints the raw SSA, which is the intermediate representation of the kernel\n# as used internally by Kirin.\nhello_world.print()\n</pre> @squin.kernel def hello_world(theta: float) -&gt; IList[MeasurementResult, Any]:     \"\"\"     Prepare a Bell state and measure in a basis that might have a Bell violation     \"\"\"     qubits = squin.qalloc(2)     squin.h(qubits[0])     squin.cx(qubits[0], qubits[1])     squin.rx(theta, qubits[0])     bits = squin.qubit.measure(qubits)     return bits   # [kernel].print() prints the raw SSA, which is the intermediate representation of the kernel # as used internally by Kirin. hello_world.print() In\u00a0[\u00a0]: Copied! <pre># Bell state prep.\n\n\ndef GHZ_method_factory(nqubits: int) -&gt; Method:\n    @squin.kernel\n    def GHZ_state() -&gt; Register:\n        qubits = squin.qalloc(nqubits)\n        squin.h(qubits[0])\n        for i in range(nqubits):\n            squin.cx(qubits[i], qubits[i + 1])\n\n        return qubits\n\n    return GHZ_state\n\n\nkernel = GHZ_method_factory(8)\nkernel.print()\n</pre> # Bell state prep.   def GHZ_method_factory(nqubits: int) -&gt; Method:     @squin.kernel     def GHZ_state() -&gt; Register:         qubits = squin.qalloc(nqubits)         squin.h(qubits[0])         for i in range(nqubits):             squin.cx(qubits[i], qubits[i + 1])          return qubits      return GHZ_state   kernel = GHZ_method_factory(8) kernel.print() <p>Alternatively, kernels could be parameterized; for example, we could write the same GHZ state preparation, except it prepares a variable number of qubits that is not declared until the kernel is run. In order to run in some <code>main</code> function, the qubits need to be declared elsewhere, either in the task declaration or within a larger kernel that calls this method as a subroutine.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef GHZ_state_factory(nqubits: int) -&gt; Register:\n    qubits = squin.qalloc(nqubits)\n    squin.h(qubits[0])\n    for i in range(nqubits - 1):\n        squin.cx(qubits[i], qubits[i + 1])\n    return qubits\n\n\nGHZ_state_factory.print()\n</pre> @squin.kernel def GHZ_state_factory(nqubits: int) -&gt; Register:     qubits = squin.qalloc(nqubits)     squin.h(qubits[0])     for i in range(nqubits - 1):         squin.cx(qubits[i], qubits[i + 1])     return qubits   GHZ_state_factory.print() In\u00a0[\u00a0]: Copied! <pre>import cirq\n\n\ndef ghz_prep(nqubits: int) -&gt; cirq.Circuit:\n    \"\"\"\n    Builder function that returns a simple N-qubit\n    GHZ state preparation circuit\n    \"\"\"\n    qubits = cirq.LineQubit.range(nqubits)\n    output = cirq.Circuit()\n    output.append(cirq.H(qubits[0]))\n    for i in range(nqubits - 1):\n        output.append(cirq.CX(qubits[i], qubits[i + 1]))\n    return output\n\n\nprint(ghz_prep(4))\n</pre> import cirq   def ghz_prep(nqubits: int) -&gt; cirq.Circuit:     \"\"\"     Builder function that returns a simple N-qubit     GHZ state preparation circuit     \"\"\"     qubits = cirq.LineQubit.range(nqubits)     output = cirq.Circuit()     output.append(cirq.H(qubits[0]))     for i in range(nqubits - 1):         output.append(cirq.CX(qubits[i], qubits[i + 1]))     return output   print(ghz_prep(4)) <p>The cirq circuit can be converted to a bloqade kernel with the transpilation function <code>load_circuit</code>. The kernel can be considered as a transformation on the register of qubits it is applied to as arguments, with the return being the qubits that still persist.</p> In\u00a0[\u00a0]: Copied! <pre>from bloqade.cirq_utils import emit_circuit, load_circuit\n\n# Load a cirq circuit into squin\nkernel = load_circuit(\n    ghz_prep(4),\n    kernel_name=\"ghz_prep_cirq\",  # Define the name of the kernel as if one were using @squin.kernel on a function\n    register_as_argument=False,  # If the resulting kernel should take in a qubit register (True) or make a new one (False)\n    return_register=True,  # If the resulting kernel should return the register of the qubits it acts on.\n)\n\n# Then, we can convert the circuit back to cirq.\n# Note that this is **not possible** in a general case because\n# cirq cannot represent complex control flow.\ncircuit2: cirq.Circuit = emit_circuit(kernel, ignore_returns=True)\nprint(circuit2)\n</pre> from bloqade.cirq_utils import emit_circuit, load_circuit  # Load a cirq circuit into squin kernel = load_circuit(     ghz_prep(4),     kernel_name=\"ghz_prep_cirq\",  # Define the name of the kernel as if one were using @squin.kernel on a function     register_as_argument=False,  # If the resulting kernel should take in a qubit register (True) or make a new one (False)     return_register=True,  # If the resulting kernel should return the register of the qubits it acts on. )  # Then, we can convert the circuit back to cirq. # Note that this is **not possible** in a general case because # cirq cannot represent complex control flow. circuit2: cirq.Circuit = emit_circuit(kernel, ignore_returns=True) print(circuit2) <p>The circuit loading also works with classical feed forward, though it is generally more difficult to extract a cirq circuit from a generic feedforward cirq kernel. For example, the T teleportation gadget can be written and loaded as</p> In\u00a0[\u00a0]: Copied! <pre>reg = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit()\ncircuit.append(cirq.T(reg[0]))\ncircuit.append(cirq.CNOT(reg[1], reg[0]))\ncircuit.append(cirq.measure(reg[0], key=\"m\"))\ncircuit.append(cirq.S(reg[1]).with_classical_controls(\"m\"))\ncircuit.append(cirq.X(reg[1]).with_classical_controls(\"m\"))\nprint(circuit)\nkernel = load_circuit(\n    circuit, kernel_name=\"teleport\", register_as_argument=True, return_register=True\n)\nkernel.print()\n</pre> reg = cirq.LineQubit.range(2) circuit = cirq.Circuit() circuit.append(cirq.T(reg[0])) circuit.append(cirq.CNOT(reg[1], reg[0])) circuit.append(cirq.measure(reg[0], key=\"m\")) circuit.append(cirq.S(reg[1]).with_classical_controls(\"m\")) circuit.append(cirq.X(reg[1]).with_classical_controls(\"m\")) print(circuit) kernel = load_circuit(     circuit, kernel_name=\"teleport\", register_as_argument=True, return_register=True ) kernel.print() <p>Due to the difficulty of representing mid-circuit control flow in cirq, attempting to lower these kernels back to cirq will result in an error.</p> In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef t_teleport_noargs() -&gt; None:\n    \"\"\"\n    A simple T teleportation circuit that requires mid circuit control flow.\n    \"\"\"\n    ancilla = squin.qalloc(1)[0]\n    target = squin.qalloc(1)[0]\n    squin.t(ancilla)\n    squin.cx(target, ancilla)\n    if squin.qubit.measure(target):\n        squin.s(ancilla)\n        squin.x(ancilla)\n\n\ntry:\n    print(emit_circuit(t_teleport_noargs))\n    raise (RuntimeError(\"Oops this should have errored.\"))\nexcept Exception as e:\n    print(\"ERROR:\", e)\n\n\n# Though measurement without feedforward is possible\n@squin.kernel\ndef coinflip() -&gt; MeasurementResult:\n    qubit = squin.qalloc(1)[0]\n    squin.h(qubit)\n    return squin.qubit.measure(qubit)\n\n\ncircuit = emit_circuit(coinflip, ignore_returns=True)\nprint(circuit)\n</pre> @squin.kernel def t_teleport_noargs() -&gt; None:     \"\"\"     A simple T teleportation circuit that requires mid circuit control flow.     \"\"\"     ancilla = squin.qalloc(1)[0]     target = squin.qalloc(1)[0]     squin.t(ancilla)     squin.cx(target, ancilla)     if squin.qubit.measure(target):         squin.s(ancilla)         squin.x(ancilla)   try:     print(emit_circuit(t_teleport_noargs))     raise (RuntimeError(\"Oops this should have errored.\")) except Exception as e:     print(\"ERROR:\", e)   # Though measurement without feedforward is possible @squin.kernel def coinflip() -&gt; MeasurementResult:     qubit = squin.qalloc(1)[0]     squin.h(qubit)     return squin.qubit.measure(qubit)   circuit = emit_circuit(coinflip, ignore_returns=True) print(circuit) In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import StackMemorySimulator, DynamicMemorySimulator\n\n# StackMemorySimulator - static number of qubits\n# DynamicMemorySimulator - dynamic number of qubits, but slower. Use if you don't know how many qubits you need in advance.\nemulator = StackMemorySimulator(min_qubits=8)\n\ntask = emulator.task(GHZ_state_factory, args=(4,))\nresults = task.run()\n# The results are the same ResultType as the kernel return.\n# In this case, it is a list of qubits.\nprint(results)\n</pre> from bloqade.pyqrack import StackMemorySimulator, DynamicMemorySimulator  # StackMemorySimulator - static number of qubits # DynamicMemorySimulator - dynamic number of qubits, but slower. Use if you don't know how many qubits you need in advance. emulator = StackMemorySimulator(min_qubits=8)  task = emulator.task(GHZ_state_factory, args=(4,)) results = task.run() # The results are the same ResultType as the kernel return. # In this case, it is a list of qubits. print(results) <p>Note that, while it is instinctive to simply call <code>GHZ_state_factory(4)</code> and expect it to run, this isn't necessarily the correct abstraction. <code>emulator.task</code> links the kernel to a specific interpreter-- for example, if you wanted to run your program on a noisy emulator vs a perfect emulator vs. real hardware, this is the way you would specify it. Furthermore, the instantiation of the task is not necessarily linked with the execution of that task. For example, if that task must be run asynchronously on hardware, there must be an object which represents the run itself as well as the (future) results.</p> <p>For simpler kernels that only use kirin built-in statements -- such as control flow, for loops, arithmetic, and the like -- it is possible to directly call the kernel and use the default Kirin interpreter.</p> In\u00a0[\u00a0]: Copied! <pre>def foo(x: int, y: int) -&gt; bool:\n    return x &lt; y\n\n\nassert foo(1, 2)\n</pre> def foo(x: int, y: int) -&gt; bool:     return x &lt; y   assert foo(1, 2) In\u00a0[\u00a0]: Copied! <pre>from bloqade.pyqrack import PyQrackQubit\n\n# This kernel returns a list of Qubit objects. We can use these to analyze the\n# quantum state of the register.\nresults: list[PyQrackQubit] = task.run()\n\n# If the kernel does not return the qubit register, one can still collect it. Note that\n# it is now the onus of you, the user, to determine which qubits are which.\n# Qubits are typically added sequentially, so if you make multiple registers, the qubits\n# will be in the order they were added. The StackMemorySimulator may have extra qubits.\nqubits: list[PyQrackQubit] = task.qubits()\n\n# Extract the quantum state as a reduced density matrix. Note that he qubits themselves\n# point to the internal state of the emulator\nstate = emulator.quantum_state(results)\ndensity_matrix = emulator.reduced_density_matrix(results)\n\n# Note that the RDM is represented in its eigenbasis for efficiency.\n# If the state is pure, there is only one nonzero eigenvalue. This is the case for the GHZ state.\nprint(\"A pure state has only a single eigenvalue [1] of the RDM:\", state.eigenvalues)\nstatevector = state.eigenvectors[:, 0]\nprint(\"The statevector of the GHZ state looks like [1, 0, 0, ..., 0, 1]\")\nprint(statevector)\n</pre> from bloqade.pyqrack import PyQrackQubit  # This kernel returns a list of Qubit objects. We can use these to analyze the # quantum state of the register. results: list[PyQrackQubit] = task.run()  # If the kernel does not return the qubit register, one can still collect it. Note that # it is now the onus of you, the user, to determine which qubits are which. # Qubits are typically added sequentially, so if you make multiple registers, the qubits # will be in the order they were added. The StackMemorySimulator may have extra qubits. qubits: list[PyQrackQubit] = task.qubits()  # Extract the quantum state as a reduced density matrix. Note that he qubits themselves # point to the internal state of the emulator state = emulator.quantum_state(results) density_matrix = emulator.reduced_density_matrix(results)  # Note that the RDM is represented in its eigenbasis for efficiency. # If the state is pure, there is only one nonzero eigenvalue. This is the case for the GHZ state. print(\"A pure state has only a single eigenvalue [1] of the RDM:\", state.eigenvalues) statevector = state.eigenvectors[:, 0] print(\"The statevector of the GHZ state looks like [1, 0, 0, ..., 0, 1]\") print(statevector) <p>If the output is randomized, one can average over many runs using <code>task.batch_run</code>. This returns a dictionary of probabilities of each output. Note that the output must be hashable.</p> In\u00a0[\u00a0]: Copied! <pre># Define the emulator and task\nemulator = StackMemorySimulator(min_qubits=1)\ntask = emulator.task(coinflip)\nresults = task.batch_run(shots=1000)\nstate = task.batch_state(shots=1000)\nprint(\"Results:\", results)\nprint(\"State:\", state)\n</pre> # Define the emulator and task emulator = StackMemorySimulator(min_qubits=1) task = emulator.task(coinflip) results = task.batch_run(shots=1000) state = task.batch_state(shots=1000) print(\"Results:\", results) print(\"State:\", state) In\u00a0[\u00a0]: Copied! <pre>def trotter_layer(\n    qubits: list[cirq.Qid], dt: float = 0.01, J: float = 1, h: float = 1\n) -&gt; cirq.Circuit:\n    \"\"\"\n    Cirq builder function that returns a circuit of\n    a Trotter step of the 1D transverse Ising model\n    \"\"\"\n    op_zz = cirq.ZZ ** (dt * J / np.pi)\n    op_x = cirq.X ** (dt * h / np.pi)\n    circuit = cirq.Circuit()\n    for i in range(0, len(qubits) - 1, 2):\n        circuit.append(op_zz.on(qubits[i], qubits[i + 1]))\n    for i in range(1, len(qubits) - 1, 2):\n        circuit.append(op_zz.on(qubits[i], qubits[i + 1]))\n    for i in range(len(qubits)):\n        circuit.append(op_x.on(qubits[i]))\n    return circuit\n\n\ndef trotter_circuit(\n    N: int, steps: int = 10, dt: float = 0.01, J: float = 1, h: float = 1\n) -&gt; cirq.Circuit:\n    qubits = cirq.LineQubit.range(N)\n    circuit = cirq.Circuit()\n    for _ in range(steps):\n        circuit += trotter_layer(qubits, dt, J, h)\n    return circuit\n\n\ncirq_trotter_circuit = trotter_circuit(N=8, steps=4, dt=0.01, J=1, h=1)\n\nprint(cirq_trotter_circuit)\n\n# Convert the circuit to a bloqade kernel\nbloqade_trotter_circuit = load_circuit(\n    cirq_trotter_circuit,\n    kernel_name=\"trotter\",\n    register_as_argument=False,\n    return_register=True,\n)\n</pre> def trotter_layer(     qubits: list[cirq.Qid], dt: float = 0.01, J: float = 1, h: float = 1 ) -&gt; cirq.Circuit:     \"\"\"     Cirq builder function that returns a circuit of     a Trotter step of the 1D transverse Ising model     \"\"\"     op_zz = cirq.ZZ ** (dt * J / np.pi)     op_x = cirq.X ** (dt * h / np.pi)     circuit = cirq.Circuit()     for i in range(0, len(qubits) - 1, 2):         circuit.append(op_zz.on(qubits[i], qubits[i + 1]))     for i in range(1, len(qubits) - 1, 2):         circuit.append(op_zz.on(qubits[i], qubits[i + 1]))     for i in range(len(qubits)):         circuit.append(op_x.on(qubits[i]))     return circuit   def trotter_circuit(     N: int, steps: int = 10, dt: float = 0.01, J: float = 1, h: float = 1 ) -&gt; cirq.Circuit:     qubits = cirq.LineQubit.range(N)     circuit = cirq.Circuit()     for _ in range(steps):         circuit += trotter_layer(qubits, dt, J, h)     return circuit   cirq_trotter_circuit = trotter_circuit(N=8, steps=4, dt=0.01, J=1, h=1)  print(cirq_trotter_circuit)  # Convert the circuit to a bloqade kernel bloqade_trotter_circuit = load_circuit(     cirq_trotter_circuit,     kernel_name=\"trotter\",     register_as_argument=False,     return_register=True, ) <p>As an intermediate, one can mix between writing kernels converted from Cirq circuits and direct bloqade kernels. For example, each layer has fixed parameters as defined by a cirq circuit, but a variable number of layers as parameterized by a kernel input and for loop. This option has the benefit of being able to use Cirq infrastructure to optimize and represent individual layers, while still being able to use bloqade kernels to represent parameterized circuits. In this case, the output kernel has the timestep and Ising parameters fixed (as they are fixed in the cirq circuit), but the number of steps is variable.</p> In\u00a0[\u00a0]: Copied! <pre>def factory_trotter(N: int, dt: float = 0.01, J: float = 1, h: float = 1) -&gt; Method:\n    bloqade_trotter_layer = load_circuit(\n        trotter_layer(qubits=cirq.LineQubit.range(N), dt=dt, J=J, h=h),\n        kernel_name=\"trotter\",\n        register_as_argument=True,\n        return_register=True,\n    )\n\n    @squin.kernel\n    def trotter_for_loop(steps: int) -&gt; Register:\n        \"\"\"\n        Main function that runs the Trotter circuit for a given number of steps\n        \"\"\"\n        qubits = squin.qalloc(N)\n        for _ in range(steps):\n            qubits = bloqade_trotter_layer(qubits)\n        return qubits\n\n    return trotter_for_loop\n</pre> def factory_trotter(N: int, dt: float = 0.01, J: float = 1, h: float = 1) -&gt; Method:     bloqade_trotter_layer = load_circuit(         trotter_layer(qubits=cirq.LineQubit.range(N), dt=dt, J=J, h=h),         kernel_name=\"trotter\",         register_as_argument=True,         return_register=True,     )      @squin.kernel     def trotter_for_loop(steps: int) -&gt; Register:         \"\"\"         Main function that runs the Trotter circuit for a given number of steps         \"\"\"         qubits = squin.qalloc(N)         for _ in range(steps):             qubits = bloqade_trotter_layer(qubits)         return qubits      return trotter_for_loop <p>Alternatively, you could just write everything directly as a Bloqade kernel. Note that the ZZ operator that is native to Cirq must be expanded into its own \"helper\" kernel via a decomposition into cx / z / cx. The resulting kernel is fully parameterized, with the values not actually evaluated until runtime (or further compilation and folding).</p> In\u00a0[\u00a0]: Copied! <pre># Define an operator that looks like the ZZ power gate\n@squin.kernel\ndef op_zz(theta: float, qb1: bloqade.types.Qubit, qb2: bloqade.types.Qubit) -&gt; None:\n    \"\"\"\n    A kernel that returns an operator that looks like ZZ^{theta/2pi}\n    \"\"\"\n    squin.cx(qb1, qb2)\n    squin.rz(theta, qb2)\n    squin.cx(qb1, qb2)\n\n\n@squin.kernel\ndef bloqade_trotter(\n    N: int, steps: int, dt: float = 0.01, J: float = 1, h: float = 1\n) -&gt; Register:\n    \"\"\"\n    Main function that runs the Trotter circuit for a given number of steps\n    \"\"\"\n    qubits = squin.qalloc(N)\n    for _ in range(steps):\n        for i in range(0, len(qubits) - 1):\n            op_zz(theta=dt * J, qb1=qubits[i], qb2=qubits[i + 1])\n        for i in range(0, len(qubits)):\n            squin.rx(angle=dt * h, qubit=qubits[i])\n    return qubits\n</pre> # Define an operator that looks like the ZZ power gate @squin.kernel def op_zz(theta: float, qb1: bloqade.types.Qubit, qb2: bloqade.types.Qubit) -&gt; None:     \"\"\"     A kernel that returns an operator that looks like ZZ^{theta/2pi}     \"\"\"     squin.cx(qb1, qb2)     squin.rz(theta, qb2)     squin.cx(qb1, qb2)   @squin.kernel def bloqade_trotter(     N: int, steps: int, dt: float = 0.01, J: float = 1, h: float = 1 ) -&gt; Register:     \"\"\"     Main function that runs the Trotter circuit for a given number of steps     \"\"\"     qubits = squin.qalloc(N)     for _ in range(steps):         for i in range(0, len(qubits) - 1):             op_zz(theta=dt * J, qb1=qubits[i], qb2=qubits[i + 1])         for i in range(0, len(qubits)):             squin.rx(angle=dt * h, qubit=qubits[i])     return qubits <p>Of course, both Cirq and the (converted) Bloqade kernel have the same execution and same output state.</p> In\u00a0[\u00a0]: Copied! <pre>cirq_trotter = trotter_circuit(N=12, steps=10, dt=0.01, J=1, h=1)\n\ncirq_statevector = cirq.Simulator().simulate(cirq_trotter).state_vector()\n\n# Or converting to a bloqade kernel and simulating with PyQrack\ncirq_trotter_kernel = load_circuit(\n    cirq_trotter,\n    kernel_name=\"cirq_trotter\",\n    register_as_argument=False,\n    return_register=True,\n)\ncirq_trotter_qubits = (\n    StackMemorySimulator(min_qubits=12).task(cirq_trotter_kernel).run()\n)\ncirq_bloqade_state = StackMemorySimulator.quantum_state(cirq_trotter_qubits)\n# The state is, of course, the same. A little bit of work is needed to extract out the (single) state vector from the RDM.\nprint(\n    \"Overlap:\",\n    np.abs(np.dot(np.conj(cirq_statevector), cirq_bloqade_state.eigenvectors[:, 0]))\n    ** 2,\n)\n</pre> cirq_trotter = trotter_circuit(N=12, steps=10, dt=0.01, J=1, h=1)  cirq_statevector = cirq.Simulator().simulate(cirq_trotter).state_vector()  # Or converting to a bloqade kernel and simulating with PyQrack cirq_trotter_kernel = load_circuit(     cirq_trotter,     kernel_name=\"cirq_trotter\",     register_as_argument=False,     return_register=True, ) cirq_trotter_qubits = (     StackMemorySimulator(min_qubits=12).task(cirq_trotter_kernel).run() ) cirq_bloqade_state = StackMemorySimulator.quantum_state(cirq_trotter_qubits) # The state is, of course, the same. A little bit of work is needed to extract out the (single) state vector from the RDM. print(     \"Overlap:\",     np.abs(np.dot(np.conj(cirq_statevector), cirq_bloqade_state.eigenvectors[:, 0]))     ** 2, ) <p>Similarly, the execution and output state of the cirq state and kernel written fully in bloqade have the same state. Note that for the <code>bloqade_trotter</code> kernel, the arguments are not declared until the simulator is run.</p> In\u00a0[\u00a0]: Copied! <pre>cirq_trotter_qubits = StackMemorySimulator(min_qubits=12).run(\n    bloqade_trotter, args=(12, 10, 0.01, 1, 1)\n)\ncirq_bloqade_state = StackMemorySimulator.quantum_state(cirq_trotter_qubits)\nprint(\n    \"Overlap:\",\n    np.abs(np.dot(np.conj(cirq_statevector), cirq_bloqade_state.eigenvectors[:, 0]))\n    ** 2,\n)\n</pre> cirq_trotter_qubits = StackMemorySimulator(min_qubits=12).run(     bloqade_trotter, args=(12, 10, 0.01, 1, 1) ) cirq_bloqade_state = StackMemorySimulator.quantum_state(cirq_trotter_qubits) print(     \"Overlap:\",     np.abs(np.dot(np.conj(cirq_statevector), cirq_bloqade_state.eigenvectors[:, 0]))     ** 2, ) In\u00a0[\u00a0]: Copied! <pre>@squin.kernel\ndef t_teleport(target: squin.qubit.Qubit) -&gt; squin.qubit.Qubit:\n    ancilla = squin.qalloc(1)[0]\n    squin.h(ancilla)\n    squin.t(ancilla)\n    squin.cx(control=target, target=ancilla)\n    bit = squin.qubit.measure(target)\n    if bit:\n        squin.s(ancilla)\n    return ancilla  # The state of the target qubit is also teleported to the ancilla\n\n\n# And now let\u2019s wrap it into a larger context to run. In this case,\n# apply to a |+&gt; state and see that we get a T|+&gt; state out.\n@squin.kernel\ndef t_teleport_wrapper() -&gt; squin.qubit.Qubit:\n\n    target = squin.qalloc(1)[0]\n    squin.h(target)\n    target = t_teleport(target)\n    return target\n\n\n# And run it. Observe that the batch_state uses a qubit_map to select which qubits to include in the batch state.\n# This is important because there are two qubits total (the target and the ancilla) but we only want inspect\n# the state of the output qubit.\nemulator = StackMemorySimulator(min_qubits=2)\ntask = emulator.task(t_teleport_wrapper)\nstate = task.batch_state(shots=1000, qubit_map=lambda x: [x])\n# Even though there is measurement and feedforward, the final state is still pure. Neat!\nprint(state)\n</pre> @squin.kernel def t_teleport(target: squin.qubit.Qubit) -&gt; squin.qubit.Qubit:     ancilla = squin.qalloc(1)[0]     squin.h(ancilla)     squin.t(ancilla)     squin.cx(control=target, target=ancilla)     bit = squin.qubit.measure(target)     if bit:         squin.s(ancilla)     return ancilla  # The state of the target qubit is also teleported to the ancilla   # And now let\u2019s wrap it into a larger context to run. In this case, # apply to a |+&gt; state and see that we get a T|+&gt; state out. @squin.kernel def t_teleport_wrapper() -&gt; squin.qubit.Qubit:      target = squin.qalloc(1)[0]     squin.h(target)     target = t_teleport(target)     return target   # And run it. Observe that the batch_state uses a qubit_map to select which qubits to include in the batch state. # This is important because there are two qubits total (the target and the ancilla) but we only want inspect # the state of the output qubit. emulator = StackMemorySimulator(min_qubits=2) task = emulator.task(t_teleport_wrapper) state = task.batch_state(shots=1000, qubit_map=lambda x: [x]) # Even though there is measurement and feedforward, the final state is still pure. Neat! print(state) In\u00a0[\u00a0]: Copied! <pre>def ghz_constant_depth(n_qubits: int):\n\n    @squin.kernel\n    def main() -&gt; Register:\n        qreg = squin.qalloc(n_qubits)\n        ancilla = squin.qalloc(n_qubits - 1)\n\n        for i in range(n_qubits):\n            squin.h(qreg[i])\n\n        for i in range(n_qubits - 1):\n            squin.cx(qreg[i], ancilla[i])\n        for i in range(n_qubits - 1):\n            squin.cx(qreg[i + 1], ancilla[i])\n\n        parity: int = 0\n        bits = squin.broadcast.measure(ancilla)\n        for i in range(n_qubits - 1):\n            parity = parity ^ bits[i]\n            if parity == 1:\n                squin.x(qreg[i + 1])\n        return qreg\n\n    return main\n</pre> def ghz_constant_depth(n_qubits: int):      @squin.kernel     def main() -&gt; Register:         qreg = squin.qalloc(n_qubits)         ancilla = squin.qalloc(n_qubits - 1)          for i in range(n_qubits):             squin.h(qreg[i])          for i in range(n_qubits - 1):             squin.cx(qreg[i], ancilla[i])         for i in range(n_qubits - 1):             squin.cx(qreg[i + 1], ancilla[i])          parity: int = 0         bits = squin.broadcast.measure(ancilla)         for i in range(n_qubits - 1):             parity = parity ^ bits[i]             if parity == 1:                 squin.x(qreg[i + 1])         return qreg      return main In\u00a0[\u00a0]: Copied! <pre># At this point, you know the drill. We can simulate this with multirun via PyQrack\nemulator = StackMemorySimulator(min_qubits=7)\ntask = emulator.task(ghz_constant_depth(3))\n\nstate = task.batch_state(shots=1000, qubit_map=lambda x: x)\n# Even though there is measurement and feedforward, the final state is still pure. Neat!\nprint(state.eigenvalues)\n</pre> # At this point, you know the drill. We can simulate this with multirun via PyQrack emulator = StackMemorySimulator(min_qubits=7) task = emulator.task(ghz_constant_depth(3))  state = task.batch_state(shots=1000, qubit_map=lambda x: x) # Even though there is measurement and feedforward, the final state is still pure. Neat! print(state.eigenvalues) <p>As a final note, consider how difficult it would be to represent this circuit in Cirq. In particular, there is a for loop, where inside the for loop there is an algebraic operation (XOR) that feeds forward onto a variable (parity). This circuit is very hard to express in Cirq without some serious hacking of ancilla registers.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#circuits-with-bloqade","title":"Circuits with Bloqade\u00b6","text":"<p>In this tutorial we will demonstrate how to write circuits and quantum executions with Bloqade. Specifically, we will use the <code>squin</code> dialect set from the compiler toolchain <code>kirin</code>. <code>SQUIN</code> stands for <code>S</code>tructural <code>Qu</code>antum <code>IN</code>struction set and is the circuit-level representation of quantum executions. It is built on top of the <code>kirin</code> framework, an open-source compiler toolchain for embedded domain-specific languages (eDSLs) that target scientific computing kernels. A key feature of squin is the kernel, which can roughly be seen as the object which will be executed on the target hardware. Naturally, this hardware could be a quantum computer, but it also extends to classical execution as well, such as mid-circuit feedforward or even non-quantum execution such as robotics.</p> <p>These kernels can be built using decorators of python functions. We will use the <code>@squin.kernel</code> decorator in this notebook but keep in mind that other eDSLs have different decorators inherited from base Kirin decorators. The decorator lowers Python's abstract syntax tree (AST) into a kirin SSA (single static assignment) form, which is a useful intermediate representation for compiler analysis. You don't have to worry too much about SSA or compilers here, but if you want to learn more check out the kirin documentation.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#anatomy-of-a-bloqade-kernel","title":"Anatomy of a Bloqade kernel\u00b6","text":"<p>A kernel is a representation of a hybrid quantum/classical execution that will run \"on hardware\". The decorator @squin.kernel can be considered as the \"label\" to represent this fact. A kernel can take arguments (such as <code>theta</code> here) and can return values (such as <code>bits</code> here). To help the compiler, the inputs and outputs must be decorated with a type. The return values can be considered as the \"results\" which are returned from the quantum computer, though they can also be intermediate values that are used as a part of a larger computation (e.g. a function call). A kernel can represent both quantum and classical execution: while lots of classical computation is supported (control flow, algebra, etc.) there is less support for arbitrary python calls, as this won't necessarily be supported on the microcontroller \"on hardware\". Note that shot-level execution and averaging is handled outside of the kernel itself: averaging over multiple shots within a kernel is an anti-pattern to avoid.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#squin-kernel-statements","title":"Squin kernel statements\u00b6","text":"<p>To represent quantum executions, we write and construct squin kernels. These kernels can use the typical structure of python functions -- inputs, outputs, for loops, control flow, subroutines, and so forth -- as a feature of the underlying base Kirin statements. Because one can intermix control flow with operations and measurement, arbitrary mid-circuit feed forward comes for \"free\".</p> <p>There are three dialects that comprise the domain-specific language</p> <ol> <li><code>squin.qubit</code> - Manipulation and declaration of the qubits themselves, mainly allocating new ones and measuring them.</li> <li><code>squin.gate</code> - Application of quantum gates on qubits.</li> <li><code>squin.noise</code> - Representing noise effects on the qubits.</li> </ol> <p>While you can interact with <code>squin.qubit</code> directly, the other two dialects are exposed via wrapper functions that are available directly under the <code>squin</code> namespace, or under <code>squin.broadcast</code> for parallelized versions of the gates and noise processes, respectively.</p> <p>Refer to the API documentation for a full list of the available functionality. Note that you are also able to define your own custom gates by defining similar functions.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#using-bloqade-kernels","title":"Using Bloqade kernels\u00b6","text":"<p>A key feature of kernels is the ability to do complex control flow similar to how one might program python. For example, one can use a for loop to apply the same gate to multiple qubits to prepare a GHZ state.</p> <p>A useful pattern is to use factory functions that return bloqade kernels. This way, you can fix parameters (such as the number of qubits) pythonically without needing to introduce the variable directly into the kernel itself, using a closure.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#building-circuits-in-cirq","title":"Building circuits in Cirq\u00b6","text":"<p>Instead of writing your circuit directly in bloqade, you may build circuits using Cirq and then lower them to and from bloqade kernels. This has the advantage of being able to leverage the excellent and in-depth resources of transpilation and circuit optimization without having to reinvent the wheel. However, for certain programs, such as those requiring more complex mid-circuit feed-forward, it is still required to write bloqade kernels as there is no adequate representation in other SDKs. Cirq is our initial choice of SDK, and other transformations are coming soon-- though in principle interoperability with many SDK is possible through an intermediate Cirq representation.</p> <p>Let us begin by writing a simple GHZ state preparation circuit, in analogy to the bloqade kernel above. Observe that the resulting object is a static representation of a circuit, similar to the <code>GHZ_state</code> kernel, and differentiated from the dynamic <code>GHZ_state_factory</code> kernel which can return a dynamically sized GHZ state.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#simulation-emulation-and-analysis","title":"Simulation, emulation, and analysis\u00b6","text":"<p>A kernel is simply a representation of an execution and is not much use without being able to analyze and execute that kernel. We can simulate the action of kernels using concrete interpreters. The emulator must a) keep track of the classical state of the variables, b) keep track of the quantum state of the qubits, and thus c) faithfully represent the execution of that program as if it was run on a hybrid quantum/classical computer. Bloqade's emulator is built on top of the excellent PyQrack quantum simulator and satisfies the three goals above.</p> <p>There are four main objects when considering simulation:</p> <ol> <li>The emulator object - Representing the thing that some kernel is going to be executed on. Today it is the PyQrack simulator, but eventually it could also include other simulators or physical hardware. The <code>*.task</code> method of the <code>emulator</code> object builds a <code>task</code> object.</li> <li>The task object - Binding together the emulator, kernel, and input parameters for that kernel. This task is not executed until the <code>*.run</code> method is called. Upon calling <code>run</code>, the kernel is interpreted, the quantum circuit is executed, any classical co-processing is done, and the kernel completes, returning . Repeated calling of <code>run</code> will \"reset\" the executor into its initial state and rerun the kernel. Alternatively, one could call <code>*.batch_run</code> to repeatedly run the kernel's result to get stochastic averaging. Products of the task include the <code>results</code> and <code>QuantumState</code> objects.</li> <li>The results object - Whatever the <code>return</code> of the kernel is returned, with the same type signature. This is generated from <code>*run()</code> (as a ResultType) or <code>*.batch_run</code> (as a dict keyed by ResultType and valued by frequency) These could be qubits or qubit registers (list of qubits), values, or whatever object you like.</li> <li>The QuantumState object - The final quantum state of the emulator object. While this is a nonphysical quantity, the QuantumState is useful for debugging and analysis. This can be extracted from either the <code>emulator.quantum_state</code> method (for a single run after the <code>run()</code> method), or with <code>task.batch_state</code> (for a stochastic average over many samples). The quantum state is efficiently represented as an eigensystem of a reduced density matrix.</li> </ol>"},{"location":"digital/tutorials/circuits_with_bloqade/#extracting-quantum-states","title":"Extracting quantum states\u00b6","text":"<p>PyQRack is mainly intended as an emulator, attempting to recreate the physical action and interaction of quantum hardware with classical controls. However, it is often useful for user analysis and debugging to extract out non-physical values, such as the quantum statevector, fidelity, or exact expectation values of observables and correlation functions.</p> <p>These nonphysical values are based in being able to directly observe and evaluate the quantum state. The state can be extracted via the <code>PyQrackSimulator.quantum_state</code> method, with an input signature of a list of (pyqrack) qubits. These qubits can be generated as a return value from a kernel (as is the case for the <code>GHZ_state_factory</code> function) or from the <code>task.qubits()</code> method.</p> <p>The resulting state is a reduced density matrix represented by its eigensystem of eigenvalues and eigenvectors, or a dense $2^N \\times 2^N$ array.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#composition-of-kernels","title":"Composition of kernels\u00b6","text":"<p>Bloqade kernels allow all the typical syntax of for loops, if-else statements, function calls, and other powerful abstractions. Let us use this to write efficient representations of complex circuits.</p> <p>For this example, we will use a Trotterization of the 1d Transverse Ising model.</p> <p>The first option we will explore is to write the entire circuit in Cirq and then convert it into a bloqade kernel using the <code>load_circuit</code> lowering. Observe that the return objects of these builder functions are static objects.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#mid-circuit-feed-forward","title":"Mid-circuit feed forward\u00b6","text":"<p>Bloqade kernels can natively represent mid-circuit feed-forward using control flow represented by standard pythonic if-else and while structures. While the possibilities are endless, including measurement-based quantum computing and error correction, we show two examples here.</p> <p>The first is T state teleportation, which teleports a T gate that was applied to an ancilla (a \"T state\") onto the target state using only Clifford gates and feedforward. Due to the property of being Clifford, the circuit itself is fault tolerant and thus plays an important role in many error corrected algorithms.</p>"},{"location":"digital/tutorials/circuits_with_bloqade/#constant-depth-ghz-state","title":"Constant depth GHZ state\u00b6","text":"<p>Remarkably, it is also possible to prepare a GHZ state with a constant number of gates. At first glance, this seems impossible: quantum information can only propagate as fast as the information lightcone, and so a constant depth circuit can only have a small amount of entanglement\u2014not enough to prepare the long-range correlated GHZ state. The trick is, we can replace quantum gates with ancillas and classical feedforward measurements so that the information is propagated classically instead of quantumly. For more details, check out [1] and [2].</p> <p>[1] Efficient Long-Range Entanglement Using Dynamic Circuits</p> <p>[2] Constant-Depth Preparation of Matrix Product States with Adaptive Quantum Circuits</p> <p>The explicit circuit for the GHZ circuit is shown in Fig. 5 of [1]. There is classical feedforward in the form of a parity check, which requires a classical XOR operation that is irrepresentable by CIRQ.</p>"},{"location":"quick_start/analog/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"quick_start/analog/#bloqade-analog-quick-start","title":"Bloqade Analog Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"quick_start/analog/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.analog.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade.analog import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"quick_start/analog/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade.analog import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"quick_start/analog/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade.analog import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"quick_start/analog/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"quick_start/analog/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade.analog import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"quick_start/analog/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"quick_start/analog/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"quick_start/analog/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"quick_start/analog/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade.analog import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"quick_start/analog/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade.analog import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade.analog import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"quick_start/analog/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade.analog import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade.analog import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"quick_start/circuits/","title":"Digital Quantum Computing with bloqade","text":"<p>This section provides the quick start guide for developing quantum programs represented by circuits using Bloqade. Circuits are a general-purpose and powerful way of representing arbitrary computations. For a few examples please refer to our examples.</p>"},{"location":"quick_start/circuits/#pick-your-frontend-choose-a-dsl","title":"Pick your frontend: choose a DSL","text":"<p>bloqade-circuit provides a number of different domain specific languages (DSLs) for writing quantum programs. If you are unsure which one to choose, head over to the DSL documentation for an overview of all available ones.</p> <p>If you are looking to write a circuit, we recommend giving SQUIN a go. Here's an example of how you would write a simple GHZ preparation circuit:</p> <pre><code>from bloqade import squin\n\n@squin.kernel\ndef ghz(n: int):\n    q = squin.qalloc(n)\n    squin.h(q[0])\n    for i in range(1, n):\n        squin.cx(q[i - 1], q[i])\n</code></pre> <p>One of the features here is that the SQUIN DSL support control flow, such as for loops, which allows you to write your programs in a concise way. At some point, before execution on hardware, such a loop will have to be unrolled. However, you can let the compiler worry about that and use it as a high-level feature.</p>"},{"location":"quick_start/circuits/#optimize-your-program","title":"Optimize your program","text":"<p>Note</p> <p>This step is optional and you may just skip ahead to choosing your backend.</p> <p>When you define a program, such as the one above, it creates an intermediate representation (IR) of that program. In the above, since <code>ghz</code> is annotated with the <code>@squin.kernel</code> decorator, it is not a function, but a <code>Method</code> object that stores the IR of the GHZ program.</p> <p>You can run different optimizations and compiler passes on your IR in order to tailor your program to run optimally on the chosen backend.</p> <p>While it is possible to write your own compiler passes and optimizations - for that, please refer to the kirin documentation - bloqade-circuit also offers a number of different, pre-defined optimizations.</p> <p>Warning</p> <p>Compiler and optimization passes are currently under development. While quite a lot of them are used internally, they are not in a user-friendly state. Please skip this step for the time being.</p>"},{"location":"quick_start/circuits/#pick-your-backend-simulation-and-hardware","title":"Pick your backend: simulation and hardware","text":"<p>Once you have your program written and optimized to a point at which you are satisfied, it is time to think about execution. Bloqade Digital is a hardware-first SDK, which means that simulation tries to mirror execution on hardware as closely as possible. Choosing the hardware you want to run on is therefore mostly interchangeable with simulator backends.</p>"},{"location":"quick_start/circuits/#simulation-with-pyqrack","title":"Simulation with PyQrack","text":"<p>In order to simulate your quantum program, bloqade-circuit integrates with the Qrack simulator via its Python bindings. Let's run a simulation of the above GHZ program:</p> <pre><code>from bloqade.pyqrack import StackMemorySimulator\nsim = StackMemorySimulator(min_qubits=4)\nsim.run(ghz, args=(4,))  # need to pass in function arguments separately\n</code></pre> <p>There are also some things available in the simulator which cannot be obtained when running on hardware, such as the actual state vector of the system:</p> <pre><code>sim.state_vector(ghz, args=(4,))\n</code></pre>"},{"location":"quick_start/circuits/#hardware-execution","title":"Hardware execution","text":"<p>Note</p> <p>We're all very excited for this part, but we will have to wait just a bit longer for it to become available. Stay tuned!</p>"},{"location":"quick_start/circuits/#further-reading-and-examples","title":"Further reading and examples","text":"<p>For more details on domain specific languages available in bloqade-circuits, please refer to the dedicated documentation section on dialects. We also recommend that you check out our collection of examples, where we show some more advanced usage examples.</p> <p>There is also some more documentation available on the PyQrack simulation backend.</p> <p>Finally, if you want to learn more about compilation and compiler passes, please refer to this documentation page. We also highly recommend that you have a look at the kirin framework.</p>"},{"location":"reference/","title":"API Reference","text":"<p>Here you can find a full API reference grouped by the respective submodules of bloqade:</p> <ul> <li><code>bloqade-circuit</code></li> <li><code>bloqade-analog</code></li> </ul> <p>Please note that the reference is auto-generated and therefore follows the structure of the code. You can use the navigation on the left to browse through the full API reference or use the search functionality.</p>"},{"location":"reference/SUMMARY_BLOQADE_ANALOG/","title":"SUMMARY BLOQADE ANALOG","text":"<ul> <li>src<ul> <li>bloqade<ul> <li>analog<ul> <li>atom_arrangement</li> <li>builder<ul> <li>args</li> <li>assign</li> <li>backend<ul> <li>bloqade</li> <li>braket</li> <li>quera</li> </ul> </li> <li>coupling</li> <li>drive</li> <li>field</li> <li>parallelize</li> <li>parse<ul> <li>builder</li> <li>stream</li> <li>trait</li> </ul> </li> <li>pragmas</li> <li>route</li> <li>sequence_builder</li> <li>spatial</li> <li>start</li> <li>typing</li> <li>waveform</li> </ul> </li> <li>compiler<ul> <li>analysis<ul> <li>common<ul> <li>assignment_scan</li> <li>check_slices</li> <li>is_constant</li> <li>is_hyperfine</li> <li>scan_channels</li> <li>scan_variables</li> </ul> </li> <li>hardware<ul> <li>channels</li> <li>lattice</li> <li>piecewise_constant</li> <li>piecewise_linear</li> </ul> </li> <li>python<ul> <li>waveform</li> </ul> </li> </ul> </li> <li>passes<ul> <li>emulator</li> <li>hardware<ul> <li>components</li> <li>define</li> <li>units</li> </ul> </li> </ul> </li> <li>rewrite<ul> <li>common<ul> <li>add_padding</li> <li>assign_to_literal</li> <li>assign_variables</li> <li>canonicalize</li> <li>flatten</li> </ul> </li> <li>python<ul> <li>waveform</li> </ul> </li> </ul> </li> </ul> </li> <li>constants</li> <li>emulate<ul> <li>ir<ul> <li>atom_type</li> <li>emulator</li> <li>space</li> <li>state_vector</li> </ul> </li> <li>sparse_operator</li> </ul> </li> <li>factory</li> <li>ir<ul> <li>analog_circuit</li> <li>control<ul> <li>field</li> <li>pulse</li> <li>sequence</li> <li>traits<ul> <li>append</li> <li>canonicalize</li> <li>hash</li> <li>slice</li> </ul> </li> <li>waveform</li> </ul> </li> <li>location<ul> <li>bravais</li> <li>location</li> </ul> </li> <li>routine<ul> <li>base</li> <li>bloqade</li> <li>braket</li> <li>params</li> <li>quera</li> </ul> </li> <li>scalar</li> </ul> </li> <li>migrate</li> <li>serialize</li> <li>submission<ul> <li>base</li> <li>braket</li> <li>ir<ul> <li>braket</li> <li>capabilities</li> <li>parallel</li> <li>task_results</li> <li>task_specification</li> </ul> </li> <li>load_config</li> <li>mock</li> <li>quera</li> </ul> </li> <li>task<ul> <li>base</li> <li>batch</li> <li>bloqade</li> <li>braket</li> <li>braket_simulator</li> <li>exclusive</li> <li>quera</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/SUMMARY_BLOQADE_CIRCUIT/","title":"SUMMARY BLOQADE CIRCUIT","text":"<ul> <li>src<ul> <li>bloqade<ul> <li>analysis<ul> <li>address<ul> <li>analysis</li> <li>impls</li> <li>lattice</li> </ul> </li> <li>fidelity<ul> <li>analysis</li> </ul> </li> <li>measure_id<ul> <li>analysis</li> <li>impls</li> <li>lattice</li> </ul> </li> </ul> </li> <li>annotate<ul> <li>stmts</li> <li>types</li> </ul> </li> <li>cirq_utils<ul> <li>emit<ul> <li>base</li> <li>gate</li> <li>noise</li> <li>qubit</li> </ul> </li> <li>lineprog</li> <li>lowering</li> <li>noise<ul> <li>conflict_graph</li> <li>model</li> <li>transform</li> </ul> </li> <li>parallelize</li> </ul> </li> <li>device</li> <li>gemini<ul> <li>analysis<ul> <li>logical_validation<ul> <li>analysis</li> <li>impls</li> </ul> </li> </ul> </li> <li>groups</li> </ul> </li> <li>native<ul> <li>dialects<ul> <li>gate<ul> <li>stmts</li> </ul> </li> </ul> </li> <li>stdlib<ul> <li>broadcast</li> <li>simple</li> </ul> </li> <li>upstream<ul> <li>squin2native</li> </ul> </li> </ul> </li> <li>pyqrack<ul> <li>base</li> <li>device</li> <li>native</li> <li>noise<ul> <li>native</li> </ul> </li> <li>qasm2<ul> <li>core</li> <li>glob</li> <li>parallel</li> <li>uop</li> </ul> </li> <li>reg</li> <li>squin<ul> <li>gate<ul> <li>gate</li> </ul> </li> <li>noise<ul> <li>native</li> </ul> </li> <li>qubit</li> </ul> </li> <li>target</li> <li>task</li> </ul> </li> <li>qasm2<ul> <li>dialects<ul> <li>core<ul> <li>address</li> <li>stmts</li> </ul> </li> <li>expr<ul> <li>stmts</li> </ul> </li> <li>glob</li> <li>indexing</li> <li>inline</li> <li>noise<ul> <li>fidelity</li> <li>model</li> <li>stmts</li> </ul> </li> <li>parallel</li> <li>uop<ul> <li>schedule</li> <li>stmts</li> </ul> </li> </ul> </li> <li>emit<ul> <li>base</li> <li>gate</li> <li>impls<ul> <li>noise</li> </ul> </li> <li>main</li> <li>target</li> </ul> </li> <li>glob</li> <li>groups</li> <li>noise</li> <li>parallel</li> <li>parse<ul> <li>ast</li> <li>build</li> <li>lowering</li> <li>parser</li> <li>print</li> <li>visitor</li> </ul> </li> <li>passes<ul> <li>fold</li> <li>glob</li> <li>lift_qubits</li> <li>noise</li> <li>parallel</li> <li>py2qasm</li> <li>qasm2py</li> <li>unroll_if</li> </ul> </li> <li>rewrite<ul> <li>desugar</li> <li>glob</li> <li>insert_qubits</li> <li>native_gates</li> <li>noise<ul> <li>heuristic_noise</li> <li>remove_noise</li> </ul> </li> <li>parallel_to_glob</li> <li>parallel_to_uop</li> <li>register</li> <li>uop_to_parallel</li> </ul> </li> <li>types</li> </ul> </li> <li>qbraid<ul> <li>lowering</li> <li>schema</li> <li>simulation_result</li> <li>target</li> </ul> </li> <li>qubit<ul> <li>analysis<ul> <li>address_impl</li> </ul> </li> <li>stdlib<ul> <li>broadcast</li> <li>simple</li> </ul> </li> <li>stmts</li> </ul> </li> <li>rewrite<ul> <li>passes<ul> <li>aggressive_unroll</li> <li>callgraph</li> <li>canonicalize_ilist</li> </ul> </li> <li>rules<ul> <li>split_ifs</li> </ul> </li> </ul> </li> <li>squin<ul> <li>analysis<ul> <li>schedule</li> </ul> </li> <li>gate<ul> <li>stmts</li> </ul> </li> <li>groups</li> <li>noise<ul> <li>stmts</li> </ul> </li> <li>rewrite<ul> <li>U3_to_clifford</li> <li>remove_dangling_qubits</li> <li>wrap_analysis</li> </ul> </li> <li>stdlib<ul> <li>broadcast<ul> <li>gate</li> <li>noise</li> </ul> </li> <li>simple<ul> <li>gate</li> <li>noise</li> </ul> </li> </ul> </li> </ul> </li> <li>stim<ul> <li>dialects<ul> <li>auxiliary<ul> <li>emit</li> <li>interp</li> <li>lowering</li> <li>stmts<ul> <li>annotate</li> <li>const</li> </ul> </li> <li>types</li> </ul> </li> <li>collapse<ul> <li>emit_str</li> <li>stmts<ul> <li>measure</li> <li>pp_measure</li> <li>reset</li> </ul> </li> </ul> </li> <li>gate<ul> <li>emit</li> <li>stmts<ul> <li>base</li> <li>clifford_1q</li> <li>clifford_2q</li> <li>control_2q</li> <li>pp</li> </ul> </li> </ul> </li> <li>noise<ul> <li>emit</li> <li>stmts</li> </ul> </li> </ul> </li> <li>emit<ul> <li>impls</li> <li>stim_str</li> </ul> </li> <li>groups</li> <li>parse<ul> <li>lowering</li> </ul> </li> <li>passes<ul> <li>flatten</li> <li>simplify_ifs</li> <li>squin_to_stim</li> </ul> </li> <li>rewrite<ul> <li>get_record_util</li> <li>ifs_to_stim</li> <li>py_constant_to_stim</li> <li>qubit_to_stim</li> <li>set_detector_to_stim</li> <li>set_observable_to_stim</li> <li>squin_measure</li> <li>squin_noise</li> <li>util</li> </ul> </li> <li>upstream<ul> <li>from_squin</li> </ul> </li> </ul> </li> <li>task</li> <li>types</li> <li>validation<ul> <li>analysis<ul> <li>analysis</li> <li>lattice</li> </ul> </li> <li>kernel_validation</li> </ul> </li> <li>visual<ul> <li>animation<ul> <li>animate</li> <li>base</li> <li>gate_event</li> <li>runtime<ul> <li>aod</li> <li>atoms</li> <li>ppoly</li> <li>qpustate</li> <li>utils</li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.RB_C6","title":"RB_C6  <code>module-attribute</code>","text":"<pre><code>RB_C6 = 2 * pi * 862690\n</code></pre> <p>The C6 constant for the Rydberg Interaction of two Rubidium atoms in units of: rad \u03bcm^6/\u03bcs</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty [<code>ListOfLocations</code>][bloqade.ir.location.list.ListOfLocations].</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for [<code>Rydberg</code>][bloqade.builder.coupling.Rydberg]     Level coupling</li> <li><code>start.hyperfine</code>: for [<code>Hyperfine</code>][bloqade.builder.coupling.Hyperfine]     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li>[<code>Scalar</code>][bloqade.ir.scalar.Scalar] objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.Literal","title":"Literal","text":"<p>               Bases: <code>Real</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.Literal[Literal]\n              bloqade.analog.ir.scalar.Real[Real]\n              bloqade.analog.ir.scalar.Scalar[Scalar]\n\n                              bloqade.analog.ir.scalar.Real --&gt; bloqade.analog.Literal\n                                bloqade.analog.ir.scalar.Scalar --&gt; bloqade.analog.ir.scalar.Real\n                \n\n\n\n              click bloqade.analog.Literal href \"\" \"bloqade.analog.Literal\"\n              click bloqade.analog.ir.scalar.Real href \"\" \"bloqade.analog.ir.scalar.Real\"\n              click bloqade.analog.ir.scalar.Scalar href \"\" \"bloqade.analog.ir.scalar.Scalar\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Decimal\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.Variable","title":"Variable","text":"<p>               Bases: <code>Real</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.Variable[Variable]\n              bloqade.analog.ir.scalar.Real[Real]\n              bloqade.analog.ir.scalar.Scalar[Scalar]\n\n                              bloqade.analog.ir.scalar.Real --&gt; bloqade.analog.Variable\n                                bloqade.analog.ir.scalar.Scalar --&gt; bloqade.analog.ir.scalar.Real\n                \n\n\n\n              click bloqade.analog.Variable href \"\" \"bloqade.analog.Variable\"\n              click bloqade.analog.ir.scalar.Real href \"\" \"bloqade.analog.ir.scalar.Real\"\n              click bloqade.analog.ir.scalar.Scalar href \"\" \"bloqade.analog.ir.scalar.Scalar\"\n            </code></pre> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.cast","title":"cast","text":"<pre><code>cast(py) -&gt; Scalar\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to [<code>Scalar Literal</code>][bloqade.ir.scalar.Literal].</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to [<code>Scalar Variable</code>][bloqade.ir.scalar.Variable].</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.constant","title":"constant","text":"<pre><code>constant(\n    duration: ScalarType, value: ScalarType\n) -&gt; Constant\n</code></pre> <p>Create a Constant waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of the Constant waveform.</p> required <code>value</code> <code>ScalarType</code> <p>Value of the Constant waveform.s</p> required <p>Returns:</p> Name Type Description <code>Constant</code> <code>Constant</code> <p>A Constant waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef constant(duration: ScalarType, value: ScalarType) -&gt; Constant:\n    \"\"\"Create a Constant waveform.\n\n    Args:\n        duration (ScalarType): Duration of the Constant waveform.\n        value (ScalarType): Value of the Constant waveform.s\n\n    Returns:\n        Constant: A Constant waveform.\n    \"\"\"\n    return Constant(value, duration)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.dumps","title":"dumps","text":"<pre><code>dumps(\n    o: Any, use_decimal: bool = True, **json_kwargs\n) -&gt; str\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef dumps(\n    o: Any,\n    use_decimal: bool = True,\n    **json_kwargs,\n) -&gt; str:\n    \"\"\"Serialize object to string\n\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    return json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities(\n    use_experimental: bool = False,\n) -&gt; QuEraCapabilities\n</code></pre> <p>Get the device capabilities for Aquila</p> <p>Parameters:</p> Name Type Description Default <code>use_experimental</code> <code>bool</code> <p>Get experimental capabilities instead of standard ones. By default value is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>QuEraCapabilities</code> <code>QuEraCapabilities</code> <p>capabilities object for Aquila device.</p> Note <p>Units of time, distance, and energy are microseconds (us), micrometers (um), and rad / us, respectively.</p> <p>For a comprehensive list of capabilities, see the Hardware Reference page</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>def get_capabilities(use_experimental: bool = False) -&gt; \"QuEraCapabilities\":\n    \"\"\"Get the device capabilities for Aquila\n\n    Args:\n        use_experimental (bool): Get experimental capabilities instead of\n            standard ones. By default value is False.\n\n    Returns:\n        QuEraCapabilities: capabilities object for Aquila device.\n\n\n    Note:\n        Units of time, distance, and energy are microseconds (us),\n        micrometers (um), and rad / us, respectively.\n\n        For a comprehensive list of capabilities,\n        see the [Hardware Reference](../../reference/hardware-capabilities.md)\n        page\n    \"\"\"\n\n    from bloqade.analog.submission.capabilities import get_capabilities\n\n    # manually convert to units\n    return get_capabilities(use_experimental=use_experimental).scale_units(\n        Decimal(\"1e6\"), Decimal(\"1e-6\")\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.linear","title":"linear","text":"<pre><code>linear(\n    duration: ScalarType,\n    start: ScalarType,\n    stop: ScalarType,\n) -&gt; Linear\n</code></pre> <p>Create a Linear waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of linear waveform</p> required <code>start</code> <code>ScalarType</code> <p>Starting value of linear waveform</p> required <code>stop</code> <code>ScalarType</code> <p>Ending value of linear waveform</p> required <p>Returns:</p> Name Type Description <code>Linear</code> <code>Linear</code> <p>Linear waveform</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef linear(duration: ScalarType, start: ScalarType, stop: ScalarType) -&gt; Linear:\n    \"\"\"Create a Linear waveform.\n\n    Args:\n        duration (ScalarType): Duration of linear waveform\n        start (ScalarType): Starting value of linear waveform\n        stop (ScalarType): Ending value of linear waveform\n\n    Returns:\n        Linear: Linear waveform\n    \"\"\"\n    return Linear(start, stop, duration)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.load","title":"load","text":"<pre><code>load(\n    fp: Union[TextIO, str],\n    use_decimal: bool = True,\n    **json_kwargs\n)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from file\n\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    if isinstance(fp, str):\n        with open(fp, \"r\") as f:\n            return json.load(\n                f,\n                object_hook=Serializer.object_hook,\n                use_decimal=use_decimal,\n                **json_kwargs,\n            )\n    else:\n        return json.load(\n            fp,\n            object_hook=Serializer.object_hook,\n            use_decimal=use_decimal,\n            **json_kwargs,\n        )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.loads","title":"loads","text":"<pre><code>loads(s: str, use_decimal: bool = True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from string\n\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    return json.loads(\n        s, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise constant waveform from a list of durations and values. The value <code>duration[i]</code> corresponds to the length of time for the i'th segment with a value of <code>values[i]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not the same as the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise constant waveform from a list of durations and values. The\n    value `duration[i]` corresponds to the length of time for the i'th segment\n    with a value of `values[i]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not the same as the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n    if len(durations) != len(values):\n        raise ValueError(\n            \"The length of values must be the same as the length of durations\"\n        )\n\n    if len(durations) == 0:\n        raise ValueError(\"The durations and values lists must not be empty.\")\n\n    pwc_wf = Constant(values[0], durations[0])\n    for duration, value in zip(durations[1:], values[1:]):\n        pwc_wf = pwc_wf.append(Constant(value, duration))\n\n    return pwc_wf\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise linear waveform from a list of durations and values. The value <code>duration[i]</code> is of the linear segment between <code>values[i]</code> and <code>values[i+1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not one greater than the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef piecewise_linear(durations: List[ScalarType], values: List[ScalarType]) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise linear waveform from a list of durations and values. The\n    value `duration[i]` is of the linear segment between `values[i]` and `values[i+1]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not one greater than the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n\n    if len(durations) + 1 != len(values):\n        raise ValueError(\n            \"The length of values must be one greater than the length of durations\"\n        )\n\n    if len(durations) == 0:\n        raise ValueError(\"The durations and values lists must not be empty.\")\n\n    pwl_wf = Linear(values[0], values[1], durations[0])\n    for duration, start, stop in zip(durations[1:], values[1:-1], values[2:]):\n        pwl_wf = pwl_wf.append(Linear(start, stop, duration))\n\n    return pwl_wf\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.rydberg_h","title":"rydberg_h","text":"<pre><code>rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[\n        List[Dict[str, Any]], Dict[str, Any]\n    ] = [],\n    args: List[str | Variable] = [],\n) -&gt; Routine\n</code></pre> <p>Create a rydberg program with uniform detuning, amplitude, and phase.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_positions</code> <code>Any</code> <p>Description of geometry of atoms in system.</p> required <code>detuning</code> <code>Optional[Waveform]</code> <p>Waveform for detuning. Defaults to None.</p> <code>None</code> <code>amplitude</code> <code>Optional[Waveform]</code> <p>Waveform describing the amplitude of the rabi term. Defaults to None.</p> <code>None</code> <code>phase</code> <code>Optional[Waveform]</code> <p>Waveform describing the phase of rabi term. Defaults to None.</p> <code>None</code> <code>static_params</code> <code>Dict[str, Any]</code> <p>Define static parameters of your program. Defaults to {}.</p> <code>{}</code> <code>batch_params</code> <code>Union[List[Dict[str, Any]], Dict[str, Any]]</code> <p>Parmaters for a batch of tasks. Defaults to [].</p> <code>[]</code> <code>args</code> <code>List[str]</code> <p>List of arguments to leave till runtime. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>An object that can be used to dispatch a rydberg program to multiple backends.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[List[Dict[str, Any]], Dict[str, Any]] = [],\n    args: List[str | Variable] = [],\n) -&gt; Routine:\n    \"\"\"Create a rydberg program with uniform detuning, amplitude, and phase.\n\n    Args:\n        atoms_positions (Any): Description of geometry of atoms in system.\n        detuning (Optional[Waveform], optional): Waveform for detuning.\n            Defaults to None.\n        amplitude (Optional[Waveform], optional): Waveform describing the amplitude of\n            the rabi term. Defaults to None.\n        phase (Optional[Waveform], optional): Waveform describing the phase of rabi\n            term. Defaults to None.\n        static_params (Dict[str, Any], optional): Define static parameters of your\n            program. Defaults to {}.\n        batch_params (Union[List[Dict[str, Any]], Dict[str, Any]], optional):\n            Parmaters for a batch of tasks. Defaults to [].\n        args (List[str], optional): List of arguments to leave till runtime.\n            Defaults to [].\n\n    Returns:\n        Routine: An object that can be used to dispatch a rydberg program to\n            multiple backends.\n    \"\"\"\n    from bloqade.analog import start\n    from bloqade.analog.atom_arrangement import AtomArrangement\n\n    if isinstance(atoms_positions, AtomArrangement):\n        prog = atoms_positions\n    else:\n        prog = start.add_position(atoms_positions)\n\n    if detuning is not None:\n        prog = prog.rydberg.detuning.uniform.apply(detuning)\n\n    if amplitude is not None:\n        prog = prog.rydberg.rabi.amplitude.uniform.apply(amplitude)\n\n    if phase is not None:\n        prog = prog.rydberg.rabi.phase.uniform.apply(phase)\n\n    if not isinstance(prog, Assignable):\n        raise ValueError(\n            \"At least one of detuning, amplitude, or phase must be provided.\"\n        )\n\n    prog = prog.assign(**static_params)\n\n    if isinstance(batch_params, dict):\n        prog = prog.batch_assign(**batch_params)\n    else:\n        prog = prog.batch_assign(batch_params)\n\n    prog = prog.args(args)\n\n    return prog.parse()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.save","title":"save","text":"<pre><code>save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs\n) -&gt; None\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs,\n) -&gt; None:\n    \"\"\"Serialize object to file\n\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    if isinstance(fp, str):\n        with open(fp, \"w\") as f:\n            json.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n    else:\n        json.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.tree_depth","title":"tree_depth","text":"<pre><code>tree_depth(depth: int = None)\n</code></pre> <p>Setting globally maximum depth for tree printing</p> <p>If <code>depth=None</code>, return current depth. If <code>depth</code> is provided, setting current depth to <code>depth</code></p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>int</code> <p>the user specified depth. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <p>current updated depth</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/__init__.py</code> <pre><code>def tree_depth(depth: int = None):\n    \"\"\"Setting globally maximum depth for tree printing\n\n    If `depth=None`, return current depth.\n    If `depth` is provided, setting current depth to `depth`\n\n    Args:\n        depth (int, optional): the user specified depth. Defaults to None.\n\n    Returns:\n        int: current updated depth\n    \"\"\"\n    if depth is not None:\n        _ir.tree_print.MAX_TREE_DEPTH = depth\n    return _ir.tree_print.MAX_TREE_DEPTH\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/#bloqade.analog.var","title":"var","text":"<pre><code>var(py: str) -&gt; Variable\n</code></pre> <p>cast string (or list/tuple of strings) to [<code>Variable</code>][bloqade.ir.scalar.Variable].</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/","title":"Atom arrangement","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.atom_arrangement.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.atom_arrangement.AtomArrangement href \"\" \"bloqade.analog.atom_arrangement.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims: int\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[\n        Union[BoolArray, List[bool], bool]\n    ] = None,\n) -&gt; ListOfLocations\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(\n    n_defects: int, rng: Generator = np.random.default_rng()\n)\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability: float,\n    rng: Generator = np.random.default_rng(),\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments) -&gt; NDArray\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.analog.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale: ScalarType)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.AtomArrangement.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Chain","title":"Chain","text":"<pre><code>Chain(\n    L: int,\n    *,\n    lattice_spacing: ScalarType = 1.0,\n    vertical_chain: bool = False\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Chain[Chain]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Chain\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Chain href \"\" \"bloqade.analog.atom_arrangement.Chain\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Honeycomb[Honeycomb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Honeycomb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Honeycomb href \"\" \"bloqade.analog.atom_arrangement.Honeycomb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (1/2, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Kagome","title":"Kagome","text":"<pre><code>Kagome(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Kagome[Kagome]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Kagome\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Kagome href \"\" \"bloqade.analog.atom_arrangement.Kagome\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Lieb","title":"Lieb","text":"<pre><code>Lieb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Lieb[Lieb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Lieb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Lieb href \"\" \"bloqade.analog.atom_arrangement.Lieb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.ListOfLocations","title":"ListOfLocations","text":"<pre><code>ListOfLocations(\n    location_list: List[\n        Union[LocationInfo, Tuple[ScalarType, ScalarType]]\n    ] = [],\n)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.ListOfLocations[ListOfLocations]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.atom_arrangement.ListOfLocations\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.atom_arrangement.ListOfLocations href \"\" \"bloqade.analog.atom_arrangement.ListOfLocations\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    location_list: List[Union[LocationInfo, Tuple[ScalarType, ScalarType]]] = [],\n):\n    self.location_list = []\n    for ele in location_list:\n        if isinstance(ele, LocationInfo):\n            self.location_list.append(ele)\n        else:\n            self.location_list.append(LocationInfo.create(ele, True))\n\n    if self.location_list:\n        self.__n_atoms = sum(\n            1 for loc in self.location_list if loc.filling == SiteFilling.filled\n        )\n        self.__n_sites = len(self.location_list)\n        self.__n_vacant = self.__n_sites - self.__n_atoms\n        self.__n_dims = len(self.location_list[0].position)\n    else:\n        self.__n_sites = 0\n        self.__n_atoms = 0\n        self.__n_dims = None\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.ListOfLocations.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.ListOfLocations.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.ListOfLocations.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.ListOfLocations.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.ListOfLocations.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self):\n    return iter(self.location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Rectangular[Rectangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Rectangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Rectangular href \"\" \"bloqade.analog.atom_arrangement.Rectangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Square","title":"Square","text":"<pre><code>Square(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Square[Square]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Square\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Square href \"\" \"bloqade.analog.atom_arrangement.Square\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/atom_arrangement/#bloqade.analog.atom_arrangement.Triangular","title":"Triangular","text":"<pre><code>Triangular(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.atom_arrangement.Triangular[Triangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.atom_arrangement.Triangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.atom_arrangement.Triangular href \"\" \"bloqade.analog.atom_arrangement.Triangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/constants/","title":"Constants","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/constants/#bloqade.analog.constants.RB_C6","title":"RB_C6  <code>module-attribute</code>","text":"<pre><code>RB_C6 = 2 * pi * 862690\n</code></pre> <p>The C6 constant for the Rydberg Interaction of two Rubidium atoms in units of: rad \u03bcm^6/\u03bcs</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/","title":"Factory","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/#bloqade.analog.factory.constant","title":"constant","text":"<pre><code>constant(\n    duration: ScalarType, value: ScalarType\n) -&gt; Constant\n</code></pre> <p>Create a Constant waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of the Constant waveform.</p> required <code>value</code> <code>ScalarType</code> <p>Value of the Constant waveform.s</p> required <p>Returns:</p> Name Type Description <code>Constant</code> <code>Constant</code> <p>A Constant waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef constant(duration: ScalarType, value: ScalarType) -&gt; Constant:\n    \"\"\"Create a Constant waveform.\n\n    Args:\n        duration (ScalarType): Duration of the Constant waveform.\n        value (ScalarType): Value of the Constant waveform.s\n\n    Returns:\n        Constant: A Constant waveform.\n    \"\"\"\n    return Constant(value, duration)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/#bloqade.analog.factory.get_capabilities","title":"get_capabilities","text":"<pre><code>get_capabilities(\n    use_experimental: bool = False,\n) -&gt; QuEraCapabilities\n</code></pre> <p>Get the device capabilities for Aquila</p> <p>Parameters:</p> Name Type Description Default <code>use_experimental</code> <code>bool</code> <p>Get experimental capabilities instead of standard ones. By default value is False.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>QuEraCapabilities</code> <code>QuEraCapabilities</code> <p>capabilities object for Aquila device.</p> Note <p>Units of time, distance, and energy are microseconds (us), micrometers (um), and rad / us, respectively.</p> <p>For a comprehensive list of capabilities, see the Hardware Reference page</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>def get_capabilities(use_experimental: bool = False) -&gt; \"QuEraCapabilities\":\n    \"\"\"Get the device capabilities for Aquila\n\n    Args:\n        use_experimental (bool): Get experimental capabilities instead of\n            standard ones. By default value is False.\n\n    Returns:\n        QuEraCapabilities: capabilities object for Aquila device.\n\n\n    Note:\n        Units of time, distance, and energy are microseconds (us),\n        micrometers (um), and rad / us, respectively.\n\n        For a comprehensive list of capabilities,\n        see the [Hardware Reference](../../reference/hardware-capabilities.md)\n        page\n    \"\"\"\n\n    from bloqade.analog.submission.capabilities import get_capabilities\n\n    # manually convert to units\n    return get_capabilities(use_experimental=use_experimental).scale_units(\n        Decimal(\"1e6\"), Decimal(\"1e-6\")\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/#bloqade.analog.factory.linear","title":"linear","text":"<pre><code>linear(\n    duration: ScalarType,\n    start: ScalarType,\n    stop: ScalarType,\n) -&gt; Linear\n</code></pre> <p>Create a Linear waveform.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>ScalarType</code> <p>Duration of linear waveform</p> required <code>start</code> <code>ScalarType</code> <p>Starting value of linear waveform</p> required <code>stop</code> <code>ScalarType</code> <p>Ending value of linear waveform</p> required <p>Returns:</p> Name Type Description <code>Linear</code> <code>Linear</code> <p>Linear waveform</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef linear(duration: ScalarType, start: ScalarType, stop: ScalarType) -&gt; Linear:\n    \"\"\"Create a Linear waveform.\n\n    Args:\n        duration (ScalarType): Duration of linear waveform\n        start (ScalarType): Starting value of linear waveform\n        stop (ScalarType): Ending value of linear waveform\n\n    Returns:\n        Linear: Linear waveform\n    \"\"\"\n    return Linear(start, stop, duration)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/#bloqade.analog.factory.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise constant waveform from a list of durations and values. The value <code>duration[i]</code> corresponds to the length of time for the i'th segment with a value of <code>values[i]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not the same as the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise constant waveform from a list of durations and values. The\n    value `duration[i]` corresponds to the length of time for the i'th segment\n    with a value of `values[i]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not the same as the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n    if len(durations) != len(values):\n        raise ValueError(\n            \"The length of values must be the same as the length of durations\"\n        )\n\n    if len(durations) == 0:\n        raise ValueError(\"The durations and values lists must not be empty.\")\n\n    pwc_wf = Constant(values[0], durations[0])\n    for duration, value in zip(durations[1:], values[1:]):\n        pwc_wf = pwc_wf.append(Constant(value, duration))\n\n    return pwc_wf\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/#bloqade.analog.factory.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; Waveform\n</code></pre> <p>Create a piecewise linear waveform.</p> <p>Create a piecewise linear waveform from a list of durations and values. The value <code>duration[i]</code> is of the linear segment between <code>values[i]</code> and <code>values[i+1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>durations</code> <code>List[ScalarType]</code> <p>The duration of each segment</p> required <code>values</code> <code>List[ScalarType]</code> <p>The values for each segment</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the length of <code>values</code> is not one greater than the length of</p> <p>Returns:</p> Name Type Description <code>Waveform</code> <code>Waveform</code> <p>The piecewise linear waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef piecewise_linear(durations: List[ScalarType], values: List[ScalarType]) -&gt; Waveform:\n    \"\"\"Create a piecewise linear waveform.\n\n    Create a piecewise linear waveform from a list of durations and values. The\n    value `duration[i]` is of the linear segment between `values[i]` and `values[i+1]`.\n\n    Args:\n        durations (List[ScalarType]): The duration of each segment\n        values (List[ScalarType]): The values for each segment\n\n    Raises:\n        ValueError: If the length of `values` is not one greater than the length of\n        `durations`.\n\n    Returns:\n        Waveform: The piecewise linear waveform.\n    \"\"\"\n\n    if len(durations) + 1 != len(values):\n        raise ValueError(\n            \"The length of values must be one greater than the length of durations\"\n        )\n\n    if len(durations) == 0:\n        raise ValueError(\"The durations and values lists must not be empty.\")\n\n    pwl_wf = Linear(values[0], values[1], durations[0])\n    for duration, start, stop in zip(durations[1:], values[1:-1], values[2:]):\n        pwl_wf = pwl_wf.append(Linear(start, stop, duration))\n\n    return pwl_wf\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/factory/#bloqade.analog.factory.rydberg_h","title":"rydberg_h","text":"<pre><code>rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[\n        List[Dict[str, Any]], Dict[str, Any]\n    ] = [],\n    args: List[str | Variable] = [],\n) -&gt; Routine\n</code></pre> <p>Create a rydberg program with uniform detuning, amplitude, and phase.</p> <p>Parameters:</p> Name Type Description Default <code>atoms_positions</code> <code>Any</code> <p>Description of geometry of atoms in system.</p> required <code>detuning</code> <code>Optional[Waveform]</code> <p>Waveform for detuning. Defaults to None.</p> <code>None</code> <code>amplitude</code> <code>Optional[Waveform]</code> <p>Waveform describing the amplitude of the rabi term. Defaults to None.</p> <code>None</code> <code>phase</code> <code>Optional[Waveform]</code> <p>Waveform describing the phase of rabi term. Defaults to None.</p> <code>None</code> <code>static_params</code> <code>Dict[str, Any]</code> <p>Define static parameters of your program. Defaults to {}.</p> <code>{}</code> <code>batch_params</code> <code>Union[List[Dict[str, Any]], Dict[str, Any]]</code> <p>Parmaters for a batch of tasks. Defaults to [].</p> <code>[]</code> <code>args</code> <code>List[str]</code> <p>List of arguments to leave till runtime. Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>An object that can be used to dispatch a rydberg program to multiple backends.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/factory.py</code> <pre><code>@beartype\ndef rydberg_h(\n    atoms_positions: Any,\n    detuning: Optional[Waveform] = None,\n    amplitude: Optional[Waveform] = None,\n    phase: Optional[Waveform] = None,\n    static_params: Dict[str, Any] = {},\n    batch_params: Union[List[Dict[str, Any]], Dict[str, Any]] = [],\n    args: List[str | Variable] = [],\n) -&gt; Routine:\n    \"\"\"Create a rydberg program with uniform detuning, amplitude, and phase.\n\n    Args:\n        atoms_positions (Any): Description of geometry of atoms in system.\n        detuning (Optional[Waveform], optional): Waveform for detuning.\n            Defaults to None.\n        amplitude (Optional[Waveform], optional): Waveform describing the amplitude of\n            the rabi term. Defaults to None.\n        phase (Optional[Waveform], optional): Waveform describing the phase of rabi\n            term. Defaults to None.\n        static_params (Dict[str, Any], optional): Define static parameters of your\n            program. Defaults to {}.\n        batch_params (Union[List[Dict[str, Any]], Dict[str, Any]], optional):\n            Parmaters for a batch of tasks. Defaults to [].\n        args (List[str], optional): List of arguments to leave till runtime.\n            Defaults to [].\n\n    Returns:\n        Routine: An object that can be used to dispatch a rydberg program to\n            multiple backends.\n    \"\"\"\n    from bloqade.analog import start\n    from bloqade.analog.atom_arrangement import AtomArrangement\n\n    if isinstance(atoms_positions, AtomArrangement):\n        prog = atoms_positions\n    else:\n        prog = start.add_position(atoms_positions)\n\n    if detuning is not None:\n        prog = prog.rydberg.detuning.uniform.apply(detuning)\n\n    if amplitude is not None:\n        prog = prog.rydberg.rabi.amplitude.uniform.apply(amplitude)\n\n    if phase is not None:\n        prog = prog.rydberg.rabi.phase.uniform.apply(phase)\n\n    if not isinstance(prog, Assignable):\n        raise ValueError(\n            \"At least one of detuning, amplitude, or phase must be provided.\"\n        )\n\n    prog = prog.assign(**static_params)\n\n    if isinstance(batch_params, dict):\n        prog = prog.batch_assign(**batch_params)\n    else:\n        prog = prog.batch_assign(batch_params)\n\n    prog = prog.args(args)\n\n    return prog.parse()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/migrate/","title":"Migrate","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/serialize/","title":"Serialize","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/serialize/#bloqade.analog.serialize.dumps","title":"dumps","text":"<pre><code>dumps(\n    o: Any, use_decimal: bool = True, **json_kwargs\n) -&gt; str\n</code></pre> <p>Serialize object to string</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dumps</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>the serialized object as a string</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef dumps(\n    o: Any,\n    use_decimal: bool = True,\n    **json_kwargs,\n) -&gt; str:\n    \"\"\"Serialize object to string\n\n    Args:\n        o (Any): the object to serialize\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dumps\n\n    Returns:\n        str: the serialized object as a string\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    return json.dumps(o, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/serialize/#bloqade.analog.serialize.load","title":"load","text":"<pre><code>load(\n    fp: Union[TextIO, str],\n    use_decimal: bool = True,\n    **json_kwargs\n)\n</code></pre> <p>Load object from file</p> <p>Parameters:</p> Name Type Description Default <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.load</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef load(fp: Union[TextIO, str], use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from file\n\n    Args:\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.load\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    if isinstance(fp, str):\n        with open(fp, \"r\") as f:\n            return json.load(\n                f,\n                object_hook=Serializer.object_hook,\n                use_decimal=use_decimal,\n                **json_kwargs,\n            )\n    else:\n        return json.load(\n            fp,\n            object_hook=Serializer.object_hook,\n            use_decimal=use_decimal,\n            **json_kwargs,\n        )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/serialize/#bloqade.analog.serialize.loads","title":"loads","text":"<pre><code>loads(s: str, use_decimal: bool = True, **json_kwargs)\n</code></pre> <p>Load object from string</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>str</code> <p>the string to load</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.loads</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>the deserialized object</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef loads(s: str, use_decimal: bool = True, **json_kwargs):\n    \"\"\"Load object from string\n\n    Args:\n        s (str): the string to load\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.loads\n\n    Returns:\n        Any: the deserialized object\n    \"\"\"\n    load_bloqade()\n    return json.loads(\n        s, object_hook=Serializer.object_hook, use_decimal=use_decimal, **json_kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/serialize/#bloqade.analog.serialize.save","title":"save","text":"<pre><code>save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs\n) -&gt; None\n</code></pre> <p>Serialize object to file</p> <p>Parameters:</p> Name Type Description Default <code>o</code> <code>Any</code> <p>the object to serialize</p> required <code>fp</code> <code>Union[TextIO, str]</code> <p>the file path or file object</p> required <code>use_decimal</code> <code>bool</code> <p>use decimal.Decimal for numbers. Defaults to True.</p> <code>True</code> <code>**json_kwargs</code> <p>other arguments passed to json.dump</p> <code>{}</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/serialize.py</code> <pre><code>@beartype\ndef save(\n    o: Any,\n    fp: Union[TextIO, str],\n    use_decimal=True,\n    **json_kwargs,\n) -&gt; None:\n    \"\"\"Serialize object to file\n\n    Args:\n        o (Any): the object to serialize\n        fp (Union[TextIO, str]): the file path or file object\n        use_decimal (bool, optional): use decimal.Decimal for numbers. Defaults to True.\n        **json_kwargs: other arguments passed to json.dump\n\n    Returns:\n        None\n    \"\"\"\n    if not isinstance(o, Serializer.types):\n        raise TypeError(\n            f\"Object of type {type(o)} is not JSON serializable. \"\n            f\"Only {Serializer.types} are supported.\"\n        )\n    if isinstance(fp, str):\n        with open(fp, \"w\") as f:\n            json.dump(o, f, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n    else:\n        json.dump(o, fp, cls=Serializer, use_decimal=use_decimal, **json_kwargs)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/args/","title":"Args","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/assign/","title":"Assign","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/","title":"Coupling","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.Hyperfine","title":"Hyperfine","text":"<pre><code>Hyperfine(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>LevelCoupling</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.coupling.Hyperfine[Hyperfine]\n              bloqade.analog.builder.coupling.LevelCoupling[LevelCoupling]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.coupling.LevelCoupling --&gt; bloqade.analog.builder.coupling.Hyperfine\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.coupling.LevelCoupling\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.builder.coupling.Hyperfine href \"\" \"bloqade.analog.builder.coupling.Hyperfine\"\n              click bloqade.analog.builder.coupling.LevelCoupling href \"\" \"bloqade.analog.builder.coupling.LevelCoupling\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>This node represents level coupling between hyperfine states.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Hyperfine'&gt;\n\n- Hyperfine level coupling has two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; hyp_detune = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; hyp_rabi = bloqade.start.hyperfine.rabi\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.Hyperfine.__bloqade_ir__","title":"__bloqade_ir__","text":"<pre><code>__bloqade_ir__()\n</code></pre> <p>Generate the intermediate representation (IR) for the Hyperfine level coupling.</p> <p>Returns:</p> Name Type Description <code>IR</code> <p>An intermediate representation of the Hyperfine level coupling sequence.</p> Note <p>This method is used internally by the Bloqade framework.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/coupling.py</code> <pre><code>def __bloqade_ir__(self):\n    \"\"\"\n    Generate the intermediate representation (IR) for the Hyperfine level coupling.\n\n    Args:\n        None\n\n    Returns:\n        IR: An intermediate representation of the Hyperfine level coupling sequence.\n\n    Raises:\n        None\n\n    Note:\n        This method is used internally by the Bloqade framework.\n    \"\"\"\n    from bloqade.analog.ir.control.sequence import hyperfine\n\n    return hyperfine\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.LevelCoupling","title":"LevelCoupling","text":"<pre><code>LevelCoupling(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.coupling.LevelCoupling[LevelCoupling]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.coupling.LevelCoupling\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.coupling.LevelCoupling href \"\" \"bloqade.analog.builder.coupling.LevelCoupling\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.LevelCoupling.detuning","title":"detuning  <code>property</code>","text":"<pre><code>detuning: Detuning\n</code></pre> <p>Specify the [<code>Detuning</code>][bloqade.builder.field.Detuning] [<code>Field</code>][bloqade.builder.field.Field] of your program. You will be able to specify the spatial modulation afterwards.</p> <p>Returns:</p> Type Description <code>Detuning</code> <p>[<code>Detuning</code>][bloqade.builder.field.Detuning]: A program node representing the detuning field.</p> Note <p>The detuning specifies how off-resonant the laser being applied to the atoms is from the atomic energy transition, driven by the Rabi frequency.</p> <p>Example:     <pre><code>from bloqade import start\ngeometry = start.add_position((0,0))\ncoupling = geometry.rydberg\ncoupling.detuning\n</code></pre></p> <ul> <li>Next Possible Steps You may continue building your program via:</li> <li>[<code>uniform</code>][bloqade.builder.field.Detuning.uniform]: To address all atoms in the field</li> <li>[<code>location(locations, scales)</code>][bloqade.builder.field.Detuning.location]: To address atoms at specific locations via indices</li> <li>[<code>scale(coeffs)</code>][bloqade.builder.field.Detuning.scale]: To address all atoms with an individual scale factor</li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.LevelCoupling.rabi","title":"rabi  <code>property</code>","text":"<pre><code>rabi: Rabi\n</code></pre> <p>Specify the complex-valued [<code>Rabi</code>][bloqade.builder.field.Rabi] field of your program.</p> <p>The Rabi field is composed of a real-valued Amplitude and Phase field.</p> <p>Returns:</p> Name Type Description <code>Rabi</code> <code>Rabi</code> <p>A program node representing the Rabi field.</p> Note <p>Next possible steps to build your program are creating the RabiAmplitude field and RabiPhase field of the field: - <code>...rabi.amplitude</code>: To create the Rabi amplitude field - <code>...rabi.phase</code>: To create the Rabi phase field</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.Rydberg","title":"Rydberg","text":"<pre><code>Rydberg(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>LevelCoupling</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.coupling.Rydberg[Rydberg]\n              bloqade.analog.builder.coupling.LevelCoupling[LevelCoupling]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.coupling.LevelCoupling --&gt; bloqade.analog.builder.coupling.Rydberg\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.coupling.LevelCoupling\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.builder.coupling.Rydberg href \"\" \"bloqade.analog.builder.coupling.Rydberg\"\n              click bloqade.analog.builder.coupling.LevelCoupling href \"\" \"bloqade.analog.builder.coupling.LevelCoupling\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>This node represents level coupling of the Rydberg state.</p> <p>Examples:</p> <pre><code>- To reach the node from the start node:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.coupling.Rydberg'&gt;\n\n- Rydberg level coupling has two reachable field nodes:\n\n    - detuning term (See also [`Detuning`][bloqade.builder.field.Detuning])\n    - rabi term (See also [`Rabi`][bloqade.builder.field.Rabi])\n\n&gt;&gt;&gt; ryd_detune = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; ryd_rabi = bloqade.start.rydberg.rabi\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/coupling/#bloqade.analog.builder.coupling.Rydberg.__bloqade_ir__","title":"__bloqade_ir__","text":"<pre><code>__bloqade_ir__()\n</code></pre> <p>Generate the intermediate representation (IR) for the Rydberg level coupling.</p> <p>Returns:</p> Name Type Description <code>IR</code> <p>An intermediate representation of the Rydberg level coupling sequence.</p> Note <p>This method is used internally by the Bloqade framework.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/coupling.py</code> <pre><code>def __bloqade_ir__(self):\n    \"\"\"\n    Generate the intermediate representation (IR) for the Rydberg level coupling.\n\n    Args:\n        None\n\n    Returns:\n        IR: An intermediate representation of the Rydberg level coupling sequence.\n\n    Raises:\n        None\n\n    Note:\n        This method is used internally by the Bloqade framework.\n    \"\"\"\n    from bloqade.analog.ir.control.sequence import rydberg\n\n    return rydberg\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/drive/","title":"Drive","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/drive/#bloqade.analog.builder.drive.Drive","title":"Drive","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/drive/#bloqade.analog.builder.drive.Drive.hyperfine","title":"hyperfine  <code>property</code>","text":"<pre><code>hyperfine: Hyperfine\n</code></pre> <p>Address the Hyperfine level coupling in your program.</p> <ul> <li>Next possible steps to build your program are specifying the   [<code>Rabi</code>][bloqade.builder.field.Rabi] field or   [<code>Detuning</code>][bloqade.builder.field.Detuning] field.<ul> <li><code>...hyperfine.rabi</code>: for Rabi field</li> <li><code>...hyperfine.detuning</code>: for Detuning field</li> </ul> </li> <li>In the absence of a field you the value is set to zero by default.</li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/drive/#bloqade.analog.builder.drive.Drive.rydberg","title":"rydberg  <code>property</code>","text":"<pre><code>rydberg: Rydberg\n</code></pre> <p>Address the Rydberg level coupling in your program.</p> <ul> <li>Next possible steps to build your program are specifying the   [<code>Rabi</code>][bloqade.builder.field.Rabi] field or   [<code>Detuning</code>][bloqade.builder.field.Detuning] field.<ul> <li><code>...rydberg.rabi</code>: for Rabi field</li> <li><code>...rydberg.detuning</code>: for Detuning field</li> </ul> </li> <li>In the absence of a field you the value is set to zero by default.</li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/","title":"Field","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Detuning","title":"Detuning","text":"<pre><code>Detuning(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Field</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.field.Detuning[Detuning]\n              bloqade.analog.builder.field.Field[Field]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.field.Field --&gt; bloqade.analog.builder.field.Detuning\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.field.Field\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.builder.field.Detuning href \"\" \"bloqade.analog.builder.field.Detuning\"\n              click bloqade.analog.builder.field.Field href \"\" \"bloqade.analog.builder.field.Field\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>This node represent detuning field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify detuning of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n\n- To specify detuning of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.detuning\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Detuning'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See [<code>SpatialModulation</code>][bloqade.builder.field.SpatialModulation] for additional options.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Field","title":"Field","text":"<pre><code>Field(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.field.Field[Field]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.field.Field\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.field.Field href \"\" \"bloqade.analog.builder.field.Field\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Field.uniform","title":"uniform  <code>property</code>","text":"<pre><code>uniform: Uniform\n</code></pre> <p>Address all atoms as part of defining the spatial modulation component of a drive.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.).</p> <ul> <li>You can now do:<ul> <li><code>...uniform.linear(start, stop, duration)</code> : to apply a linear waveform</li> <li><code>...uniform.constant(value, duration)</code> : to apply a constant waveform</li> <li><code>...uniform.poly([coefficients], duration)</code> : to apply a     polynomial waveform</li> <li><code>...uniform.apply(wf:bloqade.ir.Waveform)</code>: to apply a pre-defined waveform</li> <li><code>...uniform.piecewise_linear([durations], [values])</code>:  to apply a piecewise linear waveform</li> <li><code>...uniform.piecewise_constant([durations], [values])</code>: to apply a piecewise constant waveform</li> <li><code>...uniform.fn(f(t,...))</code>: to apply a function as a waveform</li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Field.location","title":"location","text":"<pre><code>location(\n    labels: Union[List[int], int],\n    scales: Union[\n        List[ScalarType], ScalarType, None\n    ] = None,\n) -&gt; Location\n</code></pre> <p>Address a single atom (or multiple) atoms.</p> <p>Address a single atom (or multiple) as part of defining the spatial modulation component of a drive. You can specify the atoms to target as a list of labels and a list of scales. The scales are used to multiply the waveform that is applied to the atom. You can also specify a single label and scale to target a single atom.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field. (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Field.location--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n# to target a single atom with a waveform\n&gt;&gt;&gt; one_location_prog = prog.location(0)\n# to target a single atom with a scale\n&gt;&gt;&gt; one_location_prog = prog.location(0, 0.5)\n# to target multiple atoms with same waveform\n&gt;&gt;&gt; multi_location_prog = prog.location([0, 2])\n# to target multiple atoms with different scales\n&gt;&gt;&gt; multi_location_prog = prog.location([0, 2], [0.5, \"scale\"])\n</code></pre> <ul> <li>You can now do:<ul> <li><code>...location(labels, scales).linear(start, stop, duration)</code> : to apply     a linear waveform</li> <li><code>...location(labels, scales).constant(value, duration)</code> : to apply     a constant waveform</li> <li><code>...location(labels, scales).poly([coefficients], duration)</code> : to apply     a polynomial waveform</li> <li><code>...location(labels, scales).apply(wf:bloqade.ir.Waveform)</code>: to apply     a pre-defined waveform</li> <li><code>...location(labels, scales).piecewise_linear([durations], [values])</code>:     to apply     a piecewise linear waveform</li> <li><code>...location(labels, scales).piecewise_constant([durations], [values])</code>:     to apply     a piecewise constant waveform</li> <li><code>...location(labels, scales).fn(f(t,..))</code>: to apply a function as a     waveform</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/field.py</code> <pre><code>def location(\n    self,\n    labels: Union[List[int], int],\n    scales: Union[List[ScalarType], ScalarType, None] = None,\n) -&gt; \"Location\":\n    \"\"\"Address a single atom (or multiple) atoms.\n\n    Address a single atom (or multiple) as part of defining the spatial\n    modulation component of a drive. You can specify the atoms to target\n    as a list of labels and a list of scales. The scales are used to\n    multiply the waveform that is applied to the atom. You can also specify\n    a single label and scale to target a single atom.\n\n    Next steps to build your program include choosing the waveform that\n    will be summed with the spatial modulation to create a drive.\n\n    The drive by itself, or the sum of subsequent drives (created by just\n    chaining the construction of drives) will become the field.\n    (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n    # to target a single atom with a waveform\n    &gt;&gt;&gt; one_location_prog = prog.location(0)\n    # to target a single atom with a scale\n    &gt;&gt;&gt; one_location_prog = prog.location(0, 0.5)\n    # to target multiple atoms with same waveform\n    &gt;&gt;&gt; multi_location_prog = prog.location([0, 2])\n    # to target multiple atoms with different scales\n    &gt;&gt;&gt; multi_location_prog = prog.location([0, 2], [0.5, \"scale\"])\n    ```\n\n    - You can now do:\n        - `...location(labels, scales).linear(start, stop, duration)` : to apply\n            a linear waveform\n        - `...location(labels, scales).constant(value, duration)` : to apply\n            a constant waveform\n        - `...location(labels, scales).poly([coefficients], duration)` : to apply\n            a polynomial waveform\n        - `...location(labels, scales).apply(wf:bloqade.ir.Waveform)`: to apply\n            a pre-defined waveform\n        - `...location(labels, scales).piecewise_linear([durations], [values])`:\n            to apply\n            a piecewise linear waveform\n        - `...location(labels, scales).piecewise_constant([durations], [values])`:\n            to apply\n            a piecewise constant waveform\n        - `...location(labels, scales).fn(f(t,..))`: to apply a function as a\n            waveform\n\n    \"\"\"\n    return self._location(labels, scales)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Field.scale","title":"scale","text":"<pre><code>scale(coeffs: Union[str, List[ScalarType]]) -&gt; Scale\n</code></pre> <p>Address all the atoms scaling each atom with an element of the list or define a variable name for the scale list to be assigned later by defining a <code>name</code> and using <code>assign</code> or <code>batch_assign</code> later.</p> <p>Next steps to build your program include choosing the waveform that will be summed with the spatial modulation to create a drive.</p> <p>The drive by itself, or the sum of subsequent drives (created by just chaining the construction of drives) will become the field (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Field.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n\n# assign a literal list of values to scale each atom\n&gt;&gt;&gt; one_location_prog = prog.scale([0.1, 0.2, 0.3])\n# assign a variable name to be assigned later\n&gt;&gt;&gt; one_location_prog = prog.scale(\"a\")\n# \"a\" can be assigned in the END of the program during variable assignment\n# using a list of values, indicating the scaling for each atom\n&gt;&gt;&gt; single_assignment = ...assign(a = [0.1, 0.2, 0.3])\n# a list of lists, indicating a set of atoms should be targeted\n# for each task in a batch.\n&gt;&gt;&gt; batch_assignment = ...batch_assign(a = [list_1, list_2, list_3,...])\n</code></pre> <ul> <li>You can now do:<ul> <li><code>...scale(coeffs).linear(start, stop, duration)</code> : to apply     a linear waveform</li> <li><code>...scale(coeffs).constant(value, duration)</code> : to apply     a constant waveform</li> <li><code>...scale(coeffs).poly([coefficients], duration)</code> : to apply     a polynomial waveform</li> <li><code>...scale(coeffs).apply(wf:bloqade.ir.Waveform)</code>: to apply     a pre-defined waveform</li> <li><code>...scale(coeffs).piecewise_linear(durations, values)</code>:  to     apply a piecewise linear waveform</li> <li><code>...scale(coeffs).piecewise_constant(durations, values)</code>: to     apply a piecewise constant waveform</li> <li><code>...scale(coeffs).fn(f(t,..))</code>: to apply a function as a waveform</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/field.py</code> <pre><code>def scale(self, coeffs: Union[str, List[ScalarType]]) -&gt; \"Scale\":\n    \"\"\"\n    Address all the atoms scaling each atom with an element of the list\n    or define a variable name for the scale list to be assigned later by\n    defining a `name` and using `assign` or `batch_assign` later.\n\n    Next steps to build your program include choosing the waveform that\n    will be summed with the spatial modulation to create a drive.\n\n    The drive by itself, or the sum of subsequent drives (created by just\n    chaining the construction of drives) will become the field\n    (e.g. Detuning Field, Real-Valued Rabi Amplitude/Rabi Phase Field, etc.)\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position([(0,0),(1,4),(2,8)]).rydberg.rabi\n\n    # assign a literal list of values to scale each atom\n    &gt;&gt;&gt; one_location_prog = prog.scale([0.1, 0.2, 0.3])\n    # assign a variable name to be assigned later\n    &gt;&gt;&gt; one_location_prog = prog.scale(\"a\")\n    # \"a\" can be assigned in the END of the program during variable assignment\n    # using a list of values, indicating the scaling for each atom\n    &gt;&gt;&gt; single_assignment = ...assign(a = [0.1, 0.2, 0.3])\n    # a list of lists, indicating a set of atoms should be targeted\n    # for each task in a batch.\n    &gt;&gt;&gt; batch_assignment = ...batch_assign(a = [list_1, list_2, list_3,...])\n\n    ```\n\n    - You can now do:\n        - `...scale(coeffs).linear(start, stop, duration)` : to apply\n            a linear waveform\n        - `...scale(coeffs).constant(value, duration)` : to apply\n            a constant waveform\n        - `...scale(coeffs).poly([coefficients], duration)` : to apply\n            a polynomial waveform\n        - `...scale(coeffs).apply(wf:bloqade.ir.Waveform)`: to apply\n            a pre-defined waveform\n        - `...scale(coeffs).piecewise_linear(durations, values)`:  to\n            apply a piecewise linear waveform\n        - `...scale(coeffs).piecewise_constant(durations, values)`: to\n            apply a piecewise constant waveform\n        - `...scale(coeffs).fn(f(t,..))`: to apply a function as a waveform\n\n    \"\"\"\n    from bloqade.analog.builder.spatial import Scale\n\n    return Scale(coeffs, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Rabi","title":"Rabi","text":"<pre><code>Rabi(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.field.Rabi[Rabi]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.field.Rabi\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.field.Rabi href \"\" \"bloqade.analog.builder.field.Rabi\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>This node represent rabi field of a specified level coupling (rydberg or hyperfine) type.</p> <p>Examples:</p> <pre><code>- To specify rabi of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n\n- To specify rabi of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Rabi'&gt;\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Rabi.amplitude","title":"amplitude  <code>property</code>","text":"<pre><code>amplitude: RabiAmplitude\n</code></pre> <p>Specify the real-valued Rabi Amplitude field.</p> <p>Next steps to build your program focus on specifying a spatial modulation.</p> <p>The spatial modulation, when coupled with a waveform, completes the specification of a \"Drive\". One or more drives can be summed together automatically to create a field such as the Rabi Amplitude here.</p> <ul> <li>You can now<ul> <li><code>...amplitude.uniform</code>: Address all atoms in the field</li> <li><code>...amplitude.location(...)</code>: Scale atoms by their indices</li> <li><code>...amplitude.scale(...)</code>: Scale each atom with a value from a     list or assign a variable name to be assigned later</li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.Rabi.phase","title":"phase  <code>property</code>","text":"<pre><code>phase: RabiPhase\n</code></pre> <p>Specify the real-valued Rabi Phase field.</p> <p>Next steps to build your program focus on specifying a spatial modulation.</p> <p>The spatial modulation, when coupled with a waveform, completes the specification of a \"Drive\". One or more drives can be summed together automatically to create a field such as the Rabi Phase here.</p> <ul> <li>You can now<ul> <li><code>...amplitude.uniform</code>: Address all atoms in the field</li> <li><code>...amplitude.location(...)</code>: Scale atoms by their indices</li> <li><code>...amplitude.scale(...)</code>: Scale each atom with a value from a     list or assign a variable name to be assigned later</li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.RabiAmplitude","title":"RabiAmplitude","text":"<pre><code>RabiAmplitude(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Field</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.field.RabiAmplitude[RabiAmplitude]\n              bloqade.analog.builder.field.Field[Field]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.field.Field --&gt; bloqade.analog.builder.field.RabiAmplitude\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.field.Field\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.builder.field.RabiAmplitude href \"\" \"bloqade.analog.builder.field.RabiAmplitude\"\n              click bloqade.analog.builder.field.Field href \"\" \"bloqade.analog.builder.field.Field\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>This node represent amplitude of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi amplitude of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n\n- To specify rabi amplitude of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.amplitude\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Amplitude'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See [<code>SpatialModulation</code>][bloqade.builder.field.SpatialModulation] for additional options.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/field/#bloqade.analog.builder.field.RabiPhase","title":"RabiPhase","text":"<pre><code>RabiPhase(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Field</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.field.RabiPhase[RabiPhase]\n              bloqade.analog.builder.field.Field[Field]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.field.Field --&gt; bloqade.analog.builder.field.RabiPhase\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.field.Field\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.builder.field.RabiPhase href \"\" \"bloqade.analog.builder.field.RabiPhase\"\n              click bloqade.analog.builder.field.Field href \"\" \"bloqade.analog.builder.field.Field\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>This node represent phase of a rabi field.</p> <p>Examples:</p> <pre><code>- To specify rabi phase of rydberg coupling:\n\n&gt;&gt;&gt; node = bloqade.start.rydberg.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n\n- To specify rabi phase of hyperfine coupling:\n\n&gt;&gt;&gt; node = bloqade.start.hyperfine.rabi.phase\n&gt;&gt;&gt; type(node)\n&lt;class 'bloqade.builder.field.Phase'&gt;\n</code></pre> Note <p>This node is a SpatialModulation node. See [<code>SpatialModulation</code>][bloqade.builder.field.SpatialModulation] for additional options.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parallelize/","title":"Parallelize","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/","title":"Pragmas","text":"<p>This module provides classes for building and managing quantum programs using the Bloqade library.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.AddArgs","title":"AddArgs","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.AddArgs.args","title":"args","text":"<pre><code>args(args_list: List[Union[str, Variable]]) -&gt; Args\n</code></pre> <p>Add arguments to the current program.</p> <p>Parameters:</p> Name Type Description Default <code>args_list</code> <code>List[Union[str, Variable]]</code> <p>List of argument names or Variable objects to be added.</p> required <p>Returns:</p> Name Type Description <code>Args</code> <code>Args</code> <p>A new instance of the Args class with the specified arguments.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If args_list contains invalid types.</p> Note <p>This method is useful for deferring the value assignment of certain variables to runtime.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/pragmas.py</code> <pre><code>def args(self, args_list: List[Union[str, Variable]]) -&gt; \"Args\":\n    \"\"\"\n    Add arguments to the current program.\n\n    Args:\n        args_list (List[Union[str, Variable]]): List of argument names or Variable\n            objects to be added.\n\n    Returns:\n        Args: A new instance of the Args class with the specified arguments.\n\n    Raises:\n        TypeError: If args_list contains invalid types.\n\n    Note:\n        This method is useful for deferring the value assignment of certain\n        variables to runtime.\n    \"\"\"\n    from bloqade.analog.builder.args import Args\n\n    return Args(args_list, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.Assignable","title":"Assignable","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.Assignable.assign","title":"assign","text":"<pre><code>assign(**assignments) -&gt; Assign\n</code></pre> <p>Assign values to variables declared previously in the program.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>Key-value pairs where the key is the variable name and the value is the value to assign.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Assign</code> <code>Assign</code> <p>A new instance of the Assign class with the specified assignments.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an invalid assignment is provided.</p> Note <p>This is reserved for variables that should take single values or for spatial modulations created with <code>.scale(str)</code>. After assigning values, you can choose a backend for emulation or execution.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.Assignable.assign--usage-examples","title":"Usage Examples:","text":"<pre><code># define geometry\n&gt;&gt;&gt; reg = bloqade.start\n...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n# define variables in program\n&gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n...       .linear(start=\"ival\", stop=1, duration=\"span_time\")\n# assign values to variables\n&gt;&gt;&gt; seq = seq.assign(span_time=0.5, ival=0.0)\n</code></pre> <ul> <li>Next steps:<ul> <li><code>...assign(assignments).bloqade</code>: select the bloqade local emulator backend</li> <li><code>...assign(assignments).braket</code>: select braket local emulator or QuEra hardware</li> <li><code>...assign(assignments).device(specifier_string)</code>: select backend by specifying a string</li> <li><code>...assign(assignments).batch_assign(assignments)</code>: assign multiple values for a parameter sweep</li> <li><code>...assign(assignments).parallelize(cluster_spacing)</code>: parallelize the program register</li> <li><code>...assign(assignments).args([previously_defined_vars])</code>: defer value assignment to runtime</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/pragmas.py</code> <pre><code>def assign(self, **assignments) -&gt; \"Assign\":\n    \"\"\"\n    Assign values to variables declared previously in the program.\n\n    Args:\n        **assignments: Key-value pairs where the key is the variable name and\n            the value is the value to assign.\n\n    Returns:\n        Assign: A new instance of the Assign class with the specified\n            assignments.\n\n    Raises:\n        ValueError: If an invalid assignment is provided.\n\n    Note:\n        This is reserved for variables that should take single values or for\n        spatial modulations created with `.scale(str)`. After assigning values,\n        you can choose a backend for emulation or execution.\n\n    ### Usage Examples:\n    ```\n    # define geometry\n    &gt;&gt;&gt; reg = bloqade.start\n    ...       .add_position([(0,0),(1,1),(2,2),(3,3)])\n    # define variables in program\n    &gt;&gt;&gt; seq = reg.rydberg.detuning.uniform\n    ...       .linear(start=\"ival\", stop=1, duration=\"span_time\")\n    # assign values to variables\n    &gt;&gt;&gt; seq = seq.assign(span_time=0.5, ival=0.0)\n    ```\n\n    - Next steps:\n        - `...assign(assignments).bloqade`: select the bloqade local emulator backend\n        - `...assign(assignments).braket`: select braket local emulator or QuEra hardware\n        - `...assign(assignments).device(specifier_string)`: select backend by specifying a\n        string\n        - `...assign(assignments).batch_assign(assignments)`: assign multiple values for a\n        parameter sweep\n        - `...assign(assignments).parallelize(cluster_spacing)`: parallelize the program\n        register\n        - `...assign(assignments).args([previously_defined_vars])`: defer value assignment to\n        runtime\n    \"\"\"\n    from bloqade.analog.builder.assign import Assign\n\n    return Assign(assignments, parent=self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.BatchAssignable","title":"BatchAssignable","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.BatchAssignable.batch_assign","title":"batch_assign","text":"<pre><code>batch_assign(\n    __batch_params: List[Dict[str, ParamType]] = [],\n    **assignments: List[ParamType]\n) -&gt; Union[BatchAssign, ListAssign]\n</code></pre> <p>Assign multiple values to variables for creating a parameter sweep.</p> <p>Parameters:</p> Name Type Description Default <code>__batch_params</code> <code>List[Dict[str, ParamType]]</code> <p>List of dictionaries where each dictionary contains variable assignments for one set of parameters.</p> <code>[]</code> <code>**assignments</code> <code>List[ParamType]</code> <p>Key-value pairs where the key is the variable name and the value is a list of values to assign.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[BatchAssign, ListAssign]</code> <p>Union[BatchAssign, ListAssign]: A new instance of BatchAssign or ListAssign class with the specified assignments.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both __batch_params and assignments are provided.</p> Note <p>Bloqade handles the multiple programs generated by this method and treats them as a unified object for easy post-processing. Ensure all lists of values are of the same length as Bloqade will not perform a Cartesian product.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.BatchAssignable.batch_assign--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (0, \"atom_distance\")])\n&gt;&gt;&gt; prog = reg.rydberg.rabi.amplitude.uniform.constant(\"value\", 5.0)\n&gt;&gt;&gt; var_assigned_prog = prog.batch_assign(value=[1.0, 2.0, 3.0],\natom_distance=[1.0, 2.0, 3.0])\n</code></pre> <ul> <li>Next steps:<ul> <li><code>...batch_assign(assignments).bloqade</code>: select the bloqade local emulator backend</li> <li><code>...batch_assign(assignments).braket</code>: select braket local emulator or QuEra hardware</li> <li><code>...batch_assign(assignments).device(specifier_string)</code>: select backend by specifying a string</li> <li><code>...batch_assign(assignments).parallelize(cluster_spacing)</code>: parallelize the program register</li> <li><code>...batch_assign(assignments).args([previously_defined_vars])</code>: defer value assignment to runtime</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/pragmas.py</code> <pre><code>def batch_assign(\n    self,\n    __batch_params: List[Dict[str, ParamType]] = [],\n    **assignments: List[ParamType],\n) -&gt; Union[\"BatchAssign\", \"ListAssign\"]:\n    \"\"\"\n    Assign multiple values to variables for creating a parameter sweep.\n\n    Args:\n        __batch_params (List[Dict[str, ParamType]], optional): List of dictionaries\n            where each dictionary contains variable assignments for one set of parameters.\n        **assignments (List[ParamType]): Key-value pairs where the key is the variable\n            name and the value is a list of values to assign.\n\n    Returns:\n        Union[BatchAssign, ListAssign]: A new instance of BatchAssign or ListAssign\n            class with the specified assignments.\n\n    Raises:\n        ValueError: If both __batch_params and assignments are provided.\n\n    Note:\n        Bloqade handles the multiple programs generated by this method and treats them\n        as a unified object for easy post-processing. Ensure all lists of values are of\n        the same length as Bloqade will not perform a Cartesian product.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (0, \"atom_distance\")])\n    &gt;&gt;&gt; prog = reg.rydberg.rabi.amplitude.uniform.constant(\"value\", 5.0)\n    &gt;&gt;&gt; var_assigned_prog = prog.batch_assign(value=[1.0, 2.0, 3.0],\n    atom_distance=[1.0, 2.0, 3.0])\n    ```\n\n    - Next steps:\n        - `...batch_assign(assignments).bloqade`: select the bloqade local emulator backend\n        - `...batch_assign(assignments).braket`: select braket local emulator or QuEra hardware\n        - `...batch_assign(assignments).device(specifier_string)`: select backend by specifying\n        a string\n        - `...batch_assign(assignments).parallelize(cluster_spacing)`: parallelize the program\n        register\n        - `...batch_assign(assignments).args([previously_defined_vars])`: defer value assignment\n        to runtime\n    \"\"\"\n    from bloqade.analog.builder.assign import ListAssign, BatchAssign\n\n    if len(__batch_params) &gt; 0 and assignments:\n        raise ValueError(\"batch_params and assignments cannot be used together.\")\n\n    if len(__batch_params) &gt; 0:\n        return ListAssign(__batch_params, parent=self)\n    else:\n        return BatchAssign(assignments, parent=self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.Parallelizable","title":"Parallelizable","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.Parallelizable.parallelize","title":"parallelize","text":"<pre><code>parallelize(cluster_spacing: LiteralType) -&gt; Parallelize\n</code></pre> <p>Parallelize the current problem by duplicating the geometry to utilize all available space/qubits on hardware.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_spacing</code> <code>LiteralType</code> <p>Specifies the spacing between clusters in micrometers.</p> required <p>Returns:</p> Name Type Description <code>Parallelize</code> <code>Parallelize</code> <p>A new instance of the Parallelize class with the specified cluster spacing.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the cluster_spacing is not a valid value.</p> Note <p>After calling this method, you can choose a backend for emulation or execution. Options include <code>bloqade</code> for a local emulator, <code>braket</code> for a local emulator or QuEra hardware on the cloud, or specifying a device with a string.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/pragmas/#bloqade.analog.builder.pragmas.Parallelizable.parallelize--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position((0,0)).rydberg.rabi.uniform.amplitude.constant(1.0, 1.0)\n# copy-paste the geometry and waveforms\n&gt;&gt;&gt; parallelized_prog = reg.parallelize(24)\n</code></pre> <ul> <li>Next steps:<ul> <li><code>...parallelize(cluster_spacing).bloqade</code>: select the bloqade local emulator backend</li> <li><code>...parallelize(cluster_spacing).braket</code>: select braket local emulator or QuEra hardware on the cloud</li> <li><code>...parallelize(cluster_spacing).device(specifier_string)</code>: select backend by specifying a string</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/pragmas.py</code> <pre><code>def parallelize(self, cluster_spacing: LiteralType) -&gt; \"Parallelize\":\n    \"\"\"\n    Parallelize the current problem by duplicating the geometry to utilize\n    all available space/qubits on hardware.\n\n    Args:\n        cluster_spacing (LiteralType): Specifies the spacing between clusters\n            in micrometers.\n\n    Returns:\n        Parallelize: A new instance of the Parallelize class with the specified\n            cluster spacing.\n\n    Raises:\n        ValueError: If the cluster_spacing is not a valid value.\n\n    Note:\n        After calling this method, you can choose a backend for emulation or\n        execution. Options include `bloqade` for a local emulator, `braket` for\n        a local emulator or QuEra hardware on the cloud, or specifying a device\n        with a string.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position((0,0)).rydberg.rabi.uniform.amplitude.constant(1.0, 1.0)\n    # copy-paste the geometry and waveforms\n    &gt;&gt;&gt; parallelized_prog = reg.parallelize(24)\n    ```\n\n    - Next steps:\n        - `...parallelize(cluster_spacing).bloqade`: select the bloqade local emulator backend\n        - `...parallelize(cluster_spacing).braket`: select braket local emulator or QuEra\n        hardware on the cloud\n        - `...parallelize(cluster_spacing).device(specifier_string)`: select backend by\n        specifying a string\n    \"\"\"\n    from bloqade.analog.builder.parallelize import Parallelize\n\n    return Parallelize(cluster_spacing, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/route/","title":"Route","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/sequence_builder/","title":"Sequence builder","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/spatial/","title":"Spatial","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/spatial/#bloqade.analog.builder.spatial.Uniform","title":"Uniform","text":"<pre><code>Uniform(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>SpatialModulation</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.spatial.Uniform[Uniform]\n              bloqade.analog.builder.spatial.SpatialModulation[SpatialModulation]\n              bloqade.analog.builder.waveform.WaveformAttachable[WaveformAttachable]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.spatial.SpatialModulation --&gt; bloqade.analog.builder.spatial.Uniform\n                                bloqade.analog.builder.waveform.WaveformAttachable --&gt; bloqade.analog.builder.spatial.SpatialModulation\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.waveform.WaveformAttachable\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.builder.spatial.Uniform href \"\" \"bloqade.analog.builder.spatial.Uniform\"\n              click bloqade.analog.builder.spatial.SpatialModulation href \"\" \"bloqade.analog.builder.spatial.SpatialModulation\"\n              click bloqade.analog.builder.waveform.WaveformAttachable href \"\" \"bloqade.analog.builder.waveform.WaveformAttachable\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>The node specify a uniform spacial modulation. Which is ready to apply waveform (See [<code>Waveform</code>][bloqade.builder.waveform] for available waveform options)</p> <p>Examples:</p> <pre><code>- To hit this node from the start node:\n\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform\n\n- Apply Linear waveform:\n\n&gt;&gt;&gt; wv = bloqade.ir.Linear(start=0,stop=1,duration=0.5)\n&gt;&gt;&gt; reg = bloqade.start.add_position([(0,0),(1,1),(2,2),(3,3)])\n&gt;&gt;&gt; loc = reg.rydberg.detuning.uniform.apply(wv)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/start/","title":"Start","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/start/#bloqade.analog.builder.start.ProgramStart","title":"ProgramStart","text":"<pre><code>ProgramStart(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Drive</code>, <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>ProgramStart is the base class for a starting/entry node for building a program.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/start/#bloqade.analog.builder.start.ProgramStart.apply","title":"apply","text":"<pre><code>apply(sequence: SequenceExpr) -&gt; SequenceBuilder\n</code></pre> <p>Apply a pre-built sequence to a program.</p> <p>This allows you to build a program independent of any geometry and then <code>apply</code> the program to said geometry. Or, if you have a program you would like to try on multiple geometries you can trivially do so with this.</p> <p>Example Usage: <pre><code>&gt;&gt;&gt; from numpy import pi\n&gt;&gt;&gt; seq = start.rydberg.rabi.amplitude.constant(2.0 * pi, 4.5)\n# choose a geometry of interest to apply the program on\n&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain, Kagome\n&gt;&gt;&gt; complete_program = Chain(10).apply(seq)\n# you can .apply to as many geometries as you like\n&gt;&gt;&gt; another_complete_program = Kagome(3).apply(seq)\n</code></pre></p> <ul> <li>From here you can now do:<ul> <li><code>...assign(assignments).bloqade</code>: select the bloqade     local emulator backend</li> <li><code>...assign(assignments).braket</code>: select braket     local emulator or QuEra hardware</li> <li><code>...assign(assignments).device(specifier_string)</code>: select     backend by specifying a string</li> </ul> </li> <li>Assign multiple values to a single variable for a parameter sweep:<ul> <li><code>...assign(assignments).batch_assign(assignments)</code>:</li> </ul> </li> <li>Parallelize the program register, duplicating the geometry and waveform     sequence to take advantage of all available   space/qubits on the QPU:<ul> <li><code>...assign(assignments).parallelize(cluster_spacing)</code></li> </ul> </li> <li>Defer value assignment of certain variables to runtime:<ul> <li><code>...assign(assignments).args([previously_defined_vars])</code></li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/start.py</code> <pre><code>@beartype\ndef apply(self, sequence: SequenceExpr) -&gt; SequenceBuilder:\n    \"\"\"\n    Apply a pre-built sequence to a program.\n\n    This allows you to build a program independent of any geometry\n    and then `apply` the program to said geometry. Or, if you have a\n    program you would like to try on multiple geometries you can\n    trivially do so with this.\n\n    Example Usage:\n    ```\n    &gt;&gt;&gt; from numpy import pi\n    &gt;&gt;&gt; seq = start.rydberg.rabi.amplitude.constant(2.0 * pi, 4.5)\n    # choose a geometry of interest to apply the program on\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain, Kagome\n    &gt;&gt;&gt; complete_program = Chain(10).apply(seq)\n    # you can .apply to as many geometries as you like\n    &gt;&gt;&gt; another_complete_program = Kagome(3).apply(seq)\n    ```\n\n    - From here you can now do:\n        - `...assign(assignments).bloqade`: select the bloqade\n            local emulator backend\n        - `...assign(assignments).braket`: select braket\n            local emulator or QuEra hardware\n        - `...assign(assignments).device(specifier_string)`: select\n            backend by specifying a string\n    - Assign multiple values to a single variable for a parameter sweep:\n        - `...assign(assignments).batch_assign(assignments)`:\n    - Parallelize the program register, duplicating the geometry and waveform\n        sequence to take advantage of all available\n      space/qubits on the QPU:\n        - `...assign(assignments).parallelize(cluster_spacing)`\n    - Defer value assignment of certain variables to runtime:\n        - `...assign(assignments).args([previously_defined_vars])`\n\n    \"\"\"\n    return SequenceBuilder(sequence, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/typing/","title":"Typing","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.Recordable","title":"Recordable","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.Recordable.record","title":"record","text":"<pre><code>record(name: str) -&gt; Record\n</code></pre> <p>Copy or \"record\" the value at the end of the waveform into a variable so that it can be used in another place.</p> <p>A common design pattern is to couple this with <code>.slice()</code> considering you may not know exactly what the end value of a <code>.slice()</code> is, especially in parameter sweeps where it becomes cumbersome to handle.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.Recordable.record--usage-example","title":"Usage Example:","text":"<pre><code># define program of interest\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; prog = start.rydberg.rabi.amplitude.uniform\n&gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n# We now slice the piecewise_linear from above and record the\n# value at the end of that slice. We then use that value\n# to construct a new waveform that can be appended to the previous\n# one without introducing discontinuity (refer to the\n# \"Quantum Scar Dynamics\" tutorial for how this could be handy)\n&gt;&gt;&gt; prog_with_record = prog_with_wf.slice(0.0, 1.0).record(\"end_of_wf\")\n&gt;&gt;&gt; record_applied_prog = prog_with_record.linear(start=\"end_of_wf\"\n, stop=0.0, duration=0.3)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...slice(start, stop).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...slice(start, stop).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...slice(start, stop).piecewise_linear()</code>:     to append a piecewise linear waveform</li> <li><code>...slice(start, stop).piecewise_constant()</code>:     to append a piecewise constant waveform</li> <li><code>...slice(start, stop).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...slice(start, stop).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...slilce(start, stop).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...slice(start, stop).uniform</code>:     To address all atoms in the field</li> <li><code>...slice(start, stop).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...slice(start, stop).scale(str)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...slice(start, stop).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...slice(start, stop)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...slice(start, stop).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...slice(start, stop).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...slice(start, stop).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...slice(start, stop).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...slice(start, stop).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...slice(start, stop).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...slice(start, stop).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...slice(start, stop).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...slice(start, stop).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...slice(start, stop).detuning</code>:     to target the Detuning field</li> <li><code>...slice(start, stop).rabi</code>:     to target the complex-valued Rabi field ```</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef record(self, name: str) -&gt; \"Record\":\n    \"\"\"\n    Copy or \"record\" the value at the end of the waveform into a variable\n    so that it can be used in another place.\n\n    A common design pattern is to couple this with `.slice()` considering\n    you may not know exactly what the end value of a `.slice()` is,\n    especially in parameter sweeps where it becomes cumbersome to handle.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    # define program of interest\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; prog = start.rydberg.rabi.amplitude.uniform\n    &gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    # We now slice the piecewise_linear from above and record the\n    # value at the end of that slice. We then use that value\n    # to construct a new waveform that can be appended to the previous\n    # one without introducing discontinuity (refer to the\n    # \"Quantum Scar Dynamics\" tutorial for how this could be handy)\n    &gt;&gt;&gt; prog_with_record = prog_with_wf.slice(0.0, 1.0).record(\"end_of_wf\")\n    &gt;&gt;&gt; record_applied_prog = prog_with_record.linear(start=\"end_of_wf\"\n    , stop=0.0, duration=0.3)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...slice(start, stop).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...slice(start, stop).constant(value, duration)`:\n            to append a constant waveform\n        - `...slice(start, stop).piecewise_linear()`:\n            to append a piecewise linear waveform\n        - `...slice(start, stop).piecewise_constant()`:\n            to append a piecewise constant waveform\n        - `...slice(start, stop).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...slice(start, stop).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...slilce(start, stop).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...slice(start, stop).uniform`:\n            To address all atoms in the field\n        - `...slice(start, stop).location(int)`:\n            To address an atom at a specific location via index\n        - `...slice(start, stop).scale(str)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...slice(start, stop).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...slice(start, stop)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...slice(start, stop).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...slice(start, stop).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...slice(start, stop).bloqade`:\n            to run on the Bloqade local emulator\n        - `...slice(start, stop).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...slice(start, stop).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...slice(start, stop).rydberg`:\n            to target the Rydberg level coupling\n        - `...slice(start, stop).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...slice(start, stop).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...slice(start, stop).phase`:\n            to target the real-valued Rabi Phase field\n        - `...slice(start, stop).detuning`:\n            to target the Detuning field\n        - `...slice(start, stop).rabi`:\n            to target the complex-valued Rabi field\n    ```\n    \"\"\"\n    return Record(name, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.Sliceable","title":"Sliceable","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.Sliceable.slice","title":"slice","text":"<pre><code>slice(\n    start: Optional[ScalarType] = None,\n    stop: Optional[ScalarType] = None,\n) -&gt; Slice\n</code></pre> <p>Indicate that you only want a portion of your waveform to be used in the program.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.Sliceable.slice--usage-example","title":"Usage Example:","text":"<pre><code># define a program with a waveform of interest\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n&gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n# instead of using the full waveform we opt to only take the first 1 us\n&gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(0.0, 1.0)\n# you may use variables as well\n&gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(\"start\", \"end\")\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...slice(start, stop).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...slice(start, stop).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...slice(start, stop).piecewise_linear()</code>:     to append a piecewise linear waveform</li> <li><code>...slice(start, stop).piecewise_constant()</code>:     to append a piecewise constant waveform</li> <li><code>...slice(start, stop).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...slice(start, stop).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...slilce(start, stop).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...slice(start, stop).uniform</code>:     To address all atoms in the field</li> <li><code>...slice(start, stop).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...slice(start, stop).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...slice(start, stop).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...slice(start, stop)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...slice(start, stop).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...slice(start, stop).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...slice(start, stop).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...slice(start, stop).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...slice(start, stop).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...slice(start, stop).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...slice(start, stop).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...slice(start, stop).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...slice(start, stop).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...slice(start, stop).detuning</code>:     to target the Detuning field</li> <li><code>...slice(start, stop).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef slice(\n    self,\n    start: Optional[ScalarType] = None,\n    stop: Optional[ScalarType] = None,\n) -&gt; \"Slice\":\n    \"\"\"\n    Indicate that you only want a portion of your waveform to be used in\n    the program.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n\n    ### Usage Example:\n    ```\n    # define a program with a waveform of interest\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n    &gt;&gt;&gt; prog_with_wf = prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    # instead of using the full waveform we opt to only take the first 1 us\n    &gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(0.0, 1.0)\n    # you may use variables as well\n    &gt;&gt;&gt; prog_with_slice = prog_with_wf.slice(\"start\", \"end\")\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...slice(start, stop).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...slice(start, stop).constant(value, duration)`:\n            to append a constant waveform\n        - `...slice(start, stop).piecewise_linear()`:\n            to append a piecewise linear waveform\n        - `...slice(start, stop).piecewise_constant()`:\n            to append a piecewise constant waveform\n        - `...slice(start, stop).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...slice(start, stop).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...slilce(start, stop).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...slice(start, stop).uniform`:\n            To address all atoms in the field\n        - `...slice(start, stop).location(int)`:\n            To address an atom at a specific location via index\n        - `...slice(start, stop).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...slice(start, stop).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...slice(start, stop)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...slice(start, stop).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...slice(start, stop).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...slice(start, stop).bloqade`:\n            to run on the Bloqade local emulator\n        - `...slice(start, stop).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...slice(start, stop).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...slice(start, stop).rydberg`:\n            to target the Rydberg level coupling\n        - `...slice(start, stop).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...slice(start, stop).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...slice(start, stop).phase`:\n            to target the real-valued Rabi Phase field\n        - `...slice(start, stop).detuning`:\n            to target the Detuning field\n        - `...slice(start, stop).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Slice(start, stop, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable","title":"WaveformAttachable","text":"<pre><code>WaveformAttachable(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.waveform.WaveformAttachable[WaveformAttachable]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.waveform.WaveformAttachable\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.waveform.WaveformAttachable href \"\" \"bloqade.analog.builder.waveform.WaveformAttachable\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.apply","title":"apply","text":"<pre><code>apply(wf: Waveform) -&gt; Apply\n</code></pre> <p>Apply a [<code>Waveform</code>][bloqade.ir.control.Waveform] built previously to current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.apply--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# build our waveform independently of the main program\n&gt;&gt;&gt; from bloqade import piecewise_linear\n&gt;&gt;&gt; wf = piecewise_linear(durations=[0.3, 2.5, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n&gt;&gt;&gt; prog.apply(wf)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...apply(waveform).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...apply(waveform).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...apply(waveform).piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...apply(waveform).piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...apply(waveform).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...apply(waveform).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...apply(waveform).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...apply(waveform).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...apply(waveform).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...apply(waveform).uniform</code>: To address all atoms in the field</li> <li><code>...apply(waveform).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...apply(waveform).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying a     single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...apply(waveform).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...apply(waveform).batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...apply(waveform).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...apply(waveform).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...apply(waveform).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...apply(waveform).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...apply(waveform).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...apply(waveform).rydberg</code>: to target the Rydberg level coupling</li> <li><code>...apply(waveform).hyperfine</code>: to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...apply(waveform).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...apply(waveform).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...apply(waveform).detuning</code>:     to target the Detuning field</li> <li><code>...apply(waveform).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef apply(self, wf: ir.Waveform) -&gt; \"Apply\":\n    \"\"\"\n    Apply a [`Waveform`][bloqade.ir.control.Waveform] built previously to\n    current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # build our waveform independently of the main program\n    &gt;&gt;&gt; from bloqade import piecewise_linear\n    &gt;&gt;&gt; wf = piecewise_linear(durations=[0.3, 2.5, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    &gt;&gt;&gt; prog.apply(wf)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...apply(waveform).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...apply(waveform).constant(value, duration)`:\n            to append a constant waveform\n        - `...apply(waveform).piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...apply(waveform).piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...apply(waveform).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...apply(waveform).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...apply(waveform).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...apply(waveform).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...apply(waveform).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...apply(waveform).uniform`: To address all atoms in the field\n        - `...apply(waveform).location(int)`:\n            To address an atom at a specific location via index\n        - `...apply(waveform).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying a\n                single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...apply(waveform).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...apply(waveform).batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...apply(waveform).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...apply(waveform).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...apply(waveform).bloqade`:\n            to run on the Bloqade local emulator\n        - `...apply(waveform).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...apply(waveform).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...apply(waveform).rydberg`: to target the Rydberg level coupling\n        - `...apply(waveform).hyperfine`: to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...apply(waveform).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...apply(waveform).phase`:\n            to target the real-valued Rabi Phase field\n        - `...apply(waveform).detuning`:\n            to target the Detuning field\n        - `...apply(waveform).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Apply(wf, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.constant","title":"constant","text":"<pre><code>constant(\n    value: ScalarType, duration: ScalarType\n) -&gt; Constant\n</code></pre> <p>Append or assign a constant waveform to the current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.constant--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# apply a constant waveform of 1.9 radians/us for 0.5 us\n&gt;&gt;&gt; prog.constant(value=1.9,duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...constant(value, duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...constant(value, duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...constant(value, duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...constant(value, duration)     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...constant(value, duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...constant(value, duration).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...constant(value, duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...constant(value, duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...constant(value, duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...constant(value, duration).uniform</code>:     To address all atoms in the field</li> <li><code>...constant(value, duration).scale(...)</code>:     To address an atom at a specific location via index</li> <li><code>...constant(value, duration).location(int)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...constant(value, duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...constant(value, duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...constant(value, duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...constant(value, duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...constant(value, duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...constant(value, duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...constant(start, stop, duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...constant(value, duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...constant(value, duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current   level coupling (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...constant(value, duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...constant(value, duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...constant(value, duration).detuning</code>:     to target the Detuning field</li> <li><code>...constant(value, duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef constant(self, value: ScalarType, duration: ScalarType) -&gt; \"Constant\":\n    \"\"\"\n    Append or assign a constant waveform to the current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # apply a constant waveform of 1.9 radians/us for 0.5 us\n    &gt;&gt;&gt; prog.constant(value=1.9,duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...constant(value, duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...constant(value, duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...constant(value, duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...constant(value, duration)\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...constant(value, duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...constant(value, duration).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...constant(value, duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...constant(value, duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...constant(value, duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...constant(value, duration).uniform`:\n            To address all atoms in the field\n        - `...constant(value, duration).scale(...)`:\n            To address an atom at a specific location via index\n        - `...constant(value, duration).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...constant(value, duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...constant(value, duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...constant(value, duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...constant(value, duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...constant(value, duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...constant(value, duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...constant(start, stop, duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...constant(value, duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...constant(value, duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current\n      level coupling (previously selected as `rydberg` or `hyperfine`):\n        - `...constant(value, duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...constant(value, duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...constant(value, duration).detuning`:\n            to target the Detuning field\n        - `...constant(value, duration).rabi`:\n            to target the complex-valued Rabi field\n\n    \"\"\"\n    return Constant(value, duration, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.fn","title":"fn","text":"<pre><code>fn(fn: Callable, duration: ScalarType) -&gt; Fn\n</code></pre> <p>Append or assign a custom function as a waveform.</p> <p>The function must have its first argument be that of time but can also have other arguments which are treated as variables. You can assign values to later in the program via <code>.assign</code> or <code>.batch_assign</code>.</p> <p>The function must also return a singular float value.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.fn--usage-examples","title":"### Usage Examples:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# define our custom waveform. It must have one argument\n# be time followed by any other number of arguments that can\n# be assigned a value later in the program via `.assign` or `.batch_assign`\n&gt;&gt;&gt; def custom_waveform_function(t, arg1, arg2):\n        return arg1*t + arg2\n&gt;&gt;&gt; prog = prog.fn(custom_waveform_function, duration = 0.5)\n# assign values\n&gt;&gt;&gt; assigned_vars_prog = prog.assign(arg1 = 1.0, arg2 = 2.0)\n# or go for batching!\n&gt;&gt;&gt; assigned_vars_batch_prog = prog.assign(arg1 = 1.0, arg2 = [1.0, 2.0, 3.0])\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...fn(f(t,...))     .linear(start, stop, duration)</code>: to append another linear waveform</li> <li><code>...fn(f(t,...))     .constant(value, duration)</code>: to append a constant waveform</li> <li><code>...fn(f(t,...))     .piecewise_linear(durations, values)</code>:     to append a piecewise linear waveform</li> <li><code>...fn(f(t,...))     .piecewise_constant(durations, values)</code>:     to append a piecewise constant waveform</li> <li><code>...fn(f(t,...))     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...fn(f(t,...))     .apply(waveform)</code>: to append a pre-defined waveform</li> <li><code>...fn(f(t,...))     .fn(f(t,...))</code>: to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...fn(f(t,...)).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...fn(f(t,...)).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...fn(f(t,...)).uniform</code>:     To address all atoms in the field</li> <li><code>...fn(f(t,...)).scale(...)</code>:     To address an atom at a specific location via index</li> <li>...fn(f(t,...)).location(int)`<ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...fn(f(t,...))     .assign(variable_name = value)</code>: to assign a single value to a variable</li> <li><code>...fn(f(t,...))     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...fn(f(t,...))     .args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...fn(f(t,...)).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...fn(f(t,...)).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...fn(f(t,...)).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...fn(f(t,...)).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...fn(f(t,...)).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...fn(f(t,...)).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...fn(f(t,...)).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...fn(f(t,...)).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...fn(f(t,...)).detuning</code>:     to target the Detuning field</li> <li><code>...fn(f(t,...)).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef fn(self, fn: Callable, duration: ScalarType) -&gt; \"Fn\":\n    \"\"\"\n    Append or assign a custom function as a waveform.\n\n    The function must have its first argument be that of time but\n    can also have other arguments which are treated as variables.\n    You can assign values to later in the program via `.assign` or `.batch_assign`.\n\n    The function must also return a singular float value.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### ### Usage Examples:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # define our custom waveform. It must have one argument\n    # be time followed by any other number of arguments that can\n    # be assigned a value later in the program via `.assign` or `.batch_assign`\n    &gt;&gt;&gt; def custom_waveform_function(t, arg1, arg2):\n            return arg1*t + arg2\n    &gt;&gt;&gt; prog = prog.fn(custom_waveform_function, duration = 0.5)\n    # assign values\n    &gt;&gt;&gt; assigned_vars_prog = prog.assign(arg1 = 1.0, arg2 = 2.0)\n    # or go for batching!\n    &gt;&gt;&gt; assigned_vars_batch_prog = prog.assign(arg1 = 1.0, arg2 = [1.0, 2.0, 3.0])\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...fn(f(t,...))\n            .linear(start, stop, duration)`: to append another linear waveform\n        - `...fn(f(t,...))\n            .constant(value, duration)`: to append a constant waveform\n        - `...fn(f(t,...))\n            .piecewise_linear(durations, values)`:\n            to append a piecewise linear waveform\n        - `...fn(f(t,...))\n            .piecewise_constant(durations, values)`:\n            to append a piecewise constant waveform\n        - `...fn(f(t,...))\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...fn(f(t,...))\n            .apply(waveform)`: to append a pre-defined waveform\n        - `...fn(f(t,...))\n            .fn(f(t,...))`: to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...fn(f(t,...)).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...fn(f(t,...)).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...fn(f(t,...)).uniform`:\n            To address all atoms in the field\n        - `...fn(f(t,...)).scale(...)`:\n            To address an atom at a specific location via index\n        - ...fn(f(t,...)).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...fn(f(t,...))\n            .assign(variable_name = value)`: to assign a single value to a variable\n        - `...fn(f(t,...))\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...fn(f(t,...))\n            .args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...fn(f(t,...)).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...fn(f(t,...)).bloqade`:\n            to run on the Bloqade local emulator\n        - `...fn(f(t,...)).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...fn(f(t,...)).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...fn(f(t,...)).rydberg`:\n            to target the Rydberg level coupling\n        - `...fn(f(t,...)).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...fn(f(t,...)).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...fn(f(t,...)).phase`:\n            to target the real-valued Rabi Phase field\n        - `...fn(f(t,...)).detuning`:\n            to target the Detuning field\n        - `...fn(f(t,...)).rabi`:\n            to target the complex-valued Rabi field\n\n    \"\"\"\n    return Fn(fn, duration, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.linear","title":"linear","text":"<pre><code>linear(\n    start: ScalarType,\n    stop: ScalarType,\n    duration: ScalarType,\n) -&gt; Linear\n</code></pre> <p>Append or assign a linear waveform to the current location(s).</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.linear--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# apply a linear waveform that goes from 0 to 1 radians/us in 0.5 us\n&gt;&gt;&gt; prog.linear(start=0,stop=1,duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...linear(start, stop, duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...linear(start, stop, duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...linear(start, stop, duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...linear(start, stop, duration)     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...linear(start, stop, duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...linear(start, stop, duration).apply(wf:bloqade.ir.Waveform)</code>:     to append a pre-defined waveform</li> <li><code>...linear(start, stop, duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...linear(start, stop, duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...linear(start, stop, duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation     (this drive will be summed to the one you just created):<ul> <li><code>...linear(start, stop, duration).uniform</code>:     To address all atoms in the field</li> <li><code>...linear(start, stop, duration).location(int)</code>:     To address atoms at specific location with scaling</li> <li><code>...linear(start, stop, duration).scale(...)</code><ul> <li>To address atoms at specific location with scaling</li> <li>To address multiple atoms at specific locations by specifying     a single variable and then assigning it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...linear(start, stop, duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...linear(start, stop, duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...linear(start, stop, duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...linear(start, stop, duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...linear(start, stop, duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...linear(start, stop, duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...linear(start, stop, duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...linear(start, stop, duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...linear(start, stop, duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...linear(start, stop, duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...linear(start, stop, duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...linear(start, stop, duration).detuning</code>:     to target the Detuning field</li> <li><code>...linear(start, stop, duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef linear(\n    self, start: ScalarType, stop: ScalarType, duration: ScalarType\n) -&gt; \"Linear\":\n    \"\"\"\n\n    Append or assign a linear waveform to the current location(s).\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # apply a linear waveform that goes from 0 to 1 radians/us in 0.5 us\n    &gt;&gt;&gt; prog.linear(start=0,stop=1,duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...linear(start, stop, duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...linear(start, stop, duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...linear(start, stop, duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...linear(start, stop, duration)\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...linear(start, stop, duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...linear(start, stop, duration).apply(wf:bloqade.ir.Waveform)`:\n            to append a pre-defined waveform\n        - `...linear(start, stop, duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...linear(start, stop, duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...linear(start, stop, duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n        (this drive will be summed to the one you just created):\n        - `...linear(start, stop, duration).uniform`:\n            To address all atoms in the field\n        - `...linear(start, stop, duration).location(int)`:\n            To address atoms at specific location with scaling\n        - `...linear(start, stop, duration).scale(...)`\n            - To address atoms at specific location with scaling\n            - To address multiple atoms at specific locations by specifying\n                a single variable and then assigning it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...linear(start, stop, duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...linear(start, stop, duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...linear(start, stop, duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...linear(start, stop, duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...linear(start, stop, duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...linear(start, stop, duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...linear(start, stop, duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...linear(start, stop, duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...linear(start, stop, duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...linear(start, stop, duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...linear(start, stop, duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...linear(start, stop, duration).detuning`:\n            to target the Detuning field\n        - `...linear(start, stop, duration).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n\n    return Linear(start, stop, duration, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.piecewise_constant","title":"piecewise_constant","text":"<pre><code>piecewise_constant(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; PiecewiseConstant\n</code></pre> <p>Append or assign a piecewise constant waveform to current location(s).</p> <p>The <code>durations</code> argument should have number of elements = len(values). <code>durations</code> should be the duration PER section of the waveform, NON-CUMULATIVE.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.piecewise_constant--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.phase.uniform\n# create a staircase, we hold 0.0 rad/us for 1.0 us, then\n# to 1.0 rad/us for 0.5 us before stopping at 0.8 rad/us for 0.9 us.\n&gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3], values=[1.0, 0.5, 0.9])\n</code></pre> <ul> <li>Your next steps including:</li> <li>Continue building your waveform via:<ul> <li><code>...piecewise_constant([durations], [values])     .linear(start, stop, duration)</code>: to append another linear waveform</li> <li><code>...piecewise_constant([durations], [values])     .constant(value, duration)</code>: to append a constant waveform</li> <li><code>...piecewise_constant([durations], [values])     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...piecewise_constant([durations], [values])     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...piecewise_constant([durations], [values])     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...piecewise_constant([durations], [values])     .apply(waveform)</code>: to append a pre-defined waveform</li> <li><code>...piecewise_constant([durations], [values]).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...piecewise_constant([durations], [values])     .slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...piecewise_constant([durations], [values])     .record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...piecewise_constant([durations], [values]).uniform</code>:     To address all atoms in the field</li> <li><code>...piecewise_constant([durations], [values]).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...piecewise_constant([durations], [values]).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...piecewise_constant([durations], [values])     .assign(variable_name = value)</code>: to assign a single value to a variable</li> <li><code>...piecewise_constant([durations], [values])     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...piecewise_constant([durations], [values])     .args([\"previously_defined_var\"])</code>: to defer assignment     of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...piecewise_constant([durations], [values]).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...piecewise_constant([durations], [values]).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...piecewise_constant([durations], [values]).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...piecewise_constat([durations], [values]).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...piecewise_constant([durations], [values]).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...piecewise_constant([durations], [values]).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...piecewise_constant(durations, values).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...piecewise_constant([durations], [values]).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...piecewise_constant([durations], [values]).detuning</code>:     to target the Detuning field</li> <li><code>...piecewise_constant([durations], [values]).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_constant(\n    self, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseConstant\":\n    \"\"\"\n    Append or assign a piecewise constant waveform to current location(s).\n\n    The `durations` argument should have number of elements = len(values).\n    `durations` should be the duration PER section of the waveform,\n    NON-CUMULATIVE.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.rabi.phase.uniform\n    # create a staircase, we hold 0.0 rad/us for 1.0 us, then\n    # to 1.0 rad/us for 0.5 us before stopping at 0.8 rad/us for 0.9 us.\n    &gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3], values=[1.0, 0.5, 0.9])\n    ```\n\n    - Your next steps including:\n    - Continue building your waveform via:\n        - `...piecewise_constant([durations], [values])\n            .linear(start, stop, duration)`: to append another linear waveform\n        - `...piecewise_constant([durations], [values])\n            .constant(value, duration)`: to append a constant waveform\n        - `...piecewise_constant([durations], [values])\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...piecewise_constant([durations], [values])\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...piecewise_constant([durations], [values])\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...piecewise_constant([durations], [values])\n            .apply(waveform)`: to append a pre-defined waveform\n        - `...piecewise_constant([durations], [values]).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...piecewise_constant([durations], [values])\n            .slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...piecewise_constant([durations], [values])\n            .record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...piecewise_constant([durations], [values]).uniform`:\n            To address all atoms in the field\n        - `...piecewise_constant([durations], [values]).location(int)`:\n            To address an atom at a specific location via index\n        - `...piecewise_constant([durations], [values]).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...piecewise_constant([durations], [values])\n            .assign(variable_name = value)`: to assign a single value to a variable\n        - `...piecewise_constant([durations], [values])\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...piecewise_constant([durations], [values])\n            .args([\"previously_defined_var\"])`: to defer assignment\n            of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...piecewise_constant([durations], [values]).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...piecewise_constant([durations], [values]).bloqade`:\n            to run on the Bloqade local emulator\n        - `...piecewise_constant([durations], [values]).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...piecewise_constat([durations], [values]).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...piecewise_constant([durations], [values]).rydberg`:\n            to target the Rydberg level coupling\n        - `...piecewise_constant([durations], [values]).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...piecewise_constant(durations, values).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...piecewise_constant([durations], [values]).phase`:\n            to target the real-valued Rabi Phase field\n        - `...piecewise_constant([durations], [values]).detuning`:\n            to target the Detuning field\n        - `...piecewise_constant([durations], [values]).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return PiecewiseConstant(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.piecewise_linear","title":"piecewise_linear","text":"<pre><code>piecewise_linear(\n    durations: List[ScalarType], values: List[ScalarType]\n) -&gt; PiecewiseLinear\n</code></pre> <p>Append or assign a piecewise linear waveform to current location(s), where the waveform is formed by connecting <code>values[i], values[i+1]</code> with linear segments.</p> <p>The <code>durations</code> argument should have # of elements = len(values) - 1. <code>durations</code> should be the duration PER section of the waveform, NON-CUMULATIVE.</p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.piecewise_linear--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n# ramp our waveform up to a certain value, hold it\n# then ramp down. In this case, we ramp up to 2.0 rad/us in 0.3 us,\n# then hold it for 1.5 us before ramping down in 0.3 us back to 0.0 rad/us.\n&gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\nvalues=[0.0, 2.0, 2.0, 0.0])\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...piecewise_linear([durations], [values])     .linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...piecewise_linear([durations], [values]).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...piecewise_linear([durations], [values])     .piecewise_linear(durations, values)</code>:     to append a piecewise linear waveform</li> <li><code>...piecewise_linear([durations], [values])     .piecewise_constant([durations], [values])</code>:     to append a piecewise constant waveform</li> <li><code>...piecewise_linear([durations], [values])     .poly([coefficients], duration)</code>: to append a polynomial waveform</li> <li><code>...piecewise_linear([durations], [values]).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...piecewise_linear([durations], [values]).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...piecewise_linear([durations], [values])     .slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...piecewise_linear([durations], [values])     .record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...piecewise_linear([durations], [values]).uniform</code>:     To address all atoms in the field</li> <li><code>...piecewise_linear([durations], [values]).scale(...)</code>:     To address an atom at a specific location via index</li> <li><code>...piecewise_linear([durations], [values]).location(int)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning it a     list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...piecewise_linear([durations], [values])     .assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...piecewise_linear([durations], [values])     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...piecewise_linear([durations], [values])     .args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...piecewise_linear([durations], [values]).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...piecewise_linear([durations], [values]).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...piecewise_linear([durations], [values]).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...piecewise_linear([durations], [values]).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...piecewise_linear([durations], [values]).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...piecewise_linear([durations], [values]).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level coupling   (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...piecewise_linear([durations], [values]).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...piecewise_linear([durations], [values]).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...piecewise_linear([durations], [values]).detuning</code>:     to target the Detuning field</li> <li><code>....rabi</code>: to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef piecewise_linear(\n    self, durations: List[ScalarType], values: List[ScalarType]\n) -&gt; \"PiecewiseLinear\":\n    \"\"\"\n    Append or assign a piecewise linear waveform to current location(s),\n    where the waveform is formed by connecting `values[i], values[i+1]`\n    with linear segments.\n\n    The `durations` argument should have # of elements = len(values) - 1.\n    `durations` should be the duration PER section of the waveform, NON-CUMULATIVE.\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    # ramp our waveform up to a certain value, hold it\n    # then ramp down. In this case, we ramp up to 2.0 rad/us in 0.3 us,\n    # then hold it for 1.5 us before ramping down in 0.3 us back to 0.0 rad/us.\n    &gt;&gt;&gt; prog.piecewise_linear(durations=[0.3, 2.0, 0.3],\n    values=[0.0, 2.0, 2.0, 0.0])\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...piecewise_linear([durations], [values])\n            .linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...piecewise_linear([durations], [values]).constant(value, duration)`:\n            to append a constant waveform\n        - `...piecewise_linear([durations], [values])\n            .piecewise_linear(durations, values)`:\n            to append a piecewise linear waveform\n        - `...piecewise_linear([durations], [values])\n            .piecewise_constant([durations], [values])`:\n            to append a piecewise constant waveform\n        - `...piecewise_linear([durations], [values])\n            .poly([coefficients], duration)`: to append a polynomial waveform\n        - `...piecewise_linear([durations], [values]).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...piecewise_linear([durations], [values]).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...piecewise_linear([durations], [values])\n            .slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...piecewise_linear([durations], [values])\n            .record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...piecewise_linear([durations], [values]).uniform`:\n            To address all atoms in the field\n        - `...piecewise_linear([durations], [values]).scale(...)`:\n            To address an atom at a specific location via index\n        - `...piecewise_linear([durations], [values]).location(int)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning it a\n                list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...piecewise_linear([durations], [values])\n            .assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...piecewise_linear([durations], [values])\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...piecewise_linear([durations], [values])\n            .args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...piecewise_linear([durations], [values]).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...piecewise_linear([durations], [values]).bloqade`:\n            to run on the Bloqade local emulator\n        - `...piecewise_linear([durations], [values]).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...piecewise_linear([durations], [values]).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...piecewise_linear([durations], [values]).rydberg`:\n            to target the Rydberg level coupling\n        - `...piecewise_linear([durations], [values]).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level coupling\n      (previously selected as `rydberg` or `hyperfine`):\n        - `...piecewise_linear([durations], [values]).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...piecewise_linear([durations], [values]).phase`:\n            to target the real-valued Rabi Phase field\n        - `...piecewise_linear([durations], [values]).detuning`:\n            to target the Detuning field\n        - `....rabi`: to target the complex-valued Rabi field\n    \"\"\"\n    return PiecewiseLinear(durations, values, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.poly","title":"poly","text":"<pre><code>poly(\n    coeffs: List[ScalarType], duration: ScalarType\n) -&gt; Poly\n</code></pre> <p>Append or assign a waveform with a polynomial profile to current location(s).</p> <p>You pass in a list of coefficients and a duration to this method which obeys the following expression:</p> <p><code>wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n</code></p> <p>If you specified a spatial modulation (e.g. <code>uniform</code>, <code>location</code>,<code>scale</code>) previously without a waveform you will now have completed the construction of a \"drive\", one or a sum of drives creating a \"field\" (e.g. Real-valued Rabi Amplitude/Phase).</p> <p>If you have already specified a waveform previously you will now be appending this waveform to that previous waveform.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/waveform/#bloqade.analog.builder.waveform.WaveformAttachable.poly--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n&gt;&gt;&gt; coeffs = [-1, 0.5, 1.2]\n# resulting polynomial is:\n# f(t) = -1 + 0.5*t + 1.2*t^2 with duration of\n# 0.5 us\n&gt;&gt;&gt; prog.poly(coeffs, duration=0.5)\n</code></pre> <ul> <li>Your next steps include:</li> <li>Continue building your waveform via:<ul> <li><code>...poly([coeffs], duration).linear(start, stop, duration)</code>:     to append another linear waveform</li> <li><code>...poly([coeffs], duration).constant(value, duration)</code>:     to append a constant waveform</li> <li><code>...poly([coeffs], duration)     .piecewise_linear([durations], [values])</code>:     to append a piecewise linear waveform</li> <li><code>...poly([coeffs], duration)     .piecewise_constant([durations],[values])</code>:     to append a piecewise constant waveform</li> <li><code>...poly([coeffs], duration).poly([coefficients], duration)</code>:     to append a polynomial waveform</li> <li><code>...poly([coeffs], duration).apply(waveform)</code>:     to append a pre-defined waveform</li> <li><code>...poly([coeffs], duration).fn(f(t,...))</code>:     to append a waveform defined by a python function</li> </ul> </li> <li>Slice a portion of the waveform to be used:<ul> <li><code>...poly([coeffs], duration).slice(start, stop, duration)</code></li> </ul> </li> <li>Save the ending value of your waveform to be reused elsewhere<ul> <li><code>...poly([coeffs], duration).record(\"you_variable_here\")</code></li> </ul> </li> <li>Begin constructing another drive by starting a new spatial modulation   (this drive will be summed to the one you just created):<ul> <li><code>...poly([coeffs], duration).uniform</code>:     To address all atoms in the field</li> <li><code>...poly([coeffs], duration).location(int)</code>:     To address an atom at a specific location via index</li> <li><code>...poly([coeffs], duration).scale(...)</code><ul> <li>To address an atom at a specific location via variable</li> <li>To address multiple atoms at specific locations by     specifying a single variable and then assigning     it a list of coordinates</li> </ul> </li> </ul> </li> <li>Assign values to pre-existing variables via:<ul> <li><code>...poly([coeffs], duration).assign(variable_name = value)</code>:     to assign a single value to a variable</li> <li><code>...poly([coeffs], duration)     .batch_assign(variable_name = [value1, ...])</code>:     to assign multiple values to a variable</li> <li><code>...poly([coeffs], duration).args([\"previously_defined_var\"])</code>:     to defer assignment of a variable to execution time</li> </ul> </li> <li>Select the backend you want your program to run on via:<ul> <li><code>...poly([coeffs], duration).braket</code>:     to run on Braket local emulator or QuEra hardware remotely</li> <li><code>...poly([coeffs], duration).bloqade</code>:     to run on the Bloqade local emulator</li> <li><code>...poly([coeffs], duration).device</code>:     to specify the backend via string</li> </ul> </li> <li>Choose to parallelize your atom geometry,   duplicating it to fill the whole space:<ul> <li><code>...poly([coeffs], duration).parallelize(spacing)</code></li> </ul> </li> <li>Start targeting another level coupling<ul> <li><code>...poly([coeffs], duration).rydberg</code>:     to target the Rydberg level coupling</li> <li><code>...poly([coeffs], duration).hyperfine</code>:     to target the Hyperfine level coupling</li> </ul> </li> <li>Start targeting other fields within your current level   coupling (previously selected as <code>rydberg</code> or <code>hyperfine</code>):<ul> <li><code>...poly([coeffs], duration).amplitude</code>:     to target the real-valued Rabi Amplitude field</li> <li><code>...poly([coeffs], duration).phase</code>:     to target the real-valued Rabi Phase field</li> <li><code>...poly([coeffs], duration).detuning</code>:     to target the Detuning field</li> <li><code>...poly([coeffs], duration).rabi</code>:     to target the complex-valued Rabi field</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/waveform.py</code> <pre><code>@beartype\ndef poly(self, coeffs: List[ScalarType], duration: ScalarType) -&gt; \"Poly\":\n    \"\"\"\n    Append or assign a waveform with a polynomial profile to current location(s).\n\n    You pass in a list of coefficients and a duration to this method which obeys\n    the following expression:\n\n    `\n    wv(t) = coeffs[0] + coeffs[1]*t + coeffs[2]*t^2 + ... + coeffs[n]*t^n\n    `\n\n    If you specified a spatial modulation (e.g. `uniform`, `location`,`scale`)\n    previously without a waveform you will now have completed the construction\n    of a \"drive\", one or a sum of drives creating a \"field\"\n    (e.g. Real-valued Rabi Amplitude/Phase).\n\n    If you have already specified a waveform previously you will now be appending\n    this waveform to that previous waveform.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; prog = start.add_position((0,0)).rydberg.detuning.uniform\n    &gt;&gt;&gt; coeffs = [-1, 0.5, 1.2]\n    # resulting polynomial is:\n    # f(t) = -1 + 0.5*t + 1.2*t^2 with duration of\n    # 0.5 us\n    &gt;&gt;&gt; prog.poly(coeffs, duration=0.5)\n    ```\n\n    - Your next steps include:\n    - Continue building your waveform via:\n        - `...poly([coeffs], duration).linear(start, stop, duration)`:\n            to append another linear waveform\n        - `...poly([coeffs], duration).constant(value, duration)`:\n            to append a constant waveform\n        - `...poly([coeffs], duration)\n            .piecewise_linear([durations], [values])`:\n            to append a piecewise linear waveform\n        - `...poly([coeffs], duration)\n            .piecewise_constant([durations],[values])`:\n            to append a piecewise constant waveform\n        - `...poly([coeffs], duration).poly([coefficients], duration)`:\n            to append a polynomial waveform\n        - `...poly([coeffs], duration).apply(waveform)`:\n            to append a pre-defined waveform\n        - `...poly([coeffs], duration).fn(f(t,...))`:\n            to append a waveform defined by a python function\n    - Slice a portion of the waveform to be used:\n        - `...poly([coeffs], duration).slice(start, stop, duration)`\n    - Save the ending value of your waveform to be reused elsewhere\n        - `...poly([coeffs], duration).record(\"you_variable_here\")`\n    - Begin constructing another drive by starting a new spatial modulation\n      (this drive will be summed to the one you just created):\n        - `...poly([coeffs], duration).uniform`:\n            To address all atoms in the field\n        - `...poly([coeffs], duration).location(int)`:\n            To address an atom at a specific location via index\n        - `...poly([coeffs], duration).scale(...)`\n            - To address an atom at a specific location via variable\n            - To address multiple atoms at specific locations by\n                specifying a single variable and then assigning\n                it a list of coordinates\n    - Assign values to pre-existing variables via:\n        - `...poly([coeffs], duration).assign(variable_name = value)`:\n            to assign a single value to a variable\n        - `...poly([coeffs], duration)\n            .batch_assign(variable_name = [value1, ...])`:\n            to assign multiple values to a variable\n        - `...poly([coeffs], duration).args([\"previously_defined_var\"])`:\n            to defer assignment of a variable to execution time\n    - Select the backend you want your program to run on via:\n        - `...poly([coeffs], duration).braket`:\n            to run on Braket local emulator or QuEra hardware remotely\n        - `...poly([coeffs], duration).bloqade`:\n            to run on the Bloqade local emulator\n        - `...poly([coeffs], duration).device`:\n            to specify the backend via string\n    - Choose to parallelize your atom geometry,\n      duplicating it to fill the whole space:\n        - `...poly([coeffs], duration).parallelize(spacing)`\n    - Start targeting another level coupling\n        - `...poly([coeffs], duration).rydberg`:\n            to target the Rydberg level coupling\n        - `...poly([coeffs], duration).hyperfine`:\n            to target the Hyperfine level coupling\n    - Start targeting other fields within your current level\n      coupling (previously selected as `rydberg` or `hyperfine`):\n        - `...poly([coeffs], duration).amplitude`:\n            to target the real-valued Rabi Amplitude field\n        - `...poly([coeffs], duration).phase`:\n            to target the real-valued Rabi Phase field\n        - `...poly([coeffs], duration).detuning`:\n            to target the Detuning field\n        - `...poly([coeffs], duration).rabi`:\n            to target the complex-valued Rabi field\n    \"\"\"\n    return Poly(coeffs, duration, self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/#bloqade.analog.builder.backend.BackendRoute","title":"BackendRoute","text":"<pre><code>BackendRoute(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>QuEraService</code>, <code>BraketService</code>, <code>BloqadeService</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.BackendRoute[BackendRoute]\n              bloqade.analog.builder.backend.quera.QuEraService[QuEraService]\n              bloqade.analog.builder.backend.braket.BraketService[BraketService]\n              bloqade.analog.builder.backend.bloqade.BloqadeService[BloqadeService]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.backend.quera.QuEraService --&gt; bloqade.analog.builder.backend.BackendRoute\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.quera.QuEraService\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n                bloqade.analog.builder.backend.braket.BraketService --&gt; bloqade.analog.builder.backend.BackendRoute\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.braket.BraketService\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n                bloqade.analog.builder.backend.bloqade.BloqadeService --&gt; bloqade.analog.builder.backend.BackendRoute\n                                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.bloqade.BloqadeService\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.builder.backend.BackendRoute href \"\" \"bloqade.analog.builder.backend.BackendRoute\"\n              click bloqade.analog.builder.backend.quera.QuEraService href \"\" \"bloqade.analog.builder.backend.quera.QuEraService\"\n              click bloqade.analog.builder.backend.braket.BraketService href \"\" \"bloqade.analog.builder.backend.braket.BraketService\"\n              click bloqade.analog.builder.backend.bloqade.BloqadeService href \"\" \"bloqade.analog.builder.backend.bloqade.BloqadeService\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Specify the backend to run your program on via a string (versus more formal builder syntax) of specifying the vendor/product first (Bloqade/Braket) and narrowing it down (e.g: ...device(\"quera.aquila\") versus ...quera.aquila()) - You can pass the following arguments:     - <code>\"braket.aquila\"</code>     - <code>\"braket.local_emulator\"</code>     - <code>\"bloqade.python\"</code>     - <code>\"bloqade.julia\"</code></p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/bloqade/#bloqade.analog.builder.backend.bloqade.BloqadeDeviceRoute","title":"BloqadeDeviceRoute","text":"<pre><code>BloqadeDeviceRoute(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.bloqade.BloqadeDeviceRoute[BloqadeDeviceRoute]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.bloqade.BloqadeDeviceRoute\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.backend.bloqade.BloqadeDeviceRoute href \"\" \"bloqade.analog.builder.backend.bloqade.BloqadeDeviceRoute\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/bloqade/#bloqade.analog.builder.backend.bloqade.BloqadeDeviceRoute.python","title":"python","text":"<pre><code>python()\n</code></pre> <p>Specify the Bloqade Python backend.</p> <ul> <li>Possible Next Steps:<ul> <li><code>...python().run(shots)</code>:     to submit to the python emulator and await results</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/bloqade.py</code> <pre><code>def python(self):\n    \"\"\"\n    Specify the Bloqade Python backend.\n\n    - Possible Next Steps:\n        - `...python().run(shots)`:\n            to submit to the python emulator and await results\n    \"\"\"\n    return self.parse().bloqade.python()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/bloqade/#bloqade.analog.builder.backend.bloqade.BloqadeService","title":"BloqadeService","text":"<pre><code>BloqadeService(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.bloqade.BloqadeService[BloqadeService]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.bloqade.BloqadeService\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.backend.bloqade.BloqadeService href \"\" \"bloqade.analog.builder.backend.bloqade.BloqadeService\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/bloqade/#bloqade.analog.builder.backend.bloqade.BloqadeService.bloqade","title":"bloqade  <code>property</code>","text":"<pre><code>bloqade\n</code></pre> <p>Specify the Bloqade backend.</p> <ul> <li>Possible Next Steps:<ul> <li><code>...bloqade.python()</code>: target submission to the Bloqade python backend</li> <li><code>...bloqade.julia()</code>: (CURRENTLY NOT IMPLEMENTED!)target     submission to the Bloqade.jl backend</li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/","title":"Braket","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/#bloqade.analog.builder.backend.braket.BraketDeviceRoute","title":"BraketDeviceRoute","text":"<pre><code>BraketDeviceRoute(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.braket.BraketDeviceRoute[BraketDeviceRoute]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.braket.BraketDeviceRoute\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.backend.braket.BraketDeviceRoute href \"\" \"bloqade.analog.builder.backend.braket.BraketDeviceRoute\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/#bloqade.analog.builder.backend.braket.BraketDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila() -&gt; BraketHardwareRoutine\n</code></pre> <p>Specify QuEra's Aquila QPU on Braket to submit your program to.</p> <p>The number of shots you specify in the subsequent <code>.run</code> method will either:     - dictate the number of times your program is run     - dictate the number of times per parameter your program is run if       you have a variable with batch assignments/intend to conduct       a parameter sweep</p> <ul> <li>Possible next steps are:<ul> <li><code>...aquila().run(shots)</code>: To submit to hardware and WAIT for     results (blocking)</li> <li><code>...aquila().run_async(shots)</code>: To submit to hardware and immediately     allow for other operations to occur</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/braket.py</code> <pre><code>def aquila(self) -&gt; \"BraketHardwareRoutine\":\n    \"\"\"\n    Specify QuEra's Aquila QPU on Braket to submit your program to.\n\n    The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n          you have a variable with batch assignments/intend to conduct\n          a parameter sweep\n\n\n    - Possible next steps are:\n        - `...aquila().run(shots)`: To submit to hardware and WAIT for\n            results (blocking)\n        - `...aquila().run_async(shots)`: To submit to hardware and immediately\n            allow for other operations to occur\n    \"\"\"\n    return self.parse().braket.aquila()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/#bloqade.analog.builder.backend.braket.BraketDeviceRoute.device","title":"device","text":"<pre><code>device(device_arn) -&gt; BraketHardwareRoutine\n</code></pre> <p>Specify QPU based on the device ARN on Braket to submit your program to.</p> <p>The number of shots you specify in the subsequent <code>.run</code> method will either:     - dictate the number of times your program is run     - dictate the number of times per parameter your program is run if         you have a variable with batch assignments/intend to conduct         a parameter sweep</p> <ul> <li>Possible next steps are:<ul> <li><code>...device(arn).run(shots)</code>: To submit to hardware and WAIT for     results (blocking)</li> <li><code>...device(arn).run_async(shots)</code>: To submit to hardware and immediately     allow for other operations to occur</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/braket.py</code> <pre><code>def device(self, device_arn) -&gt; \"BraketHardwareRoutine\":\n    \"\"\"\n    Specify QPU based on the device ARN on Braket to submit your program to.\n\n    The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n            you have a variable with batch assignments/intend to conduct\n            a parameter sweep\n\n\n    - Possible next steps are:\n        - `...device(arn).run(shots)`: To submit to hardware and WAIT for\n            results (blocking)\n        - `...device(arn).run_async(shots)`: To submit to hardware and immediately\n            allow for other operations to occur\n    \"\"\"\n    return self.parse().braket.device(device_arn)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/#bloqade.analog.builder.backend.braket.BraketDeviceRoute.local_emulator","title":"local_emulator","text":"<pre><code>local_emulator() -&gt; BraketLocalEmulatorRoutine\n</code></pre> <p>Specify the Braket local emulator to submit your program to.</p> <ul> <li>The number of shots you specify in the subsequent <code>.run</code> method will either:<ul> <li>dictate the number of times your program is run</li> <li>dictate the number of times per parameter your program is run if   you have a variable with batch assignments/intend to   conduct a parameter sweep</li> </ul> </li> <li>Possible next steps are:<ul> <li><code>...local_emulator().run(shots)</code>: to submit to the emulator     and await results</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/braket.py</code> <pre><code>def local_emulator(self) -&gt; \"BraketLocalEmulatorRoutine\":\n    \"\"\"\n    Specify the Braket local emulator to submit your program to.\n\n    - The number of shots you specify in the subsequent `.run` method will either:\n        - dictate the number of times your program is run\n        - dictate the number of times per parameter your program is run if\n          you have a variable with batch assignments/intend to\n          conduct a parameter sweep\n    - Possible next steps are:\n        - `...local_emulator().run(shots)`: to submit to the emulator\n            and await results\n\n    \"\"\"\n    return self.parse().braket.local_emulator()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/#bloqade.analog.builder.backend.braket.BraketService","title":"BraketService","text":"<pre><code>BraketService(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.braket.BraketService[BraketService]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.braket.BraketService\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.backend.braket.BraketService href \"\" \"bloqade.analog.builder.backend.braket.BraketService\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/braket/#bloqade.analog.builder.backend.braket.BraketService.braket","title":"braket  <code>property</code>","text":"<pre><code>braket\n</code></pre> <p>Specify the Braket backend. This allows you to access the AWS Braket local emulator OR go submit things to QuEra hardware on AWS Braket service.</p> <ul> <li>Possible Next Steps are:<ul> <li><code>...braket.aquila()</code>: target submission to the QuEra Aquila QPU</li> <li><code>...braket.local_emulator()</code>: target submission to the Braket local emulator</li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/","title":"Quera","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraDeviceRoute","title":"QuEraDeviceRoute","text":"<pre><code>QuEraDeviceRoute(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.quera.QuEraDeviceRoute[QuEraDeviceRoute]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.quera.QuEraDeviceRoute\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.backend.quera.QuEraDeviceRoute href \"\" \"bloqade.analog.builder.backend.quera.QuEraDeviceRoute\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraDeviceRoute.aquila","title":"aquila","text":"<pre><code>aquila()\n</code></pre> <p>Specify QuEra's Aquila QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/quera.py</code> <pre><code>def aquila(self):\n    \"\"\"\n    Specify QuEra's Aquila QPU\n\n    Return:\n        QuEraHardwareRoutine\n\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n    \"\"\"\n    return self.parse().quera.aquila()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraDeviceRoute.cloud_mock","title":"cloud_mock","text":"<pre><code>cloud_mock()\n</code></pre> <p>Specify QuEra's Remote Mock QPU</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/quera.py</code> <pre><code>def cloud_mock(self):\n    \"\"\"\n    Specify QuEra's Remote Mock QPU\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n\n    \"\"\"\n    return self.parse().quera.cloud_mock()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraDeviceRoute.custom","title":"custom","text":"<pre><code>custom()\n</code></pre> <p>Specify custom backend</p> Return <p>CustomSubmissionRoutine</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/quera.py</code> <pre><code>def custom(self):\n    \"\"\"\n    Specify custom backend\n\n    Return:\n        CustomSubmissionRoutine\n\n    \"\"\"\n\n    return self.parse().quera.custom()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraDeviceRoute.device","title":"device","text":"<pre><code>device(config_file: Optional[str] = None, **api_config)\n</code></pre> <p>Specify QuEra's QPU device,</p> <p>Parameters:</p> Name Type Description Default <code>config_file</code> <code>str</code> <p>file that speficy the target hardware</p> <code>None</code> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...device().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...device().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...device().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/quera.py</code> <pre><code>def device(self, config_file: Optional[str] = None, **api_config):\n    \"\"\"\n    Specify QuEra's QPU device,\n\n    Args:\n        config_file (str): file that speficy the target hardware\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...device().submit`\n            :: submit aync remote job\n\n        -&gt; `...device().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...device().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n    \"\"\"\n    return self.parse().quera.device(config_file, **api_config)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraDeviceRoute.mock","title":"mock","text":"<pre><code>mock(\n    state_file: str = \".mock_state.txt\",\n    submission_error: bool = False,\n)\n</code></pre> <p>Specify mock, testing locally.</p> Return <p>QuEraHardwareRoutine</p> <ul> <li> <p>Possible Next:</p> <p>-&gt; <code>...aquila().submit</code>     :: submit aync remote job</p> <p>-&gt; <code>...aquila().run</code>     :: submit job and wait until job finished     and results returned</p> <p>-&gt; <code>...aquila().__callable__</code>     :: submit job and wait until job finished     and results returned</p> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/backend/quera.py</code> <pre><code>def mock(self, state_file: str = \".mock_state.txt\", submission_error: bool = False):\n    \"\"\"\n    Specify mock, testing locally.\n\n    Return:\n        QuEraHardwareRoutine\n\n    - Possible Next:\n\n        -&gt; `...aquila().submit`\n            :: submit aync remote job\n\n        -&gt; `...aquila().run`\n            :: submit job and wait until job finished\n            and results returned\n\n        -&gt; `...aquila().__callable__`\n            :: submit job and wait until job finished\n            and results returned\n\n\n\n    \"\"\"\n    return self.parse().quera.mock(\n        state_file=state_file, submission_error=submission_error\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraService","title":"QuEraService","text":"<pre><code>QuEraService(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>Builder</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.backend.quera.QuEraService[QuEraService]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.backend.quera.QuEraService\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n              click bloqade.analog.builder.backend.quera.QuEraService href \"\" \"bloqade.analog.builder.backend.quera.QuEraService\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/backend/quera/#bloqade.analog.builder.backend.quera.QuEraService.quera","title":"quera  <code>property</code>","text":"<pre><code>quera\n</code></pre> <ul> <li>Specify Quera backend</li> <li> <p>Possible Next:</p> <p>-&gt; <code>...quera.aquila</code>     :: Aquila QPU</p> <p>-&gt; <code>...quera.mock</code>     :: mock backend, meant for testings</p> <p>-&gt; <code>...quera.device</code>     :: QuEra QPU, specifiy by config_file</p> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/","title":"Builder","text":"<p>Module for parsing builder definitions into intermediate representation (IR) using the bloqade library.</p> <p>This module provides a Parser class for parsing various components of a quantum computing program, including atom arrangements, pulse sequences, analog circuits, and routines. It also defines utility functions for reading addresses, waveforms, drives, sequences, registers, and pragmas from a builder stream.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser","title":"Parser","text":"<p>A class for parsing quantum computing program components into intermediate representation (IR).</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.parse","title":"parse","text":"<pre><code>parse(builder: Builder) -&gt; Routine\n</code></pre> <p>Parse a routine from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>The parsed routine.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def parse(self, builder: Builder) -&gt; \"Routine\":\n    \"\"\"\n    Parse a routine from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        Routine: The parsed routine.\n    \"\"\"\n    from bloqade.analog.ir.routine.base import Routine\n    from bloqade.analog.ir.analog_circuit import AnalogCircuit\n    from bloqade.analog.ir.routine.params import Params, ScalarArg, VectorArg\n    from bloqade.analog.compiler.analysis.common.scan_variables import ScanVariables\n\n    self.reset(builder)\n    self.read_register()\n    self.read_sequence()\n    self.read_pragmas()\n\n    circuit = AnalogCircuit(self.register, self.sequence)\n\n    var_res = ScanVariables().scan(circuit)\n    # mark vector and scalar arguments\n    args_list = [\n        (VectorArg(name) if name in var_res.vector_vars else ScalarArg(name))\n        for name in self.order\n    ]\n\n    params = Params(\n        n_sites=self.register.n_sites,\n        static_params=self.static_params,\n        batch_params=self.batch_params,\n        args_list=args_list,\n    )\n\n    return Routine(builder, circuit, params)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit(builder: Builder) -&gt; AnalogCircuit\n</code></pre> <p>Parse an analog circuit from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Name Type Description <code>AnalogCircuit</code> <code>AnalogCircuit</code> <p>The parsed analog circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def parse_circuit(self, builder: Builder) -&gt; \"AnalogCircuit\":\n    \"\"\"\n    Parse an analog circuit from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        AnalogCircuit: The parsed analog circuit.\n    \"\"\"\n    from bloqade.analog.ir.analog_circuit import AnalogCircuit\n\n    self.reset(builder)\n    self.read_register()\n    self.read_sequence()\n\n    circuit = AnalogCircuit(self.register, self.sequence)\n\n    return circuit\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.parse_register","title":"parse_register","text":"<pre><code>parse_register(\n    builder: Builder,\n) -&gt; Union[ir.AtomArrangement, ir.ParallelRegister]\n</code></pre> <p>Parse an atom arrangement register from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Type Description <code>Union[AtomArrangement, ParallelRegister]</code> <p>Union[ir.AtomArrangement, ir.ParallelRegister]: The parsed atom arrangement or parallel register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def parse_register(\n    self, builder: Builder\n) -&gt; Union[ir.AtomArrangement, ir.ParallelRegister]:\n    \"\"\"\n    Parse an atom arrangement register from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        Union[ir.AtomArrangement, ir.ParallelRegister]: The parsed atom arrangement or parallel register.\n    \"\"\"\n    self.reset(builder)\n    self.read_register()\n    self.read_pragmas()\n    return self.register\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence(builder: Builder) -&gt; ir.Sequence\n</code></pre> <p>Parse a sequence from the builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The builder instance.</p> required <p>Returns:</p> Type Description <code>Sequence</code> <p>ir.Sequence: The parsed sequence.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def parse_sequence(self, builder: Builder) -&gt; ir.Sequence:\n    \"\"\"\n    Parse a sequence from the builder.\n\n    Args:\n        builder (Builder): The builder instance.\n\n    Returns:\n        ir.Sequence: The parsed sequence.\n    \"\"\"\n    self.reset(builder)\n    self.read_sequence()\n    return self.sequence\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.read_address","title":"read_address","text":"<pre><code>read_address(\n    stream,\n) -&gt; Tuple[LevelCoupling, Field, BuilderNode]\n</code></pre> <p>Read an address from the builder stream.</p> <p>Parameters:</p> Name Type Description Default <code>stream</code> <p>The builder stream.</p> required <p>Returns:</p> Type Description <code>Tuple[LevelCoupling, Field, BuilderNode]</code> <p>Tuple[LevelCoupling, Field, BuilderNode]: A tuple containing the level coupling, field, and spatial modulation.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def read_address(self, stream) -&gt; Tuple[LevelCoupling, Field, BuilderNode]:\n    \"\"\"\n    Read an address from the builder stream.\n\n    Args:\n        stream: The builder stream.\n\n    Returns:\n        Tuple[LevelCoupling, Field, BuilderNode]: A tuple containing the level coupling, field, and spatial modulation.\n    \"\"\"\n    spatial = stream.read_next([Location, Uniform, Scale])\n    curr = spatial\n\n    if curr is None:\n        return (None, None, None)\n\n    while curr.next is not None:\n        if not isinstance(curr.node, SpatialModulation):\n            break\n        curr = curr.next\n\n    if type(spatial.node.__parent__) in [Detuning, RabiAmplitude, RabiPhase]:\n        field = spatial.node.__parent__  # field is updated\n        if type(field) in [RabiAmplitude, RabiPhase]:\n            coupling = field.__parent__.__parent__  # skip Rabi\n        else:\n            coupling = field.__parent__\n\n        # coupling not updated\n        if type(coupling) not in [Rydberg, Hyperfine]:\n            coupling = None\n        return (coupling, field, spatial)\n    else:  # only spatial is updated\n        return (None, None, spatial)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.read_drive","title":"read_drive","text":"<pre><code>read_drive(head) -&gt; ir.Field\n</code></pre> <p>Read a drive from the builder stream.</p> <p>Parameters:</p> Name Type Description Default <code>head</code> <p>The head of the builder stream.</p> required <p>Returns:</p> Type Description <code>Field</code> <p>ir.Field: The drive field.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def read_drive(self, head) -&gt; ir.Field:\n    \"\"\"\n    Read a drive from the builder stream.\n\n    Args:\n        head: The head of the builder stream.\n\n    Returns:\n        ir.Field: The drive field.\n    \"\"\"\n    if head is None:\n        return ir.Field({})\n\n    sm = head.node.__bloqade_ir__()\n    wf, _ = self.read_waveform(head.next)\n\n    return ir.Field({sm: wf})\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.read_pragmas","title":"read_pragmas","text":"<pre><code>read_pragmas() -&gt; None\n</code></pre> <p>Read pragmas from the builder stream.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def read_pragmas(self) -&gt; None:\n    \"\"\"Read pragmas from the builder stream.\"\"\"\n    pragma_types = (\n        Assign,\n        BatchAssign,\n        ListAssign,\n        Args,\n        Parallelize,\n    )\n\n    stream = self.stream.copy()\n    curr = stream.read_next(pragma_types)\n\n    while curr is not None:\n        node = curr.node\n\n        if isinstance(node, Assign):\n            self.static_params = dict(node._static_params)\n        elif isinstance(node, BatchAssign) or isinstance(node, ListAssign):\n            self.batch_params = node._batch_params\n        elif isinstance(node, Args):\n            order = node._order\n\n            seen = set()\n            dup = []\n            for x in order:\n                if x not in seen:\n                    seen.add(x)\n                else:\n                    dup.append(x)\n\n            if dup:\n                raise ValueError(f\"Cannot have duplicate names {dup}.\")\n\n            self.order = order\n\n        elif isinstance(node, Parallelize):\n            self.register = ir.ParallelRegister(\n                self.register, node._cluster_spacing\n            )\n        else:\n            break\n\n        curr = curr.next\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.read_register","title":"read_register","text":"<pre><code>read_register() -&gt; ir.AtomArrangement\n</code></pre> <p>Read an atom arrangement register from the builder stream.</p> <p>Returns:</p> Type Description <code>AtomArrangement</code> <p>ir.AtomArrangement: The parsed atom arrangement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def read_register(self) -&gt; ir.AtomArrangement:\n    \"\"\"\n    Read an atom arrangement register from the builder stream.\n\n    Returns:\n        ir.AtomArrangement: The parsed atom arrangement.\n    \"\"\"\n    # register is always head of the stream\n    register_node = self.stream.read()\n    self.register = register_node.node\n\n    return self.register\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.read_sequence","title":"read_sequence","text":"<pre><code>read_sequence() -&gt; ir.Sequence\n</code></pre> <p>Read a sequence from the builder stream.</p> <p>Returns:</p> Type Description <code>Sequence</code> <p>ir.Sequence: The parsed sequence.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def read_sequence(self) -&gt; ir.Sequence:\n    \"\"\"\n    Read a sequence from the builder stream.\n\n    Returns:\n        ir.Sequence: The parsed sequence.\n    \"\"\"\n    if isinstance(self.stream.curr.node, SequenceBuilder):\n        # case with sequence builder object.\n        self.sequence = self.stream.read().node._sequence\n        return self.sequence\n\n    stream = self.stream.copy()\n    while stream.curr is not None:\n        coupling_builder, field_builder, spatial_head = self.read_address(stream)\n\n        if coupling_builder is not None:\n            # update to new pulse coupling\n            self.coupling_name = coupling_builder.__bloqade_ir__()\n\n        if field_builder is not None:\n            # update to new field coupling\n            self.field_name = field_builder.__bloqade_ir__()\n\n        if spatial_head is None:\n            break\n\n        pulse = self.sequence.pulses.get(self.coupling_name, ir.Pulse({}))\n        field = pulse.fields.get(self.field_name, ir.Field({}))\n\n        drive = self.read_drive(spatial_head)\n        field = field.add(drive)\n\n        pulse = ir.Pulse.create(pulse.fields | {self.field_name: field})\n        self.sequence = ir.Sequence.create(\n            self.sequence.pulses | {self.coupling_name: pulse}\n        )\n\n    return self.sequence\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.read_waveform","title":"read_waveform","text":"<pre><code>read_waveform(\n    head: BuilderNode,\n) -&gt; Tuple[ir.Waveform, BuilderNode]\n</code></pre> <p>Read a waveform from the builder stream.</p> <p>Parameters:</p> Name Type Description Default <code>head</code> <code>BuilderNode</code> <p>The head of the builder stream.</p> required <p>Returns:</p> Type Description <code>Tuple[Waveform, BuilderNode]</code> <p>Tuple[ir.Waveform, BuilderNode]: A tuple containing the waveform and the next builder node.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def read_waveform(self, head: BuilderNode) -&gt; Tuple[ir.Waveform, BuilderNode]:\n    \"\"\"\n    Read a waveform from the builder stream.\n\n    Args:\n        head (BuilderNode): The head of the builder stream.\n\n    Returns:\n        Tuple[ir.Waveform, BuilderNode]: A tuple containing the waveform and the next builder node.\n    \"\"\"\n    curr = head\n    waveform = None\n    while curr is not None:\n        node = curr.node\n\n        if isinstance(node, Slice):\n            waveform = waveform[node._start : node._stop]\n        elif isinstance(node, Record):\n            waveform = waveform.record(node._name)\n        elif isinstance(node, Sample):\n            interpolation = node._interpolation\n            if interpolation is None:\n                if self.field_name == ir.rabi.phase:\n                    interpolation = ir.Interpolation.Constant\n                else:\n                    interpolation = ir.Interpolation.Linear\n            fn_waveform = node.__parent__.__bloqade_ir__()\n            sample_waveform = ir.Sample(fn_waveform, interpolation, node._dt)\n            if waveform is None:\n                waveform = sample_waveform\n            else:\n                waveform = waveform.append(sample_waveform)\n        elif (\n            isinstance(node, Fn)\n            and curr.next is not None\n            and isinstance(curr.next.node, Sample)\n        ):\n            pass\n        elif isinstance(node, WaveformPrimitive):\n            if waveform is None:\n                waveform = node.__bloqade_ir__()\n            else:\n                waveform = waveform.append(node.__bloqade_ir__())\n        else:\n            break\n\n        curr = curr.next\n\n    return waveform, curr\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/builder/#bloqade.analog.builder.parse.builder.Parser.reset","title":"reset","text":"<pre><code>reset(builder: Builder)\n</code></pre> <p>Reset the parser's state.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/builder.py</code> <pre><code>def reset(self, builder: Builder):\n    \"\"\"Reset the parser's state.\"\"\"\n    self.stream = BuilderStream.create(builder)\n    self.vector_node_names = set()\n    self.sequence = ir.Sequence.create()\n    self.register = None\n    self.batch_params = [{}]\n    self.static_params = {}\n    self.order = ()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/","title":"Stream","text":"<p>Module for managing a stream of builder nodes.</p> <p>This module provides classes to represent builder nodes and builder streams. A builder node is a single element in the stream, representing a step in a construction process. A builder stream is a sequence of builder nodes, allowing traversal and manipulation of the construction steps.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderNode","title":"BuilderNode  <code>dataclass</code>","text":"<pre><code>BuilderNode(\n    node: Builder, next: Optional[BuilderNode] = None\n)\n</code></pre> <p>A node in the builder stream.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderNode.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Representation of the BuilderNode.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Representation of the BuilderNode.\"\"\"\n    return repr(self.node)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream","title":"BuilderStream  <code>dataclass</code>","text":"<pre><code>BuilderStream(\n    head: BuilderNode, curr: Optional[BuilderNode] = None\n)\n</code></pre> <p>Represents a stream of builder nodes.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.__iter__","title":"__iter__","text":"<pre><code>__iter__()\n</code></pre> <p>Iterator method to iterate over the builder stream.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def __iter__(self):\n    \"\"\"Iterator method to iterate over the builder stream.\"\"\"\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.__next__","title":"__next__","text":"<pre><code>__next__()\n</code></pre> <p>Next method to get the next item in the builder stream.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def __next__(self):\n    \"\"\"Next method to get the next item in the builder stream.\"\"\"\n    node = self.read()\n    if node is None:\n        raise StopIteration\n    return node\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.build_nodes","title":"build_nodes  <code>staticmethod</code>","text":"<pre><code>build_nodes(node: Builder) -&gt; BuilderNode\n</code></pre> <p>Build BuilderNode instances from the provided Builder.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>Builder</code> <p>The root Builder instance.</p> required <p>Returns:</p> Name Type Description <code>BuilderNode</code> <code>BuilderNode</code> <p>The head of the linked list of BuilderNodes.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>@staticmethod\ndef build_nodes(node: Builder) -&gt; \"BuilderNode\":\n    \"\"\"\n    Build BuilderNode instances from the provided Builder.\n\n    Args:\n        node (Builder): The root Builder instance.\n\n    Returns:\n        BuilderNode: The head of the linked list of BuilderNodes.\n    \"\"\"\n    curr = node\n    node = None\n    while curr is not None:\n        next = curr\n        curr = curr.__parent__ if hasattr(curr, \"__parent__\") else None\n        node = BuilderNode(next, node)\n\n    return node\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.copy","title":"copy","text":"<pre><code>copy() -&gt; BuilderStream\n</code></pre> <p>Create a copy of the builder stream.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def copy(self) -&gt; \"BuilderStream\":\n    \"\"\"Create a copy of the builder stream.\"\"\"\n    return BuilderStream(head=self.head, curr=self.curr)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.create","title":"create  <code>staticmethod</code>","text":"<pre><code>create(builder: Builder) -&gt; BuilderStream\n</code></pre> <p>Create a BuilderStream instance from a Builder.</p> <p>Parameters:</p> Name Type Description Default <code>builder</code> <code>Builder</code> <p>The root Builder instance.</p> required <p>Returns:</p> Name Type Description <code>BuilderStream</code> <code>BuilderStream</code> <p>The created BuilderStream instance.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>@staticmethod\ndef create(builder: Builder) -&gt; \"BuilderStream\":\n    \"\"\"\n    Create a BuilderStream instance from a Builder.\n\n    Args:\n        builder (Builder): The root Builder instance.\n\n    Returns:\n        BuilderStream: The created BuilderStream instance.\n    \"\"\"\n    head = BuilderStream.build_nodes(builder)\n    return BuilderStream(head=head, curr=head)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.eat","title":"eat","text":"<pre><code>eat(\n    types: List[Type[Builder]],\n    skips: Optional[List[Type[Builder]]] = None,\n) -&gt; BuilderNode\n</code></pre> <p>Move the stream pointer until a node of specified types is found.</p> <p>Parameters:</p> Name Type Description Default <code>types</code> <code>List[Type[Builder]]</code> <p>List of types to move the stream pointer to.</p> required <code>skips</code> <code>List[Type[Builder]] | None</code> <p>List of types to end the stream scan.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>BuilderNode</code> <code>BuilderNode</code> <p>The beginning of the stream which matches a type in <code>types</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def eat(\n    self, types: List[Type[Builder]], skips: Optional[List[Type[Builder]]] = None\n) -&gt; BuilderNode:\n    \"\"\"\n    Move the stream pointer until a node of specified types is found.\n\n    Args:\n        types (List[Type[Builder]]): List of types to move the stream pointer to.\n        skips (List[Type[Builder]] | None, optional): List of types to end the stream scan.\n\n    Returns:\n        BuilderNode: The beginning of the stream which matches a type in `types`.\n    \"\"\"\n    head = self.read_next(types)\n    curr = head\n    while curr is not None:\n        if type(curr.node) not in types:\n            if skips and type(curr.node) not in skips:\n                break\n        curr = curr.next\n    self.curr = curr\n    return head\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.read","title":"read","text":"<pre><code>read() -&gt; Optional[BuilderNode]\n</code></pre> <p>Read the next builder node from the stream.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def read(self) -&gt; Optional[BuilderNode]:\n    \"\"\"Read the next builder node from the stream.\"\"\"\n    if self.curr is None:\n        return None\n\n    node = self.curr\n    self.curr = self.curr.next\n    return node\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/stream/#bloqade.analog.builder.parse.stream.BuilderStream.read_next","title":"read_next","text":"<pre><code>read_next(\n    builder_types: List[type[Builder]],\n) -&gt; Optional[BuilderNode]\n</code></pre> <p>Read the next builder node of specified types from the stream.</p> <p>Parameters:</p> Name Type Description Default <code>builder_types</code> <code>List[type[Builder]]</code> <p>List of builder types to read from the stream.</p> required <p>Returns:</p> Type Description <code>Optional[BuilderNode]</code> <p>Optional[BuilderNode]: The next builder node matching one of the specified types, or None if not found.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/stream.py</code> <pre><code>def read_next(self, builder_types: List[type[Builder]]) -&gt; Optional[BuilderNode]:\n    \"\"\"\n    Read the next builder node of specified types from the stream.\n\n    Args:\n        builder_types (List[type[Builder]]): List of builder types to read from the stream.\n\n    Returns:\n        Optional[BuilderNode]: The next builder node matching one of the specified types, or None if not found.\n    \"\"\"\n    node = self.read()\n    while node is not None:\n        if type(node.node) in builder_types:\n            return node\n        node = self.read()\n    return None\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/","title":"Trait","text":"<p>Module for parsing and displaying quantum computing program components using the bloqade library.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.Parse","title":"Parse","text":"<p>               Bases: <code>ParseRegister</code>, <code>ParseSequence</code>, <code>ParseCircuit</code>, <code>ParseRoutine</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n\n                              bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n            </code></pre> <p>A composite class inheriting from ParseRegister, ParseSequence, ParseCircuit, and ParseRoutine. Provides a unified interface for parsing different components of the program.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.Parse.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>Return the number of atoms in the program.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of atoms in the parsed register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register type is unsupported.</p> Note <p>If the register is of type ParallelRegister, the number of atoms is extracted from its internal register.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Parse):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; n_atoms = builder.n_atoms\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseCircuit","title":"ParseCircuit","text":"<p>A class providing functionality to parse the analog circuit from the program.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseCircuit):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; analog_circuit = builder.parse_circuit()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseCircuit.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit() -&gt; AnalogCircuit\n</code></pre> <p>Parse the analog circuit from the program.</p> <p>Returns:</p> Name Type Description <code>AnalogCircuit</code> <code>AnalogCircuit</code> <p>The parsed analog circuit.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the circuit cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/trait.py</code> <pre><code>def parse_circuit(self: \"Builder\") -&gt; \"AnalogCircuit\":\n    \"\"\"\n    Parse the analog circuit from the program.\n\n    Returns:\n        AnalogCircuit: The parsed analog circuit.\n\n    Raises:\n        ValueError: If the circuit cannot be parsed.\n    \"\"\"\n    from bloqade.analog.builder.parse.builder import Parser\n\n    return Parser().parse_circuit(self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseRegister","title":"ParseRegister","text":"<p>A class providing functionality to parse the arrangement of atoms in the program.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseRegister):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; atom_arrangement = builder.parse_register()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseRegister.parse_register","title":"parse_register","text":"<pre><code>parse_register() -&gt; (\n    Union[AtomArrangement, ParallelRegister]\n)\n</code></pre> <p>Parse the arrangement of atoms in the program.</p> <p>Returns:</p> Type Description <code>Union[AtomArrangement, ParallelRegister]</code> <p>Union[AtomArrangement, ParallelRegister]: The parsed atom arrangement or parallel register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/trait.py</code> <pre><code>def parse_register(self: \"Builder\") -&gt; Union[\"AtomArrangement\", \"ParallelRegister\"]:\n    \"\"\"\n    Parse the arrangement of atoms in the program.\n\n    Returns:\n        Union[AtomArrangement, ParallelRegister]: The parsed atom arrangement or parallel register.\n\n    Raises:\n        ValueError: If the register cannot be parsed.\n    \"\"\"\n    from bloqade.analog.builder.parse.builder import Parser\n\n    return Parser().parse_register(self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseRoutine","title":"ParseRoutine","text":"<p>A class providing functionality to parse the program and return a Routine object.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseRoutine):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; routine = builder.parse()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseRoutine.parse","title":"parse","text":"<pre><code>parse() -&gt; Routine\n</code></pre> <p>Parse the program to return a Routine object.</p> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>The parsed routine object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the routine cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/trait.py</code> <pre><code>def parse(self: \"Builder\") -&gt; \"Routine\":\n    \"\"\"\n    Parse the program to return a Routine object.\n\n    Returns:\n        Routine: The parsed routine object.\n\n    Raises:\n        ValueError: If the routine cannot be parsed.\n    \"\"\"\n    from bloqade.analog.builder.parse.builder import Parser\n\n    return Parser().parse(self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseSequence","title":"ParseSequence","text":"<p>A class providing functionality to parse the pulse sequence part of the program.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(ParseSequence):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; sequence = builder.parse_sequence()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.ParseSequence.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence() -&gt; Sequence\n</code></pre> <p>Parse the pulse sequence part of the program.</p> <p>Returns:</p> Name Type Description <code>Sequence</code> <code>Sequence</code> <p>The parsed pulse sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/trait.py</code> <pre><code>def parse_sequence(self: \"Builder\") -&gt; \"Sequence\":\n    \"\"\"\n    Parse the pulse sequence part of the program.\n\n    Returns:\n        Sequence: The parsed pulse sequence.\n\n    Raises:\n        ValueError: If the sequence cannot be parsed.\n    \"\"\"\n    from bloqade.analog.builder.parse.builder import Parser\n\n    return Parser().parse_sequence(self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.Show","title":"Show","text":"<p>A mixin class providing functionality to display the builder with given arguments and batch ID.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/builder/parse/trait/#bloqade.analog.builder.parse.trait.Show.show","title":"show","text":"<pre><code>show(*args, batch_id: int = 0)\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/parse/trait.py</code> <pre><code>def show(self, *args, batch_id: int = 0):\n    \"\"\"\n    Display the current program being defined with the given arguments and batch ID.\n\n    Args:\n        *args: Additional arguments for display.\n        batch_id (int, optional): The batch ID to be displayed. Defaults to 0.\n\n    Note:\n        This method uses the `display_builder` function to render the builder's state.\n\n    Example:\n\n    ```python\n    &gt;&gt;&gt; class MyBuilder(Show):\n    ...     pass\n    &gt;&gt;&gt; builder = MyBuilder()\n    &gt;&gt;&gt; builder.show()\n    &gt;&gt;&gt; builder.show(batch_id=1)\n    &gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n    ```\n    \"\"\"\n    display_builder(self, batch_id, *args)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/assignment_scan/","title":"Assignment scan","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/check_slices/","title":"Check slices","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/is_constant/","title":"Is constant","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/is_hyperfine/","title":"Is hyperfine","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/scan_channels/","title":"Scan channels","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/common/scan_variables/","title":"Scan variables","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/#bloqade.analog.compiler.analysis.hardware.BasicLatticeValidation","title":"BasicLatticeValidation","text":"<pre><code>BasicLatticeValidation(capabilities: QuEraCapabilities)\n</code></pre> <p>               Bases: <code>BloqadeIRVisitor</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.compiler.analysis.hardware.BasicLatticeValidation[BasicLatticeValidation]\n              bloqade.analog.ir.visitor.BloqadeIRVisitor[BloqadeIRVisitor]\n\n                              bloqade.analog.ir.visitor.BloqadeIRVisitor --&gt; bloqade.analog.compiler.analysis.hardware.BasicLatticeValidation\n                \n\n\n              click bloqade.analog.compiler.analysis.hardware.BasicLatticeValidation href \"\" \"bloqade.analog.compiler.analysis.hardware.BasicLatticeValidation\"\n              click bloqade.analog.ir.visitor.BloqadeIRVisitor href \"\" \"bloqade.analog.ir.visitor.BloqadeIRVisitor\"\n            </code></pre> <p>This visitor checks that the AtomArrangement is within the bounds of the lattice and that the number of sites is within the maximum number of sites.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/analysis/hardware/lattice.py</code> <pre><code>def __init__(self, capabilities: QuEraCapabilities):\n    self.capabilities = capabilities\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/#bloqade.analog.compiler.analysis.hardware.ValidateChannels","title":"ValidateChannels","text":"<pre><code>ValidateChannels()\n</code></pre> <p>               Bases: <code>BloqadeIRVisitor</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.compiler.analysis.hardware.ValidateChannels[ValidateChannels]\n              bloqade.analog.ir.visitor.BloqadeIRVisitor[BloqadeIRVisitor]\n\n                              bloqade.analog.ir.visitor.BloqadeIRVisitor --&gt; bloqade.analog.compiler.analysis.hardware.ValidateChannels\n                \n\n\n              click bloqade.analog.compiler.analysis.hardware.ValidateChannels href \"\" \"bloqade.analog.compiler.analysis.hardware.ValidateChannels\"\n              click bloqade.analog.ir.visitor.BloqadeIRVisitor href \"\" \"bloqade.analog.ir.visitor.BloqadeIRVisitor\"\n            </code></pre> <p>Checks to make sure the given sequence can be compiled to hardware.</p> <p>This check looks at the spatial modulations and the level coupling to determine if the sequence can be compiled to hardware.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/analysis/hardware/channels.py</code> <pre><code>def __init__(self):\n    self.field_name = None\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/channels/","title":"Channels","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/channels/#bloqade.analog.compiler.analysis.hardware.channels.ValidateChannels","title":"ValidateChannels","text":"<pre><code>ValidateChannels()\n</code></pre> <p>               Bases: <code>BloqadeIRVisitor</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.compiler.analysis.hardware.channels.ValidateChannels[ValidateChannels]\n              bloqade.analog.ir.visitor.BloqadeIRVisitor[BloqadeIRVisitor]\n\n                              bloqade.analog.ir.visitor.BloqadeIRVisitor --&gt; bloqade.analog.compiler.analysis.hardware.channels.ValidateChannels\n                \n\n\n              click bloqade.analog.compiler.analysis.hardware.channels.ValidateChannels href \"\" \"bloqade.analog.compiler.analysis.hardware.channels.ValidateChannels\"\n              click bloqade.analog.ir.visitor.BloqadeIRVisitor href \"\" \"bloqade.analog.ir.visitor.BloqadeIRVisitor\"\n            </code></pre> <p>Checks to make sure the given sequence can be compiled to hardware.</p> <p>This check looks at the spatial modulations and the level coupling to determine if the sequence can be compiled to hardware.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/analysis/hardware/channels.py</code> <pre><code>def __init__(self):\n    self.field_name = None\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/lattice/#bloqade.analog.compiler.analysis.hardware.lattice.BasicLatticeValidation","title":"BasicLatticeValidation","text":"<pre><code>BasicLatticeValidation(capabilities: QuEraCapabilities)\n</code></pre> <p>               Bases: <code>BloqadeIRVisitor</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.compiler.analysis.hardware.lattice.BasicLatticeValidation[BasicLatticeValidation]\n              bloqade.analog.ir.visitor.BloqadeIRVisitor[BloqadeIRVisitor]\n\n                              bloqade.analog.ir.visitor.BloqadeIRVisitor --&gt; bloqade.analog.compiler.analysis.hardware.lattice.BasicLatticeValidation\n                \n\n\n              click bloqade.analog.compiler.analysis.hardware.lattice.BasicLatticeValidation href \"\" \"bloqade.analog.compiler.analysis.hardware.lattice.BasicLatticeValidation\"\n              click bloqade.analog.ir.visitor.BloqadeIRVisitor href \"\" \"bloqade.analog.ir.visitor.BloqadeIRVisitor\"\n            </code></pre> <p>This visitor checks that the AtomArrangement is within the bounds of the lattice and that the number of sites is within the maximum number of sites.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/analysis/hardware/lattice.py</code> <pre><code>def __init__(self, capabilities: QuEraCapabilities):\n    self.capabilities = capabilities\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/piecewise_constant/","title":"Piecewise constant","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/hardware/piecewise_linear/","title":"Piecewise linear","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/python/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/analysis/python/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/emulator/","title":"Emulator","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.analyze_channels","title":"analyze_channels","text":"<pre><code>analyze_channels(circuit: AnalogCircuit) -&gt; Dict\n</code></pre> <ol> <li>Scan channels</li> </ol> <p>This pass checks to make sure that: * There is no hyperfine coupling in the sequence * There are no non-uniform spatial modulation for rabi phase and amplitude * there is no more than one non-uniform spatial modulation for detuning</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to analyze</p> required <p>Returns:</p> Name Type Description <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the required channels for the sequence. Note that this will insert a uniform field for any missing channels.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is hyperfine coupling in the sequence.</p> <code>ValueError</code> <p>If there is more than one non-uniform spatial modulation for detuning.</p> <code>ValueError</code> <p>If there are non-uniform spatial modulations for rabi phase and amplitude.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def analyze_channels(circuit: analog_circuit.AnalogCircuit) -&gt; Dict:\n    \"\"\"1. Scan channels\n\n    This pass checks to make sure that:\n    * There is no hyperfine coupling in the sequence\n    * There are no non-uniform spatial modulation for rabi phase and amplitude\n    * there is no more than one non-uniform spatial modulation for detuning\n\n    Args:\n        circuit: AnalogCircuit to analyze\n\n    Returns:\n        level_couplings: Dictionary containing the required channels for the\n            sequence. Note that this will insert a uniform field for any missing\n            channels.\n\n    Raises:\n        ValueError: If there is hyperfine coupling in the sequence.\n        ValueError: If there is more than one non-uniform spatial modulation for\n            detuning.\n        ValueError: If there are non-uniform spatial modulations for rabi phase\n            and amplitude.\n\n    \"\"\"\n    from bloqade.analog.compiler.analysis.common import ScanChannels\n    from bloqade.analog.compiler.analysis.hardware import ValidateChannels\n\n    ValidateChannels().scan(circuit)\n    level_couplings = ScanChannels().scan(circuit)\n\n    # add missing channels\n    fields = level_couplings[sequence.rydberg]\n    # detuning, phase and amplitude are required\n    # to have at least a uniform field\n    updated_fields = {\n        field_name: fields.get(field_name, {field.Uniform}).union({field.Uniform})\n        for field_name in [pulse.detuning, pulse.rabi.amplitude, pulse.rabi.phase]\n    }\n\n    return {sequence.rydberg: updated_fields}\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.assign_circuit","title":"assign_circuit","text":"<pre><code>assign_circuit(\n    circuit: AnalogCircuit,\n    assignments: Dict[str, ParamType],\n) -&gt; Tuple[analog_circuit.AnalogCircuit, Dict]\n</code></pre> <ol> <li>Assign variables and validate assignment</li> </ol> <p>This pass assigns variables to the circuit and validates that all variables have been assigned.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to assign variables to</p> required <code>assignments</code> <code>Dict[str, ParamType]</code> <p>Dictionary containing the assignments for the variables in the circuit.</p> required <p>Returns:</p> Name Type Description <code>assigned_circuit</code> <code>Tuple[AnalogCircuit, Dict]</code> <p>AnalogCircuit with variables assigned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are any variables that have not been assigned.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def assign_circuit(\n    circuit: analog_circuit.AnalogCircuit, assignments: Dict[str, ParamType]\n) -&gt; Tuple[analog_circuit.AnalogCircuit, Dict]:\n    \"\"\"3. Assign variables and validate assignment\n\n    This pass assigns variables to the circuit and validates that all variables\n    have been assigned.\n\n    Args:\n        circuit: AnalogCircuit to assign variables to\n        assignments: Dictionary containing the assignments for the variables in\n            the circuit.\n\n    Returns:\n        assigned_circuit: AnalogCircuit with variables assigned.\n\n    Raises:\n        ValueError: If there are any variables that have not been assigned.\n\n    \"\"\"\n    from bloqade.analog.compiler.rewrite.common import AssignBloqadeIR\n    from bloqade.analog.compiler.analysis.common import ScanVariables, AssignmentScan\n\n    final_assignments = AssignmentScan(assignments).scan(circuit)\n\n    assigned_circuit = AssignBloqadeIR(final_assignments).visit(circuit)\n\n    assignment_analysis = ScanVariables().scan(assigned_circuit)\n\n    if not assignment_analysis.is_assigned:\n        missing_vars = assignment_analysis.scalar_vars.union(\n            assignment_analysis.vector_vars\n        )\n        raise ValueError(\n            \"Missing assignments for variables:\\n\"\n            + (\"\\n\".join(f\"{var}\" for var in missing_vars))\n            + \"\\n\"\n        )\n\n    return assigned_circuit, final_assignments\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.canonicalize_circuit","title":"canonicalize_circuit","text":"<pre><code>canonicalize_circuit(\n    circuit: AnalogCircuit, level_couplings: Dict\n) -&gt; analog_circuit.AnalogCircuit\n</code></pre> <ol> <li>Insert zero waveform in the explicit time intervals missing a waveform</li> </ol> <p>This pass inserts a zero waveform in the explicit time intervals missing a waveform. This is required for later analysis passes to check that the waveforms are compatible with the hardware.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to add padding to</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Return     circuit: AnalogCircuit with zero waveforms inserted in the explicit time         intervals missing a waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def canonicalize_circuit(\n    circuit: analog_circuit.AnalogCircuit, level_couplings: Dict\n) -&gt; analog_circuit.AnalogCircuit:\n    \"\"\"2. Insert zero waveform in the explicit time intervals missing a waveform\n\n    This pass inserts a zero waveform in the explicit time intervals missing a\n    waveform. This is required for later analysis passes to check that the\n    waveforms are compatible with the hardware.\n\n    Args:\n        circuit: AnalogCircuit to add padding to\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Return\n        circuit: AnalogCircuit with zero waveforms inserted in the explicit time\n            intervals missing a waveform.\n\n    \"\"\"\n    from bloqade.analog.compiler.rewrite.common import (\n        AddPadding,\n        Canonicalizer,\n        AssignToLiteral,\n    )\n\n    circuit = AddPadding(level_couplings).visit(circuit)\n    # these two passes are equivalent to a constant propagation pass\n    circuit = AssignToLiteral().visit(circuit)\n    circuit = Canonicalizer().visit(circuit)\n\n    return circuit\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.generate_ahs_code","title":"generate_ahs_code","text":"<pre><code>generate_ahs_code(\n    capabilities: Optional[QuEraCapabilities],\n    level_couplings: Dict,\n    circuit: AnalogCircuit,\n) -&gt; AHSComponents\n</code></pre> <ol> <li>generate ahs code</li> </ol> <p>Generates the AHS code for the given circuit. This includes generating the lattice data, global detuning, global amplitude, global phase, local detuning and lattice site coefficients (if applicable).</p> <p>Parameters:</p> Name Type Description Default <code>capabilities</code> <code>QuEraCapabilities | None</code> <p>Capabilities of the hardware.</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to generate AHS code for.</p> required <p>Returns:</p> Name Type Description <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit. Can be used to generate the QuEra and Braket IR.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the capabilities are not provided but the circuit has a ParallelRegister. This is because the ParallelRegister requires the capabilities to generate the lattice data.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def generate_ahs_code(\n    capabilities: Optional[QuEraCapabilities],\n    level_couplings: Dict,\n    circuit: analog_circuit.AnalogCircuit,\n) -&gt; AHSComponents:\n    \"\"\"5. generate ahs code\n\n    Generates the AHS code for the given circuit. This includes generating the\n    lattice data, global detuning, global amplitude, global phase, local\n    detuning and lattice site coefficients (if applicable).\n\n    Args:\n        capabilities (QuEraCapabilities | None): Capabilities of the hardware.\n        level_couplings (Dict): Dictionary containing the given channels for the\n            sequence.\n        circuit (AnalogCircuit): AnalogCircuit to generate AHS code for.\n\n    Returns:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit. Can be used to generate the QuEra\n            and Braket IR.\n\n    Raises:\n        ValueError: If the capabilities are not provided but the circuit has\n            a ParallelRegister. This is because the ParallelRegister requires\n            the capabilities to generate the lattice data.\n\n    \"\"\"\n    from bloqade.analog.compiler.codegen.hardware import (\n        GenerateLattice,\n        GeneratePiecewiseLinearChannel,\n        GenerateLatticeSiteCoefficients,\n        GeneratePiecewiseConstantChannel,\n    )\n    from bloqade.analog.compiler.analysis.hardware import BasicLatticeValidation\n\n    if capabilities is not None:\n        # only validate the lattice if capabilities are provided\n        BasicLatticeValidation(capabilities).visit(circuit)\n\n    ahs_lattice_data = GenerateLattice(capabilities).emit(circuit)\n\n    global_detuning = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.detuning, field.Uniform\n    ).visit(circuit)\n\n    global_amplitude = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.rabi.amplitude, field.Uniform\n    ).visit(circuit)\n\n    global_phase = GeneratePiecewiseConstantChannel(\n        sequence.rydberg, pulse.rabi.phase, field.Uniform\n    ).visit(circuit)\n\n    local_detuning = None\n    lattice_site_coefficients = None\n\n    extra_sm = set(level_couplings[sequence.rydberg][pulse.detuning]) - {field.Uniform}\n\n    if extra_sm:\n        if capabilities is not None and capabilities.capabilities.rydberg.local is None:\n            raise ValueError(\n                \"Device does not support local detuning, but the program has a \"\n                \"non-uniform spatial modulation for detuning.\"\n            )\n\n        sm = extra_sm.pop()\n\n        lattice_site_coefficients = GenerateLatticeSiteCoefficients(\n            parallel_decoder=ahs_lattice_data.parallel_decoder\n        ).emit(circuit)\n\n        local_detuning = GeneratePiecewiseLinearChannel(\n            sequence.rydberg, pulse.detuning, sm\n        ).visit(circuit)\n\n    return AHSComponents(\n        lattice_data=ahs_lattice_data,\n        global_detuning=global_detuning,\n        global_amplitude=global_amplitude,\n        global_phase=global_phase,\n        local_detuning=local_detuning,\n        lattice_site_coefficients=lattice_site_coefficients,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.generate_braket_ir","title":"generate_braket_ir","text":"<pre><code>generate_braket_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; BraketTaskSpecification\n</code></pre> <ol> <li>generate braket ir</li> </ol> <p>This pass takes the AHS components and generates the Braket IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>BraketTaskSpecification</code> <p>Braket IR for the given circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def generate_braket_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; BraketTaskSpecification:\n    \"\"\"7. generate braket ir\n\n    This pass takes the AHS components and generates the Braket IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (BraketTaskSpecification): Braket IR for the given\n            circuit.\n\n    \"\"\"\n    import braket.ir.ahs as ahs\n\n    from bloqade.analog.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    ahs_register = ahs.AtomArrangement(\n        sites=list(map(convert_coordinate_units, ahs_components.lattice_data.sites)),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning_time_series = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning_time_series = ahs.TimeSeries(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n        )\n\n    amplitude_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    phase_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = ahs.PhysicalField(\n        time_series=global_detuning_time_series,\n        pattern=\"uniform\",\n    )\n\n    amplitude = ahs.PhysicalField(\n        time_series=amplitude_time_series,\n        pattern=\"uniform\",\n    )\n\n    phase = ahs.PhysicalField(\n        time_series=phase_time_series,\n        pattern=\"uniform\",\n    )\n\n    local_detuning = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = ahs.PhysicalField(\n            time_series=local_detuning_time_series,\n            pattern=ahs_components.lattice_site_coefficients,\n        )\n\n    driving_field = ahs.DrivingField(\n        detuning=detuning,\n        amplitude=amplitude,\n        phase=phase,\n    )\n\n    shiftingFields = []\n    if ahs_components.lattice_site_coefficients is not None:\n        shiftingFields = [ahs.ShiftingField(magnitude=local_detuning)]\n\n    program = ahs.Program(\n        setup=ahs.Setup(ahs_register=ahs_register),\n        hamiltonian=ahs.Hamiltonian(\n            drivingFields=[driving_field],\n            shiftingFields=shiftingFields,\n        ),\n    )\n\n    return BraketTaskSpecification(nshots=shots, program=program)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.generate_quera_ir","title":"generate_quera_ir","text":"<pre><code>generate_quera_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; QuEraTaskSpecification\n</code></pre> <ol> <li>generate quera ir</li> </ol> <p>This pass takes the AHS components and generates the QuEra IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>QuEraTaskSpecification</code> <p>QuEra IR for the given circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def generate_quera_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; QuEraTaskSpecification:\n    \"\"\"7. generate quera ir\n\n    This pass takes the AHS components and generates the QuEra IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (QuEraTaskSpecification): QuEra IR for the given\n            circuit.\n\n    \"\"\"\n    import bloqade.analog.submission.ir.task_specification as task_spec\n    from bloqade.analog.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    lattice = task_spec.Lattice(\n        sites=list(\n            map(\n                convert_coordinate_units,\n                ahs_components.lattice_data.sites,\n            )\n        ),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning = None\n\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = task_spec.LocalField(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n            lattice_site_coefficients=ahs_components.lattice_site_coefficients,\n        )\n\n    rabi_frequency_amplitude_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    rabi_frequency_phase_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = task_spec.Detuning(\n        global_=global_detuning,\n        local=local_detuning,\n    )\n\n    rabi_frequency_amplitude = task_spec.RabiFrequencyAmplitude(\n        global_=rabi_frequency_amplitude_field,\n    )\n\n    rabi_frequency_phase = task_spec.RabiFrequencyPhase(\n        global_=rabi_frequency_phase_field,\n    )\n\n    rydberg = task_spec.RydbergHamiltonian(\n        rabi_frequency_amplitude=rabi_frequency_amplitude,\n        rabi_frequency_phase=rabi_frequency_phase,\n        detuning=detuning,\n    )\n\n    effective_hamiltonian = task_spec.EffectiveHamiltonian(\n        rydberg=rydberg,\n    )\n\n    return task_spec.QuEraTaskSpecification(\n        nshots=shots,\n        lattice=lattice,\n        effective_hamiltonian=effective_hamiltonian,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/#bloqade.analog.compiler.passes.hardware.validate_waveforms","title":"validate_waveforms","text":"<pre><code>validate_waveforms(\n    level_couplings: Dict, circuit: AnalogCircuit\n) -&gt; None\n</code></pre> <ol> <li>validate piecewise linear and piecewise constant pieces of pulses</li> </ol> <p>This pass check to make sure that the waveforms are compatible with the hardware. This includes checking that the waveforms are piecewise linear or piecewise constant. It also checks that the waveforms are compatible with the given channels.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to validate waveforms for</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the waveforms are not piecewise linear or piecewise constant, e.g. the waveform is not continuous.</p> <code>ValueError</code> <p>If a waveform segment is not compatible with the given channels.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def validate_waveforms(\n    level_couplings: Dict, circuit: analog_circuit.AnalogCircuit\n) -&gt; None:\n    \"\"\"4. validate piecewise linear and piecewise constant pieces of pulses\n\n    This pass check to make sure that the waveforms are compatible with the\n    hardware. This includes checking that the waveforms are piecewise linear or\n    piecewise constant. It also checks that the waveforms are compatible with\n    the given channels.\n\n    Args:\n        circuit: AnalogCircuit to validate waveforms for\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Raises:\n        ValueError: If the waveforms are not piecewise linear or piecewise\n            constant, e.g. the waveform is not continuous.\n        ValueError: If a waveform segment is not compatible with the given\n            channels.\n\n    \"\"\"\n    from bloqade.analog.compiler.analysis.common import CheckSlices\n    from bloqade.analog.compiler.analysis.hardware import (\n        ValidatePiecewiseLinearChannel,\n        ValidatePiecewiseConstantChannel,\n    )\n\n    channel_iter = (\n        (level_coupling, field_name, sm)\n        for level_coupling, fields in level_couplings.items()\n        for field_name, spatial_modulations in fields.items()\n        for sm in spatial_modulations\n    )\n    for channel in channel_iter:\n        if channel[1] in [pulse.detuning, pulse.rabi.amplitude]:\n            ValidatePiecewiseLinearChannel(*channel).visit(circuit)\n        else:\n            ValidatePiecewiseConstantChannel(*channel).visit(circuit)\n\n    CheckSlices().visit(circuit)\n\n    if circuit.sequence.duration() == 0:\n        raise ValueError(\"Circuit Duration must be be non-zero\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/components/","title":"Components","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/","title":"Define","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.analyze_channels","title":"analyze_channels","text":"<pre><code>analyze_channels(circuit: AnalogCircuit) -&gt; Dict\n</code></pre> <ol> <li>Scan channels</li> </ol> <p>This pass checks to make sure that: * There is no hyperfine coupling in the sequence * There are no non-uniform spatial modulation for rabi phase and amplitude * there is no more than one non-uniform spatial modulation for detuning</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to analyze</p> required <p>Returns:</p> Name Type Description <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the required channels for the sequence. Note that this will insert a uniform field for any missing channels.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there is hyperfine coupling in the sequence.</p> <code>ValueError</code> <p>If there is more than one non-uniform spatial modulation for detuning.</p> <code>ValueError</code> <p>If there are non-uniform spatial modulations for rabi phase and amplitude.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def analyze_channels(circuit: analog_circuit.AnalogCircuit) -&gt; Dict:\n    \"\"\"1. Scan channels\n\n    This pass checks to make sure that:\n    * There is no hyperfine coupling in the sequence\n    * There are no non-uniform spatial modulation for rabi phase and amplitude\n    * there is no more than one non-uniform spatial modulation for detuning\n\n    Args:\n        circuit: AnalogCircuit to analyze\n\n    Returns:\n        level_couplings: Dictionary containing the required channels for the\n            sequence. Note that this will insert a uniform field for any missing\n            channels.\n\n    Raises:\n        ValueError: If there is hyperfine coupling in the sequence.\n        ValueError: If there is more than one non-uniform spatial modulation for\n            detuning.\n        ValueError: If there are non-uniform spatial modulations for rabi phase\n            and amplitude.\n\n    \"\"\"\n    from bloqade.analog.compiler.analysis.common import ScanChannels\n    from bloqade.analog.compiler.analysis.hardware import ValidateChannels\n\n    ValidateChannels().scan(circuit)\n    level_couplings = ScanChannels().scan(circuit)\n\n    # add missing channels\n    fields = level_couplings[sequence.rydberg]\n    # detuning, phase and amplitude are required\n    # to have at least a uniform field\n    updated_fields = {\n        field_name: fields.get(field_name, {field.Uniform}).union({field.Uniform})\n        for field_name in [pulse.detuning, pulse.rabi.amplitude, pulse.rabi.phase]\n    }\n\n    return {sequence.rydberg: updated_fields}\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.assign_circuit","title":"assign_circuit","text":"<pre><code>assign_circuit(\n    circuit: AnalogCircuit,\n    assignments: Dict[str, ParamType],\n) -&gt; Tuple[analog_circuit.AnalogCircuit, Dict]\n</code></pre> <ol> <li>Assign variables and validate assignment</li> </ol> <p>This pass assigns variables to the circuit and validates that all variables have been assigned.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to assign variables to</p> required <code>assignments</code> <code>Dict[str, ParamType]</code> <p>Dictionary containing the assignments for the variables in the circuit.</p> required <p>Returns:</p> Name Type Description <code>assigned_circuit</code> <code>Tuple[AnalogCircuit, Dict]</code> <p>AnalogCircuit with variables assigned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If there are any variables that have not been assigned.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def assign_circuit(\n    circuit: analog_circuit.AnalogCircuit, assignments: Dict[str, ParamType]\n) -&gt; Tuple[analog_circuit.AnalogCircuit, Dict]:\n    \"\"\"3. Assign variables and validate assignment\n\n    This pass assigns variables to the circuit and validates that all variables\n    have been assigned.\n\n    Args:\n        circuit: AnalogCircuit to assign variables to\n        assignments: Dictionary containing the assignments for the variables in\n            the circuit.\n\n    Returns:\n        assigned_circuit: AnalogCircuit with variables assigned.\n\n    Raises:\n        ValueError: If there are any variables that have not been assigned.\n\n    \"\"\"\n    from bloqade.analog.compiler.rewrite.common import AssignBloqadeIR\n    from bloqade.analog.compiler.analysis.common import ScanVariables, AssignmentScan\n\n    final_assignments = AssignmentScan(assignments).scan(circuit)\n\n    assigned_circuit = AssignBloqadeIR(final_assignments).visit(circuit)\n\n    assignment_analysis = ScanVariables().scan(assigned_circuit)\n\n    if not assignment_analysis.is_assigned:\n        missing_vars = assignment_analysis.scalar_vars.union(\n            assignment_analysis.vector_vars\n        )\n        raise ValueError(\n            \"Missing assignments for variables:\\n\"\n            + (\"\\n\".join(f\"{var}\" for var in missing_vars))\n            + \"\\n\"\n        )\n\n    return assigned_circuit, final_assignments\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.canonicalize_circuit","title":"canonicalize_circuit","text":"<pre><code>canonicalize_circuit(\n    circuit: AnalogCircuit, level_couplings: Dict\n) -&gt; analog_circuit.AnalogCircuit\n</code></pre> <ol> <li>Insert zero waveform in the explicit time intervals missing a waveform</li> </ol> <p>This pass inserts a zero waveform in the explicit time intervals missing a waveform. This is required for later analysis passes to check that the waveforms are compatible with the hardware.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to add padding to</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Return     circuit: AnalogCircuit with zero waveforms inserted in the explicit time         intervals missing a waveform.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def canonicalize_circuit(\n    circuit: analog_circuit.AnalogCircuit, level_couplings: Dict\n) -&gt; analog_circuit.AnalogCircuit:\n    \"\"\"2. Insert zero waveform in the explicit time intervals missing a waveform\n\n    This pass inserts a zero waveform in the explicit time intervals missing a\n    waveform. This is required for later analysis passes to check that the\n    waveforms are compatible with the hardware.\n\n    Args:\n        circuit: AnalogCircuit to add padding to\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Return\n        circuit: AnalogCircuit with zero waveforms inserted in the explicit time\n            intervals missing a waveform.\n\n    \"\"\"\n    from bloqade.analog.compiler.rewrite.common import (\n        AddPadding,\n        Canonicalizer,\n        AssignToLiteral,\n    )\n\n    circuit = AddPadding(level_couplings).visit(circuit)\n    # these two passes are equivalent to a constant propagation pass\n    circuit = AssignToLiteral().visit(circuit)\n    circuit = Canonicalizer().visit(circuit)\n\n    return circuit\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.generate_ahs_code","title":"generate_ahs_code","text":"<pre><code>generate_ahs_code(\n    capabilities: Optional[QuEraCapabilities],\n    level_couplings: Dict,\n    circuit: AnalogCircuit,\n) -&gt; AHSComponents\n</code></pre> <ol> <li>generate ahs code</li> </ol> <p>Generates the AHS code for the given circuit. This includes generating the lattice data, global detuning, global amplitude, global phase, local detuning and lattice site coefficients (if applicable).</p> <p>Parameters:</p> Name Type Description Default <code>capabilities</code> <code>QuEraCapabilities | None</code> <p>Capabilities of the hardware.</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to generate AHS code for.</p> required <p>Returns:</p> Name Type Description <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit. Can be used to generate the QuEra and Braket IR.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the capabilities are not provided but the circuit has a ParallelRegister. This is because the ParallelRegister requires the capabilities to generate the lattice data.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def generate_ahs_code(\n    capabilities: Optional[QuEraCapabilities],\n    level_couplings: Dict,\n    circuit: analog_circuit.AnalogCircuit,\n) -&gt; AHSComponents:\n    \"\"\"5. generate ahs code\n\n    Generates the AHS code for the given circuit. This includes generating the\n    lattice data, global detuning, global amplitude, global phase, local\n    detuning and lattice site coefficients (if applicable).\n\n    Args:\n        capabilities (QuEraCapabilities | None): Capabilities of the hardware.\n        level_couplings (Dict): Dictionary containing the given channels for the\n            sequence.\n        circuit (AnalogCircuit): AnalogCircuit to generate AHS code for.\n\n    Returns:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit. Can be used to generate the QuEra\n            and Braket IR.\n\n    Raises:\n        ValueError: If the capabilities are not provided but the circuit has\n            a ParallelRegister. This is because the ParallelRegister requires\n            the capabilities to generate the lattice data.\n\n    \"\"\"\n    from bloqade.analog.compiler.codegen.hardware import (\n        GenerateLattice,\n        GeneratePiecewiseLinearChannel,\n        GenerateLatticeSiteCoefficients,\n        GeneratePiecewiseConstantChannel,\n    )\n    from bloqade.analog.compiler.analysis.hardware import BasicLatticeValidation\n\n    if capabilities is not None:\n        # only validate the lattice if capabilities are provided\n        BasicLatticeValidation(capabilities).visit(circuit)\n\n    ahs_lattice_data = GenerateLattice(capabilities).emit(circuit)\n\n    global_detuning = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.detuning, field.Uniform\n    ).visit(circuit)\n\n    global_amplitude = GeneratePiecewiseLinearChannel(\n        sequence.rydberg, pulse.rabi.amplitude, field.Uniform\n    ).visit(circuit)\n\n    global_phase = GeneratePiecewiseConstantChannel(\n        sequence.rydberg, pulse.rabi.phase, field.Uniform\n    ).visit(circuit)\n\n    local_detuning = None\n    lattice_site_coefficients = None\n\n    extra_sm = set(level_couplings[sequence.rydberg][pulse.detuning]) - {field.Uniform}\n\n    if extra_sm:\n        if capabilities is not None and capabilities.capabilities.rydberg.local is None:\n            raise ValueError(\n                \"Device does not support local detuning, but the program has a \"\n                \"non-uniform spatial modulation for detuning.\"\n            )\n\n        sm = extra_sm.pop()\n\n        lattice_site_coefficients = GenerateLatticeSiteCoefficients(\n            parallel_decoder=ahs_lattice_data.parallel_decoder\n        ).emit(circuit)\n\n        local_detuning = GeneratePiecewiseLinearChannel(\n            sequence.rydberg, pulse.detuning, sm\n        ).visit(circuit)\n\n    return AHSComponents(\n        lattice_data=ahs_lattice_data,\n        global_detuning=global_detuning,\n        global_amplitude=global_amplitude,\n        global_phase=global_phase,\n        local_detuning=local_detuning,\n        lattice_site_coefficients=lattice_site_coefficients,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.generate_braket_ir","title":"generate_braket_ir","text":"<pre><code>generate_braket_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; BraketTaskSpecification\n</code></pre> <ol> <li>generate braket ir</li> </ol> <p>This pass takes the AHS components and generates the Braket IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>BraketTaskSpecification</code> <p>Braket IR for the given circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def generate_braket_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; BraketTaskSpecification:\n    \"\"\"7. generate braket ir\n\n    This pass takes the AHS components and generates the Braket IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (BraketTaskSpecification): Braket IR for the given\n            circuit.\n\n    \"\"\"\n    import braket.ir.ahs as ahs\n\n    from bloqade.analog.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    ahs_register = ahs.AtomArrangement(\n        sites=list(map(convert_coordinate_units, ahs_components.lattice_data.sites)),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning_time_series = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning_time_series = ahs.TimeSeries(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n        )\n\n    amplitude_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    phase_time_series = ahs.TimeSeries(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = ahs.PhysicalField(\n        time_series=global_detuning_time_series,\n        pattern=\"uniform\",\n    )\n\n    amplitude = ahs.PhysicalField(\n        time_series=amplitude_time_series,\n        pattern=\"uniform\",\n    )\n\n    phase = ahs.PhysicalField(\n        time_series=phase_time_series,\n        pattern=\"uniform\",\n    )\n\n    local_detuning = None\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = ahs.PhysicalField(\n            time_series=local_detuning_time_series,\n            pattern=ahs_components.lattice_site_coefficients,\n        )\n\n    driving_field = ahs.DrivingField(\n        detuning=detuning,\n        amplitude=amplitude,\n        phase=phase,\n    )\n\n    shiftingFields = []\n    if ahs_components.lattice_site_coefficients is not None:\n        shiftingFields = [ahs.ShiftingField(magnitude=local_detuning)]\n\n    program = ahs.Program(\n        setup=ahs.Setup(ahs_register=ahs_register),\n        hamiltonian=ahs.Hamiltonian(\n            drivingFields=[driving_field],\n            shiftingFields=shiftingFields,\n        ),\n    )\n\n    return BraketTaskSpecification(nshots=shots, program=program)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.generate_quera_ir","title":"generate_quera_ir","text":"<pre><code>generate_quera_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; QuEraTaskSpecification\n</code></pre> <ol> <li>generate quera ir</li> </ol> <p>This pass takes the AHS components and generates the QuEra IR.</p> <p>Parameters:</p> Name Type Description Default <code>ahs_components</code> <code>AHSComponents</code> <p>A collection of the AHS components generated for the given circuit.</p> required <code>shots</code> <code>int</code> <p>Number of shots to run the circuit for.</p> required <p>Returns:</p> Name Type Description <code>task_specification</code> <code>QuEraTaskSpecification</code> <p>QuEra IR for the given circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def generate_quera_ir(\n    ahs_components: AHSComponents, shots: int\n) -&gt; QuEraTaskSpecification:\n    \"\"\"7. generate quera ir\n\n    This pass takes the AHS components and generates the QuEra IR.\n\n    Args:\n        ahs_components (AHSComponents): A collection of the AHS components\n            generated for the given circuit.\n        shots (int): Number of shots to run the circuit for.\n\n    Returns:\n        task_specification (QuEraTaskSpecification): QuEra IR for the given\n            circuit.\n\n    \"\"\"\n    import bloqade.analog.submission.ir.task_specification as task_spec\n    from bloqade.analog.compiler.passes.hardware.units import (\n        convert_time_units,\n        convert_energy_units,\n        convert_coordinate_units,\n    )\n\n    lattice = task_spec.Lattice(\n        sites=list(\n            map(\n                convert_coordinate_units,\n                ahs_components.lattice_data.sites,\n            )\n        ),\n        filling=ahs_components.lattice_data.filling,\n    )\n\n    global_detuning = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_detuning.times)),\n        values=list(map(convert_energy_units, ahs_components.global_detuning.values)),\n    )\n\n    local_detuning = None\n\n    if ahs_components.lattice_site_coefficients is not None:\n        local_detuning = task_spec.LocalField(\n            times=list(map(convert_time_units, ahs_components.local_detuning.times)),\n            values=list(\n                map(convert_energy_units, ahs_components.local_detuning.values)\n            ),\n            lattice_site_coefficients=ahs_components.lattice_site_coefficients,\n        )\n\n    rabi_frequency_amplitude_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_amplitude.times)),\n        values=list(map(convert_energy_units, ahs_components.global_amplitude.values)),\n    )\n\n    rabi_frequency_phase_field = task_spec.GlobalField(\n        times=list(map(convert_time_units, ahs_components.global_phase.times)),\n        values=ahs_components.global_phase.values,\n    )\n\n    detuning = task_spec.Detuning(\n        global_=global_detuning,\n        local=local_detuning,\n    )\n\n    rabi_frequency_amplitude = task_spec.RabiFrequencyAmplitude(\n        global_=rabi_frequency_amplitude_field,\n    )\n\n    rabi_frequency_phase = task_spec.RabiFrequencyPhase(\n        global_=rabi_frequency_phase_field,\n    )\n\n    rydberg = task_spec.RydbergHamiltonian(\n        rabi_frequency_amplitude=rabi_frequency_amplitude,\n        rabi_frequency_phase=rabi_frequency_phase,\n        detuning=detuning,\n    )\n\n    effective_hamiltonian = task_spec.EffectiveHamiltonian(\n        rydberg=rydberg,\n    )\n\n    return task_spec.QuEraTaskSpecification(\n        nshots=shots,\n        lattice=lattice,\n        effective_hamiltonian=effective_hamiltonian,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/define/#bloqade.analog.compiler.passes.hardware.define.validate_waveforms","title":"validate_waveforms","text":"<pre><code>validate_waveforms(\n    level_couplings: Dict, circuit: AnalogCircuit\n) -&gt; None\n</code></pre> <ol> <li>validate piecewise linear and piecewise constant pieces of pulses</li> </ol> <p>This pass check to make sure that the waveforms are compatible with the hardware. This includes checking that the waveforms are piecewise linear or piecewise constant. It also checks that the waveforms are compatible with the given channels.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>AnalogCircuit</code> <p>AnalogCircuit to validate waveforms for</p> required <code>level_couplings</code> <code>Dict</code> <p>Dictionary containing the given channels for the sequence.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If the waveforms are not piecewise linear or piecewise constant, e.g. the waveform is not continuous.</p> <code>ValueError</code> <p>If a waveform segment is not compatible with the given channels.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/compiler/passes/hardware/define.py</code> <pre><code>def validate_waveforms(\n    level_couplings: Dict, circuit: analog_circuit.AnalogCircuit\n) -&gt; None:\n    \"\"\"4. validate piecewise linear and piecewise constant pieces of pulses\n\n    This pass check to make sure that the waveforms are compatible with the\n    hardware. This includes checking that the waveforms are piecewise linear or\n    piecewise constant. It also checks that the waveforms are compatible with\n    the given channels.\n\n    Args:\n        circuit: AnalogCircuit to validate waveforms for\n        level_couplings: Dictionary containing the given channels for the\n            sequence.\n\n    Raises:\n        ValueError: If the waveforms are not piecewise linear or piecewise\n            constant, e.g. the waveform is not continuous.\n        ValueError: If a waveform segment is not compatible with the given\n            channels.\n\n    \"\"\"\n    from bloqade.analog.compiler.analysis.common import CheckSlices\n    from bloqade.analog.compiler.analysis.hardware import (\n        ValidatePiecewiseLinearChannel,\n        ValidatePiecewiseConstantChannel,\n    )\n\n    channel_iter = (\n        (level_coupling, field_name, sm)\n        for level_coupling, fields in level_couplings.items()\n        for field_name, spatial_modulations in fields.items()\n        for sm in spatial_modulations\n    )\n    for channel in channel_iter:\n        if channel[1] in [pulse.detuning, pulse.rabi.amplitude]:\n            ValidatePiecewiseLinearChannel(*channel).visit(circuit)\n        else:\n            ValidatePiecewiseConstantChannel(*channel).visit(circuit)\n\n    CheckSlices().visit(circuit)\n\n    if circuit.sequence.duration() == 0:\n        raise ValueError(\"Circuit Duration must be be non-zero\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/passes/hardware/units/","title":"Units","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/#bloqade.analog.compiler.rewrite.common.AssignToLiteral","title":"AssignToLiteral","text":"<p>               Bases: <code>BloqadeIRTransformer</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.compiler.rewrite.common.AssignToLiteral[AssignToLiteral]\n              bloqade.analog.ir.visitor.BloqadeIRTransformer[BloqadeIRTransformer]\n              bloqade.analog.ir.visitor.BloqadeIRVisitor[BloqadeIRVisitor]\n\n                              bloqade.analog.ir.visitor.BloqadeIRTransformer --&gt; bloqade.analog.compiler.rewrite.common.AssignToLiteral\n                                bloqade.analog.ir.visitor.BloqadeIRVisitor --&gt; bloqade.analog.ir.visitor.BloqadeIRTransformer\n                \n\n\n\n              click bloqade.analog.compiler.rewrite.common.AssignToLiteral href \"\" \"bloqade.analog.compiler.rewrite.common.AssignToLiteral\"\n              click bloqade.analog.ir.visitor.BloqadeIRTransformer href \"\" \"bloqade.analog.ir.visitor.BloqadeIRTransformer\"\n              click bloqade.analog.ir.visitor.BloqadeIRVisitor href \"\" \"bloqade.analog.ir.visitor.BloqadeIRVisitor\"\n            </code></pre> <p>Transform all assigned variables to literals.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/add_padding/","title":"Add padding","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/assign_to_literal/","title":"Assign to literal","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/assign_to_literal/#bloqade.analog.compiler.rewrite.common.assign_to_literal.AssignToLiteral","title":"AssignToLiteral","text":"<p>               Bases: <code>BloqadeIRTransformer</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.compiler.rewrite.common.assign_to_literal.AssignToLiteral[AssignToLiteral]\n              bloqade.analog.ir.visitor.BloqadeIRTransformer[BloqadeIRTransformer]\n              bloqade.analog.ir.visitor.BloqadeIRVisitor[BloqadeIRVisitor]\n\n                              bloqade.analog.ir.visitor.BloqadeIRTransformer --&gt; bloqade.analog.compiler.rewrite.common.assign_to_literal.AssignToLiteral\n                                bloqade.analog.ir.visitor.BloqadeIRVisitor --&gt; bloqade.analog.ir.visitor.BloqadeIRTransformer\n                \n\n\n\n              click bloqade.analog.compiler.rewrite.common.assign_to_literal.AssignToLiteral href \"\" \"bloqade.analog.compiler.rewrite.common.assign_to_literal.AssignToLiteral\"\n              click bloqade.analog.ir.visitor.BloqadeIRTransformer href \"\" \"bloqade.analog.ir.visitor.BloqadeIRTransformer\"\n              click bloqade.analog.ir.visitor.BloqadeIRVisitor href \"\" \"bloqade.analog.ir.visitor.BloqadeIRVisitor\"\n            </code></pre> <p>Transform all assigned variables to literals.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/assign_variables/","title":"Assign variables","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/canonicalize/","title":"Canonicalize","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/common/flatten/","title":"Flatten","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/python/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/compiler/rewrite/python/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/sparse_operator/","title":"Sparse operator","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/atom_type/","title":"Atom type","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/emulator/","title":"Emulator","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/emulator/#bloqade.analog.emulate.ir.emulator.Register","title":"Register  <code>dataclass</code>","text":"<pre><code>Register(\n    atom_type: AtomType,\n    sites: List[Tuple[Decimal, Decimal]],\n    blockade_radius: Decimal,\n    geometry: Optional[Geometry] = None,\n)\n</code></pre> <p>This class represents the of the atoms in the system.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/space/","title":"Space","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/","title":"State vector","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.AnalogGate","title":"AnalogGate  <code>dataclass</code>","text":"<pre><code>AnalogGate(hamiltonian: RydbergHamiltonian)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.AnalogGate.run","title":"run","text":"<pre><code>run(\n    shots: int = 1,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-14,\n    rtol: float = 1e-07,\n    nsteps: int = 2147483647,\n    interaction_picture: bool = False,\n    project_hyperfine: bool = True,\n) -&gt; NDArray[np.uint8]\n</code></pre> <p>Run the emulation with all atoms in the ground state, sampling the final state vector.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int = 1,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-14,\n    rtol: float = 1e-7,\n    nsteps: int = 2_147_483_647,\n    interaction_picture: bool = False,\n    project_hyperfine: bool = True,\n) -&gt; NDArray[np.uint8]:\n    \"\"\"Run the emulation with all atoms in the ground state,\n    sampling the final state vector.\"\"\"\n\n    options = dict(\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    state = self.hamiltonian.space.zero_state()\n    (result,) = self.apply(state, **options)\n    result.normalize()\n\n    return result.sample(shots, project_hyperfine=project_hyperfine)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.RydbergHamiltonian","title":"RydbergHamiltonian  <code>dataclass</code>","text":"<pre><code>RydbergHamiltonian(\n    emulator_ir: EmulatorProgram,\n    space: Space,\n    rydberg: NDArray,\n    detuning_ops: List[DetuningOperator] = list(),\n    rabi_ops: List[RabiOperator] = list(),\n)\n</code></pre> <p>Hamiltonian for a given task. With the <code>RydbergHamiltonian</code> you can convert the Hamiltonian to CSR matrix form as well as obtaining the average energy/variance of a register.</p> <p>Attributes:</p> Name Type Description <code>emulator_ir</code> <code>EmulatorProgram</code> <p>A copy of the original program used to generate the RydbergHamiltonian</p> <code>space</code> <code>Space</code> <p>The Hilbert space of the Hamiltonian, should align with the register the Hamiltonian is being applied on for average energy/variance</p> <code>rydberg</code> <code>NDArray</code> <p>Rydberg interaction operator</p> <code>detuning_ops</code> <code>List[DetuningOperator]</code> <p>Detuning Operators of the Hamiltonian</p> <code>rabi_ops</code> <code>List[RabiOperator]</code> <p>Rabi Operators of the Hamiltonian</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.RydbergHamiltonian.average","title":"average","text":"<pre><code>average(\n    register: StateVector, time: Optional[float] = None\n) -&gt; float\n</code></pre> <p>Get energy average from RydbergHamiltonian object at time <code>time</code> with register <code>register</code></p> <p>Parameters:</p> Name Type Description Default <code>register</code> <code>StateVector</code> <p>The state vector to take average with</p> required <code>time</code> <code>Optional[float]</code> <p>Time value to evaluate average at.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>average energy at time <code>time</code></p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef average(\n    self,\n    register: StateVector,\n    time: Optional[float] = None,\n) -&gt; float:\n    \"\"\"Get energy average from RydbergHamiltonian object at time `time` with\n    register `register`\n\n    Args:\n        register (StateVector): The state vector to take average with\n        time (Optional[float], optional): Time value to evaluate average at.\n        Defaults to duration of RydbergHamiltonian.\n\n    Returns:\n        float: average energy at time `time`\n    \"\"\"\n    return np.vdot(register.data, self._apply(register.data, time)).real\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.RydbergHamiltonian.average_and_variance","title":"average_and_variance","text":"<pre><code>average_and_variance(\n    register: StateVector, time: Optional[float] = None\n) -&gt; Tuple[float, float]\n</code></pre> <p>Get energy average and variance from RydbergHamiltonian object at time <code>time</code> with register <code>register</code></p> <p>Parameters:</p> Name Type Description Default <code>register</code> <code>StateVector</code> <p>The state vector to take average and variance with</p> required <code>time</code> <code>Optional[float]</code> <p>Time value to evaluate average at.</p> <code>None</code> <p>Returns:</p> Type Description <code>float</code> <p>Tuple[float, float]: average and variance of energy at time <code>time</code></p> <code>float</code> <p>respectively.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef average_and_variance(\n    self,\n    register: StateVector,\n    time: Optional[float] = None,\n) -&gt; Tuple[float, float]:\n    \"\"\"Get energy average and variance from RydbergHamiltonian object at time `time`\n    with register `register`\n\n    Args:\n        register (StateVector): The state vector to take average and variance with\n        time (Optional[float], optional): Time value to evaluate average at.\n        Defaults to duration of RydbergHamiltonian.\n\n    Returns:\n        Tuple[float, float]: average and variance of energy at time `time`\n        respectively.\n    \"\"\"\n    H_register_data = self._apply(register.data, time)\n\n    average = np.vdot(register.data, H_register_data).real\n    square_average = np.vdot(H_register_data, H_register_data).real\n\n    return average, square_average - average**2\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.RydbergHamiltonian.tocsr","title":"tocsr","text":"<pre><code>tocsr(time: float) -&gt; csr_matrix\n</code></pre> <p>Return the Hamiltonian as a csr matrix at time <code>time</code>.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>time to evaluate the Hamiltonian at.</p> required <p>Returns:</p> Name Type Description <code>csr_matrix</code> <code>csr_matrix</code> <p>The Hamiltonian as a csr matrix.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>def tocsr(self, time: float) -&gt; csr_matrix:\n    \"\"\"Return the Hamiltonian as a csr matrix at time `time`.\n\n    Args:\n        time (float): time to evaluate the Hamiltonian at.\n\n    Returns:\n        csr_matrix: The Hamiltonian as a csr matrix.\n\n    \"\"\"\n    diagonal = sum(\n        (detuning.get_diagonal(time) for detuning in self.detuning_ops),\n        start=self.rydberg,\n    )\n\n    hamiltonian = diags(diagonal).tocsr()\n    for rabi_op in self.rabi_ops:\n        hamiltonian = hamiltonian + rabi_op.tocsr(time)\n\n    return hamiltonian\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.RydbergHamiltonian.variance","title":"variance","text":"<pre><code>variance(\n    register: StateVector, time: Optional[float] = None\n) -&gt; float\n</code></pre> <p>Get the energy variance from RydbergHamiltonian object at time <code>time</code> with register <code>register</code></p> <p>Parameters:</p> Name Type Description Default <code>register</code> <code>StateVector</code> <p>The state vector to take variance with</p> required <code>time</code> <code>Optional[float]</code> <p>Time value to evaluate average at.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>complex</code> <code>float</code> <p>variance of energy at time <code>time</code> respectively.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>@beartype\ndef variance(\n    self,\n    register: StateVector,\n    time: Optional[float] = None,\n) -&gt; float:\n    \"\"\"Get the energy variance from RydbergHamiltonian object at\n    time `time` with register `register`\n\n    Args:\n        register (StateVector): The state vector to take variance with\n        time (Optional[float], optional): Time value to evaluate average at.\n        Defaults to duration of RydbergHamiltonian.\n\n    Returns:\n        complex: variance of energy at time `time` respectively.\n    \"\"\"\n\n    _, var = self.average_and_variance(register, time)\n    return var\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.StateVector","title":"StateVector  <code>dataclass</code>","text":"<pre><code>StateVector(data: NDArray, space: Space)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.StateVector.local_trace","title":"local_trace","text":"<pre><code>local_trace(\n    matrix: ndarray, site_index: Union[int, Tuple[int, int]]\n) -&gt; complex\n</code></pre> <p>return trace of an operator over the StateVector.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>ndarray</code> <p>Square matrix representing operator in the local hilbert space.</p> required <code>site_index</code> <code>int | Tuple[int, int]</code> <p>sites to apply one body operator to.</p> required <p>Returns:</p> Name Type Description <code>complex</code> <code>complex</code> <p>the trace of the operator over the state-vector.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>Error is raised when the dimension of <code>operator</code> is not</p> <code>ValueError</code> <p>Error is raised when the <code>site</code> argument is out of bounds.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>@plum.dispatch\ndef local_trace(  # noqa: F811\n    self, matrix: np.ndarray, site_index: Union[int, Tuple[int, int]]\n) -&gt; complex:  # noqa: F811\n    \"\"\"return trace of an operator over the StateVector.\n\n    Args:\n        matrix (np.ndarray): Square matrix representing operator in the local\n            hilbert space.\n        site_index (int | Tuple[int, int]): sites to apply one body operator to.\n\n    Returns:\n        complex: the trace of the operator over the state-vector.\n\n    Raises:\n        ValueError: Error is raised when the dimension of `operator` is not\n        consistent with `site` argument. The size of the operator must fit\n        the size of the local hilbert space of `site` depending on the number\n        of sites and the number of levels inside each atom, e.g. for two site\n        expectation value with a three level atom the operator must be a 9 by\n        9 array.\n\n        ValueError: Error is raised when the `site` argument is out of bounds.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.StateVector.norm","title":"norm","text":"<pre><code>norm() -&gt; float\n</code></pre> <p>Return the norm of the state vector.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>def norm(self) -&gt; float:\n    \"\"\"Return the norm of the state vector.\"\"\"\n    return np.linalg.norm(self.data)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.StateVector.normalize","title":"normalize","text":"<pre><code>normalize() -&gt; None\n</code></pre> <p>Normalize the state vector.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>def normalize(self) -&gt; None:\n    \"\"\"Normalize the state vector.\"\"\"\n    data = self.data\n    data /= np.linalg.norm(data)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/emulate/ir/state_vector/#bloqade.analog.emulate.ir.state_vector.StateVector.sample","title":"sample","text":"<pre><code>sample(\n    shots: int, project_hyperfine: bool = True\n) -&gt; NDArray\n</code></pre> <p>Sample the state vector and return bitstrings.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/emulate/ir/state_vector.py</code> <pre><code>def sample(self, shots: int, project_hyperfine: bool = True) -&gt; NDArray:\n    \"\"\"Sample the state vector and return bitstrings.\"\"\"\n    return self.space.sample_state_vector(\n        self.data, shots, project_hyperfine=project_hyperfine\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty [<code>ListOfLocations</code>][bloqade.ir.location.list.ListOfLocations].</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for [<code>Rydberg</code>][bloqade.builder.coupling.Rydberg]     Level coupling</li> <li><code>start.hyperfine</code>: for [<code>Hyperfine</code>][bloqade.builder.coupling.Hyperfine]     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li>[<code>Scalar</code>][bloqade.ir.scalar.Scalar] objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AlignedWaveform","title":"AlignedWaveform","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.AlignedWaveform[AlignedWaveform]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.AlignedWaveform\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.AlignedWaveform href \"\" \"bloqade.analog.ir.AlignedWaveform\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AnalogCircuit","title":"AnalogCircuit","text":"<p>AnalogCircuit is a dummy type that bundle register and sequence together.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with [<code>parallelize()</code>][bloqade.builder.emit.Emit.parallelize], The the register will be a [<code>ParallelRegister</code>][bloqade.ir.location.base.ParallelRegister]. Otherwise it will be a [<code>AtomArrangement</code>][bloqade.ir.location.base.AtomArrangement].</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"Interactive visualization of the program\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.ir.AtomArrangement href \"\" \"bloqade.analog.ir.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims: int\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[\n        Union[BoolArray, List[bool], bool]\n    ] = None,\n) -&gt; ListOfLocations\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(\n    n_defects: int, rng: Generator = np.random.default_rng()\n)\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability: float,\n    rng: Generator = np.random.default_rng(),\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments) -&gt; NDArray\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.analog.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale: ScalarType)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.AtomArrangement.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.ir.BoundedBravais href \"\" \"bloqade.analog.ir.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices [<code>AtomArrangement</code>][bloqade.ir.location.base.AtomArrangement].</p> <ul> <li>[<code>Square</code>][bloqade.ir.location.bravais.Square]</li> <li>[<code>Chain</code>][bloqade.ir.location.bravais.Chain]</li> <li>[<code>Honeycomb</code>][bloqade.ir.location.bravais.Honeycomb]</li> <li>[<code>Triangular</code>][bloqade.ir.location.bravais.Triangular]</li> <li>[<code>Lieb</code>][bloqade.ir.location.bravais.Lieb]</li> <li>[<code>Kagome</code>][bloqade.ir.location.bravais.Kagome]</li> <li>[<code>Rectangular</code>][bloqade.ir.location.bravais.Rectangular]</li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.n_atoms","title":"n_atoms  <code>cached</code> <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index: List[int]) -&gt; NDArray\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    for index in itertools.product(*[range(n) for n in self.shape]):\n        for pos in self.coordinates(list(index)):\n            position = tuple(self.lattice_spacing * pos)\n            yield LocationInfo.create(position, True)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor: ScalarType) -&gt; BoundedBravais\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Chain","title":"Chain","text":"<pre><code>Chain(\n    L: int,\n    *,\n    lattice_spacing: ScalarType = 1.0,\n    vertical_chain: bool = False\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Chain[Chain]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Chain\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Chain href \"\" \"bloqade.analog.ir.Chain\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Constant","title":"Constant","text":"<pre><code>Constant(value: ScalarType, duration: ScalarType)\n</code></pre> <p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Constant[Constant]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.Constant\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.Constant href \"\" \"bloqade.analog.ir.Constant\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"value\", cast(value))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Field","title":"Field","text":"<p>               Bases: <code>FieldExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Field[Field]\n              bloqade.analog.ir.control.field.FieldExpr[FieldExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.field.FieldExpr --&gt; bloqade.analog.ir.Field\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.field.FieldExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.field.FieldExpr\n                \n\n\n\n              click bloqade.analog.ir.Field href \"\" \"bloqade.analog.ir.Field\"\n              click bloqade.analog.ir.control.field.FieldExpr href \"\" \"bloqade.analog.ir.control.field.FieldExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Field node in the IR. Which contains collection(s) of [<code>Waveform</code>][bloqade.ir.control.waveform.Waveform]</p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Field\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Honeycomb[Honeycomb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Honeycomb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Honeycomb href \"\" \"bloqade.analog.ir.Honeycomb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (1/2, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Kagome","title":"Kagome","text":"<pre><code>Kagome(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Kagome[Kagome]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Kagome\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Kagome href \"\" \"bloqade.analog.ir.Kagome\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Lieb","title":"Lieb","text":"<pre><code>Lieb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Lieb[Lieb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Lieb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Lieb href \"\" \"bloqade.analog.ir.Lieb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Linear","title":"Linear","text":"<pre><code>Linear(\n    start: ScalarType,\n    stop: ScalarType,\n    duration: ScalarType,\n)\n</code></pre> <p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Linear[Linear]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.Linear\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.Linear href \"\" \"bloqade.analog.ir.Linear\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, start: ScalarType, stop: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"start\", cast(start))\n    object.__setattr__(self, \"stop\", cast(stop))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ListOfLocations","title":"ListOfLocations","text":"<pre><code>ListOfLocations(\n    location_list: List[\n        Union[LocationInfo, Tuple[ScalarType, ScalarType]]\n    ] = [],\n)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.ListOfLocations[ListOfLocations]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.ListOfLocations\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.ir.ListOfLocations href \"\" \"bloqade.analog.ir.ListOfLocations\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    location_list: List[Union[LocationInfo, Tuple[ScalarType, ScalarType]]] = [],\n):\n    self.location_list = []\n    for ele in location_list:\n        if isinstance(ele, LocationInfo):\n            self.location_list.append(ele)\n        else:\n            self.location_list.append(LocationInfo.create(ele, True))\n\n    if self.location_list:\n        self.__n_atoms = sum(\n            1 for loc in self.location_list if loc.filling == SiteFilling.filled\n        )\n        self.__n_sites = len(self.location_list)\n        self.__n_vacant = self.__n_sites - self.__n_atoms\n        self.__n_dims = len(self.location_list[0].position)\n    else:\n        self.__n_sites = 0\n        self.__n_atoms = 0\n        self.__n_dims = None\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ListOfLocations.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ListOfLocations.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ListOfLocations.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ListOfLocations.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ListOfLocations.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self):\n    return iter(self.location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Literal","title":"Literal","text":"<p>               Bases: <code>Real</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Literal[Literal]\n              bloqade.analog.ir.scalar.Real[Real]\n              bloqade.analog.ir.scalar.Scalar[Scalar]\n\n                              bloqade.analog.ir.scalar.Real --&gt; bloqade.analog.ir.Literal\n                                bloqade.analog.ir.scalar.Scalar --&gt; bloqade.analog.ir.scalar.Real\n                \n\n\n\n              click bloqade.analog.ir.Literal href \"\" \"bloqade.analog.ir.Literal\"\n              click bloqade.analog.ir.scalar.Real href \"\" \"bloqade.analog.ir.scalar.Real\"\n              click bloqade.analog.ir.scalar.Scalar href \"\" \"bloqade.analog.ir.scalar.Scalar\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Decimal\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.ParallelRegister[ParallelRegister]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.ParallelRegister\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.ir.ParallelRegister href \"\" \"bloqade.analog.ir.ParallelRegister\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ParallelRegister.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>Return the number of atoms in the program.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of atoms in the parsed register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register type is unsupported.</p> Note <p>If the register is of type ParallelRegister, the number of atoms is extracted from its internal register.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Parse):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; n_atoms = builder.n_atoms\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.ParallelRegister.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Poly","title":"Poly","text":"<pre><code>Poly(coeffs: Container[ScalarType], duration: ScalarType)\n</code></pre> <p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Poly[Poly]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.Poly\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.Poly href \"\" \"bloqade.analog.ir.Poly\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>Tuple[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, coeffs: Container[ScalarType], duration: ScalarType):\n    object.__setattr__(self, \"coeffs\", tuple(map(cast, coeffs)))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Pulse","title":"Pulse","text":"<p>               Bases: <code>PulseExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Pulse[Pulse]\n              bloqade.analog.ir.control.pulse.PulseExpr[PulseExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.pulse.PulseExpr --&gt; bloqade.analog.ir.Pulse\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n\n\n\n              click bloqade.analog.ir.Pulse href \"\" \"bloqade.analog.ir.Pulse\"\n              click bloqade.analog.ir.control.pulse.PulseExpr href \"\" \"bloqade.analog.ir.control.pulse.PulseExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Pulse\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.PythonFn","title":"PythonFn","text":"<p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.PythonFn[PythonFn]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.PythonFn\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.PythonFn href \"\" \"bloqade.analog.ir.PythonFn\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Record","title":"Record","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Record[Record]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.Record\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.Record href \"\" \"bloqade.analog.ir.Record\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt; &lt;side&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Rectangular[Rectangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Rectangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Rectangular href \"\" \"bloqade.analog.ir.Rectangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Sample","title":"Sample","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Sample[Sample]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.Sample\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.Sample href \"\" \"bloqade.analog.ir.Sample\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Sequence","title":"Sequence","text":"<p>               Bases: <code>SequenceExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Sequence[Sequence]\n              bloqade.analog.ir.control.sequence.SequenceExpr[SequenceExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.sequence.SequenceExpr --&gt; bloqade.analog.ir.Sequence\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.sequence.SequenceExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.sequence.SequenceExpr\n                \n\n\n\n              click bloqade.analog.ir.Sequence href \"\" \"bloqade.analog.ir.Sequence\"\n              click bloqade.analog.ir.control.sequence.SequenceExpr href \"\" \"bloqade.analog.ir.control.sequence.SequenceExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Sequence of a program, which includes pulses informations.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Sequence\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Square","title":"Square","text":"<pre><code>Square(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Square[Square]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Square\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Square href \"\" \"bloqade.analog.ir.Square\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Triangular","title":"Triangular","text":"<pre><code>Triangular(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Triangular[Triangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.Triangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.Triangular href \"\" \"bloqade.analog.ir.Triangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Variable","title":"Variable","text":"<p>               Bases: <code>Real</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Variable[Variable]\n              bloqade.analog.ir.scalar.Real[Real]\n              bloqade.analog.ir.scalar.Scalar[Scalar]\n\n                              bloqade.analog.ir.scalar.Real --&gt; bloqade.analog.ir.Variable\n                                bloqade.analog.ir.scalar.Scalar --&gt; bloqade.analog.ir.scalar.Real\n                \n\n\n\n              click bloqade.analog.ir.Variable href \"\" \"bloqade.analog.ir.Variable\"\n              click bloqade.analog.ir.scalar.Real href \"\" \"bloqade.analog.ir.scalar.Real\"\n              click bloqade.analog.ir.scalar.Scalar href \"\" \"bloqade.analog.ir.scalar.Scalar\"\n            </code></pre> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Waveform","title":"Waveform","text":"<p>               Bases: <code>HashTrait</code>, <code>CanonicalizeTrait</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.Waveform\n                \n\n\n              click bloqade.analog.ir.Waveform href \"\" \"bloqade.analog.ir.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Waveform node in the IR.</p> <ul> <li>[<code>&lt;instruction&gt;</code>][bloqade.ir.control.waveform.Instruction]</li> <li>[<code>&lt;smooth&gt;</code>][bloqade.ir.control.waveform.Smooth]</li> <li>[<code>&lt;slice&gt;</code>][bloqade.ir.control.waveform.Slice]</li> <li>[<code>&lt;apppend&gt;</code>][bloqade.ir.control.waveform.Append]</li> <li>[<code>&lt;negative&gt;</code>][bloqade.ir.control.waveform.Negative]</li> <li>[<code>&lt;scale&gt;</code>][bloqade.ir.control.waveform.Scale]</li> <li>[<code>&lt;add&gt;</code>][bloqade.ir.control.waveform.Add]</li> <li>[<code>&lt;record&gt;</code>][bloqade.ir.control.waveform.Record]</li> <li>[<code>&lt;sample&gt;</code>][bloqade.ir.control.waveform.Sample]</li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n    \"\"\"get figure of the plotting the waveform.\n\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\n    return get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.cast","title":"cast","text":"<pre><code>cast(py) -&gt; Scalar\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to [<code>Scalar Literal</code>][bloqade.ir.scalar.Literal].</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to [<code>Scalar Variable</code>][bloqade.ir.scalar.Variable].</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/#bloqade.analog.ir.var","title":"var","text":"<pre><code>var(py: str) -&gt; Variable\n</code></pre> <p>cast string (or list/tuple of strings) to [<code>Variable</code>][bloqade.ir.scalar.Variable].</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/analog_circuit/","title":"Analog circuit","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/analog_circuit/#bloqade.analog.ir.analog_circuit.AnalogCircuit","title":"AnalogCircuit","text":"<p>AnalogCircuit is a dummy type that bundle register and sequence together.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/analog_circuit/#bloqade.analog.ir.analog_circuit.AnalogCircuit.register","title":"register  <code>property</code>","text":"<pre><code>register\n</code></pre> <p>Get the register of the program.</p> <p>Returns:</p> Type Description <p>register (Union[\"AtomArrangement\", \"ParallelRegister\"])</p> Note <p>If the program is built with [<code>parallelize()</code>][bloqade.builder.emit.Emit.parallelize], The the register will be a [<code>ParallelRegister</code>][bloqade.ir.location.base.ParallelRegister]. Otherwise it will be a [<code>AtomArrangement</code>][bloqade.ir.location.base.AtomArrangement].</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/analog_circuit/#bloqade.analog.ir.analog_circuit.AnalogCircuit.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the program</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the program</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/analog_circuit.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"Interactive visualization of the program\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the program\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/","title":"Scalar","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/#bloqade.analog.ir.scalar.Literal","title":"Literal","text":"<p>               Bases: <code>Real</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.scalar.Literal[Literal]\n              bloqade.analog.ir.scalar.Real[Real]\n              bloqade.analog.ir.scalar.Scalar[Scalar]\n\n                              bloqade.analog.ir.scalar.Real --&gt; bloqade.analog.ir.scalar.Literal\n                                bloqade.analog.ir.scalar.Scalar --&gt; bloqade.analog.ir.scalar.Real\n                \n\n\n\n              click bloqade.analog.ir.scalar.Literal href \"\" \"bloqade.analog.ir.scalar.Literal\"\n              click bloqade.analog.ir.scalar.Real href \"\" \"bloqade.analog.ir.scalar.Real\"\n              click bloqade.analog.ir.scalar.Scalar href \"\" \"bloqade.analog.ir.scalar.Scalar\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/#bloqade.analog.ir.scalar.Literal.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: Decimal\n</code></pre> <p>Scalar Literal, which stores a decimaal value instance.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Decimal</code> <p>decimal value instance</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/#bloqade.analog.ir.scalar.Scalar","title":"Scalar","text":"<p>Base class for all scalar expressions.</p> <pre><code>&lt;scalar&gt; ::= &lt;literal&gt;\n| &lt;variable&gt;\n| &lt;default&gt;\n| &lt;negative&gt;\n| &lt;add&gt;\n| &lt;mul&gt;\n| &lt;min&gt;\n| &lt;max&gt;\n| &lt;slice&gt;\n| &lt;inverval&gt;\n\n&lt;mul&gt; ::= &lt;scalar&gt; '*' &lt;scalar&gt;\n&lt;add&gt; ::= &lt;scalar&gt; '+' &lt;scalar&gt;\n&lt;min&gt; ::= 'min' &lt;scalar&gt;+\n&lt;max&gt; ::= 'max' &lt;scalar&gt;+\n&lt;slice&gt; ::= &lt;scalar expr&gt; '[' &lt;interval&gt; ']'\n&lt;interval&gt; ::= &lt;scalar expr&gt; '..' &lt;scalar expr&gt;\n&lt;real&gt; ::= &lt;literal&gt; | &lt;var&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/#bloqade.analog.ir.scalar.Variable","title":"Variable","text":"<p>               Bases: <code>Real</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.scalar.Variable[Variable]\n              bloqade.analog.ir.scalar.Real[Real]\n              bloqade.analog.ir.scalar.Scalar[Scalar]\n\n                              bloqade.analog.ir.scalar.Real --&gt; bloqade.analog.ir.scalar.Variable\n                                bloqade.analog.ir.scalar.Scalar --&gt; bloqade.analog.ir.scalar.Real\n                \n\n\n\n              click bloqade.analog.ir.scalar.Variable href \"\" \"bloqade.analog.ir.scalar.Variable\"\n              click bloqade.analog.ir.scalar.Real href \"\" \"bloqade.analog.ir.scalar.Real\"\n              click bloqade.analog.ir.scalar.Scalar href \"\" \"bloqade.analog.ir.scalar.Scalar\"\n            </code></pre> <p>Variable, which stores a variable name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>variable instance.</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/#bloqade.analog.ir.scalar.cast","title":"cast","text":"<pre><code>cast(py) -&gt; Scalar\n</code></pre> <ol> <li> <p>cast Real number (or list/tuple of Real numbers) to [<code>Scalar Literal</code>][bloqade.ir.scalar.Literal].</p> </li> <li> <p>cast str (or list/tuple of Real numbers) to [<code>Scalar Variable</code>][bloqade.ir.scalar.Variable].</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, Real, Tuple[Real], List[Real]]</code> <p>python object to cast</p> required <p>Returns:</p> Type Description <code>Scalar</code> <p>Scalar</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/scalar.py</code> <pre><code>def cast(py) -&gt; \"Scalar\":\n    \"\"\"\n    1. cast Real number (or list/tuple of Real numbers)\n    to [`Scalar Literal`][bloqade.ir.scalar.Literal].\n\n    2. cast str (or list/tuple of Real numbers)\n    to [`Scalar Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str,Real,Tuple[Real],List[Real]]): python object to cast\n\n    Returns:\n        Scalar\n    \"\"\"\n    ret = trycast(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Scalar Literal\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/scalar/#bloqade.analog.ir.scalar.var","title":"var","text":"<pre><code>var(py: str) -&gt; Variable\n</code></pre> <p>cast string (or list/tuple of strings) to [<code>Variable</code>][bloqade.ir.scalar.Variable].</p> <p>Parameters:</p> Name Type Description Default <code>py</code> <code>Union[str, List[str]]</code> <p>a string or list/tuple of strings</p> required <p>Returns:</p> Type Description <code>Variable</code> <p>Union[Variable]</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/scalar.py</code> <pre><code>def var(py: str) -&gt; \"Variable\":\n    \"\"\"cast string (or list/tuple of strings)\n    to [`Variable`][bloqade.ir.scalar.Variable].\n\n    Args:\n        py (Union[str, List[str]]): a string or list/tuple of strings\n\n    Returns:\n       Union[Variable]\n    \"\"\"\n    ret = tryvar(py)\n    if ret is None:\n        raise TypeError(f\"Cannot cast {type(py)} to Variable\")\n\n    return ret\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/field/","title":"Field","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/field/#bloqade.analog.ir.control.field.Field","title":"Field","text":"<p>               Bases: <code>FieldExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.field.Field[Field]\n              bloqade.analog.ir.control.field.FieldExpr[FieldExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.field.FieldExpr --&gt; bloqade.analog.ir.control.field.Field\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.field.FieldExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.field.FieldExpr\n                \n\n\n\n              click bloqade.analog.ir.control.field.Field href \"\" \"bloqade.analog.ir.control.field.Field\"\n              click bloqade.analog.ir.control.field.FieldExpr href \"\" \"bloqade.analog.ir.control.field.FieldExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Field node in the IR. Which contains collection(s) of [<code>Waveform</code>][bloqade.ir.control.waveform.Waveform]</p> <pre><code>&lt;field&gt; ::= ('field' &lt;spatial modulation&gt;  &lt;padded waveform&gt;)*\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/field/#bloqade.analog.ir.control.field.Field.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Field</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Field</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/field.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Field\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Field\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/pulse/","title":"Pulse","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/pulse/#bloqade.analog.ir.control.pulse.Append","title":"Append","text":"<p>               Bases: <code>AppendTrait</code>, <code>PulseExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.pulse.Append[Append]\n              bloqade.analog.ir.control.traits.append.AppendTrait[AppendTrait]\n              bloqade.analog.ir.control.pulse.PulseExpr[PulseExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.traits.append.AppendTrait --&gt; bloqade.analog.ir.control.pulse.Append\n                \n                bloqade.analog.ir.control.pulse.PulseExpr --&gt; bloqade.analog.ir.control.pulse.Append\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n\n\n\n              click bloqade.analog.ir.control.pulse.Append href \"\" \"bloqade.analog.ir.control.pulse.Append\"\n              click bloqade.analog.ir.control.traits.append.AppendTrait href \"\" \"bloqade.analog.ir.control.traits.append.AppendTrait\"\n              click bloqade.analog.ir.control.pulse.PulseExpr href \"\" \"bloqade.analog.ir.control.pulse.PulseExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;append&gt; ::= &lt;expr&gt;+\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/pulse/#bloqade.analog.ir.control.pulse.Pulse","title":"Pulse","text":"<p>               Bases: <code>PulseExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.pulse.Pulse[Pulse]\n              bloqade.analog.ir.control.pulse.PulseExpr[PulseExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.pulse.PulseExpr --&gt; bloqade.analog.ir.control.pulse.Pulse\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n\n\n\n              click bloqade.analog.ir.control.pulse.Pulse href \"\" \"bloqade.analog.ir.control.pulse.Pulse\"\n              click bloqade.analog.ir.control.pulse.PulseExpr href \"\" \"bloqade.analog.ir.control.pulse.PulseExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;pulse&gt; ::= (&lt;field name&gt; &lt;field&gt;)+\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/pulse/#bloqade.analog.ir.control.pulse.Pulse.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Pulse</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Pulse</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/pulse.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Pulse\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Pulse\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/pulse/#bloqade.analog.ir.control.pulse.PulseExpr","title":"PulseExpr","text":"<p>               Bases: <code>HashTrait</code>, <code>CanonicalizeTrait</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.pulse.PulseExpr[PulseExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.pulse.PulseExpr\n                \n\n\n              click bloqade.analog.ir.control.pulse.PulseExpr href \"\" \"bloqade.analog.ir.control.pulse.PulseExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;expr&gt; ::= &lt;pulse&gt;\n  | &lt;append&gt;\n  | &lt;slice&gt;\n  | &lt;named&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/sequence/","title":"Sequence","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/sequence/#bloqade.analog.ir.control.sequence.Sequence","title":"Sequence","text":"<p>               Bases: <code>SequenceExpr</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.sequence.Sequence[Sequence]\n              bloqade.analog.ir.control.sequence.SequenceExpr[SequenceExpr]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.sequence.SequenceExpr --&gt; bloqade.analog.ir.control.sequence.Sequence\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.sequence.SequenceExpr\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.sequence.SequenceExpr\n                \n\n\n\n              click bloqade.analog.ir.control.sequence.Sequence href \"\" \"bloqade.analog.ir.control.sequence.Sequence\"\n              click bloqade.analog.ir.control.sequence.SequenceExpr href \"\" \"bloqade.analog.ir.control.sequence.SequenceExpr\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Sequence of a program, which includes pulses informations.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/sequence/#bloqade.analog.ir.control.sequence.Sequence.show","title":"show","text":"<pre><code>show(**assignments)\n</code></pre> <p>Interactive visualization of the Sequence</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>assigning the instance value (literal) to the existing variables in the Sequence</p> <code>{}</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/sequence.py</code> <pre><code>def show(self, **assignments):\n    \"\"\"\n    Interactive visualization of the Sequence\n\n    Args:\n        **assignments: assigning the instance value (literal) to the\n            existing variables in the Sequence\n\n    \"\"\"\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/","title":"Waveform","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Add","title":"Add","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Add[Add]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Add\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Add href \"\" \"bloqade.analog.ir.control.waveform.Add\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;add&gt; ::= &lt;waveform&gt; '+' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.AlignedWaveform","title":"AlignedWaveform","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.AlignedWaveform[AlignedWaveform]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.AlignedWaveform\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.AlignedWaveform href \"\" \"bloqade.analog.ir.control.waveform.AlignedWaveform\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;padded waveform&gt; ::= &lt;waveform&gt; | &lt;waveform&gt; &lt;alignment&gt; &lt;value&gt;\n\n&lt;alignment&gt; ::= 'left aligned' | 'right aligned'\n&lt;value&gt; ::= 'left value' | 'right value' | &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Append","title":"Append","text":"<p>               Bases: <code>AppendTrait</code>, <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Append[Append]\n              bloqade.analog.ir.control.traits.append.AppendTrait[AppendTrait]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.traits.append.AppendTrait --&gt; bloqade.analog.ir.control.waveform.Append\n                \n                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Append\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Append href \"\" \"bloqade.analog.ir.control.waveform.Append\"\n              click bloqade.analog.ir.control.traits.append.AppendTrait href \"\" \"bloqade.analog.ir.control.traits.append.AppendTrait\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;append&gt; ::= &lt;waveform&gt;+\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Constant","title":"Constant","text":"<pre><code>Constant(value: ScalarType, duration: ScalarType)\n</code></pre> <p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Constant[Constant]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.control.waveform.Constant\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.control.waveform.Constant href \"\" \"bloqade.analog.ir.control.waveform.Constant\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;constant&gt; ::= 'constant' &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = value</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Scalar</code> <p>the constant value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the constant waveform.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, value: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"value\", cast(value))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Instruction","title":"Instruction","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Instruction node in the IR.</p> <ul> <li>[<code>&lt;linear&gt;</code>][bloqade.ir.control.waveform.Linear]</li> <li>[<code>&lt;constant&gt;</code>][bloqade.ir.control.waveform.Constant]</li> <li>[<code>&lt;poly&gt;</code>][bloqade.ir.control.waveform.Poly]</li> <li>[<code>&lt;python-fn&gt;</code>][bloqade.ir.control.waveform.PythonFn]</li> </ul> <pre><code>&lt;instruction&gt; ::= &lt;linear&gt;\n    | &lt;constant&gt;\n    | &lt;poly&gt;\n    | &lt;python-fn&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Linear","title":"Linear","text":"<pre><code>Linear(\n    start: ScalarType,\n    stop: ScalarType,\n    duration: ScalarType,\n)\n</code></pre> <p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Linear[Linear]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.control.waveform.Linear\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.control.waveform.Linear href \"\" \"bloqade.analog.ir.control.waveform.Linear\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;linear&gt; ::= 'linear' &lt;scalar expr&gt; &lt;scalar expr&gt;\n</code></pre> <p>f(t=0:duration) = start + (stop-start)/duration * t</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>Scalar</code> <p>start value</p> required <code>stop</code> <code>Scalar</code> <p>stop value</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the linear waveform.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, start: ScalarType, stop: ScalarType, duration: ScalarType):\n    object.__setattr__(self, \"start\", cast(start))\n    object.__setattr__(self, \"stop\", cast(stop))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Negative","title":"Negative","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Negative[Negative]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Negative\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Negative href \"\" \"bloqade.analog.ir.control.waveform.Negative\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;negative&gt; ::= '-' &lt;waveform&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Poly","title":"Poly","text":"<pre><code>Poly(coeffs: Container[ScalarType], duration: ScalarType)\n</code></pre> <p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Poly[Poly]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.control.waveform.Poly\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.control.waveform.Poly href \"\" \"bloqade.analog.ir.control.waveform.Poly\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;poly&gt; ::= &lt;scalar&gt;+\n</code></pre> <p>f(t=0:duration) = c[0] + c[1]t + c[2]t^2 + ... + c[n-1]t^n-1 + c[n]t^n</p> <p>Parameters:</p> Name Type Description Default <code>coeffs</code> <code>Tuple[Scalar]</code> <p>the coefficients c[] of the polynomial.</p> required <code>duration</code> <code>Scalar</code> <p>the time span of the waveform.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>@beartype\ndef __init__(self, coeffs: Container[ScalarType], duration: ScalarType):\n    object.__setattr__(self, \"coeffs\", tuple(map(cast, coeffs)))\n    object.__setattr__(self, \"duration\", cast(duration))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.PythonFn","title":"PythonFn","text":"<p>               Bases: <code>Instruction</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.PythonFn[PythonFn]\n              bloqade.analog.ir.control.waveform.Instruction[Instruction]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Instruction --&gt; bloqade.analog.ir.control.waveform.PythonFn\n                                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Instruction\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n\n              click bloqade.analog.ir.control.waveform.PythonFn href \"\" \"bloqade.analog.ir.control.waveform.PythonFn\"\n              click bloqade.analog.ir.control.waveform.Instruction href \"\" \"bloqade.analog.ir.control.waveform.Instruction\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;python-fn&gt; ::= 'python-fn' &lt;python function def&gt; &lt;scalar expr&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Record","title":"Record","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Record[Record]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Record\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Record href \"\" \"bloqade.analog.ir.control.waveform.Record\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;record&gt; ::= 'record' &lt;waveform&gt; &lt;var&gt; &lt;side&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Sample","title":"Sample","text":"<p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Sample[Sample]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Sample\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Sample href \"\" \"bloqade.analog.ir.control.waveform.Sample\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;sample&gt; ::= 'sample' &lt;waveform&gt; &lt;interpolation&gt; &lt;scalar&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Scale","title":"Scale","text":"<pre><code>Scale(scalar, waveform: Waveform)\n</code></pre> <p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Scale[Scale]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Scale\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Scale href \"\" \"bloqade.analog.ir.control.waveform.Scale\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;scale&gt; ::= &lt;scalar expr&gt; '*' &lt;waveform&gt;\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>def __init__(self, scalar, waveform: Waveform):\n    object.__setattr__(self, \"scalar\", cast(scalar))\n    object.__setattr__(self, \"waveform\", waveform)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Slice","title":"Slice","text":"<p>               Bases: <code>SliceTrait</code>, <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Slice[Slice]\n              bloqade.analog.ir.control.traits.slice.SliceTrait[SliceTrait]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.traits.slice.SliceTrait --&gt; bloqade.analog.ir.control.waveform.Slice\n                \n                bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Slice\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Slice href \"\" \"bloqade.analog.ir.control.waveform.Slice\"\n              click bloqade.analog.ir.control.traits.slice.SliceTrait href \"\" \"bloqade.analog.ir.control.traits.slice.SliceTrait\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;slice&gt; ::= &lt;waveform&gt; &lt;scalar.interval&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Smooth","title":"Smooth","text":"<pre><code>Smooth(radius, kernel, waveform)\n</code></pre> <p>               Bases: <code>Waveform</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Smooth[Smooth]\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.waveform.Waveform --&gt; bloqade.analog.ir.control.waveform.Smooth\n                                bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n\n              click bloqade.analog.ir.control.waveform.Smooth href \"\" \"bloqade.analog.ir.control.waveform.Smooth\"\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <pre><code>&lt;smooth&gt; ::= 'smooth' &lt;kernel&gt; &lt;waveform&gt;\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>def __init__(self, radius, kernel, waveform):\n    if isinstance(kernel, str):\n        if kernel == \"Gaussian\":\n            kernel = GaussianKernel\n        elif kernel == \"Logistic\":\n            kernel = LogisticKernel\n        elif kernel == \"Sigmoid\":\n            kernel = SigmoidKernel\n        elif kernel == \"Triangle\":\n            kernel = TriangleKernel\n        elif kernel == \"Uniform\":\n            kernel = UniformKernel\n        elif kernel == \"Parabolic\":\n            kernel = ParabolicKernel\n        elif kernel == \"Biweight\":\n            kernel = BiweightKernel\n        elif kernel == \"Triweight\":\n            kernel = TriweightKernel\n        elif kernel == \"Tricube\":\n            kernel = TricubeKernel\n        elif kernel == \"Cosine\":\n            kernel = CosineKernel\n        else:\n            raise ValueError(f\"Invalid kernel: {kernel}\")\n\n    object.__setattr__(self, \"radius\", cast(radius))\n    object.__setattr__(self, \"kernel\", kernel)\n    object.__setattr__(self, \"waveform\", waveform)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Waveform","title":"Waveform","text":"<p>               Bases: <code>HashTrait</code>, <code>CanonicalizeTrait</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.control.waveform.Waveform[Waveform]\n              bloqade.analog.ir.control.traits.hash.HashTrait[HashTrait]\n              bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait[CanonicalizeTrait]\n\n                              bloqade.analog.ir.control.traits.hash.HashTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n                bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait --&gt; bloqade.analog.ir.control.waveform.Waveform\n                \n\n\n              click bloqade.analog.ir.control.waveform.Waveform href \"\" \"bloqade.analog.ir.control.waveform.Waveform\"\n              click bloqade.analog.ir.control.traits.hash.HashTrait href \"\" \"bloqade.analog.ir.control.traits.hash.HashTrait\"\n              click bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait href \"\" \"bloqade.analog.ir.control.traits.canonicalize.CanonicalizeTrait\"\n            </code></pre> <p>Waveform node in the IR.</p> <ul> <li>[<code>&lt;instruction&gt;</code>][bloqade.ir.control.waveform.Instruction]</li> <li>[<code>&lt;smooth&gt;</code>][bloqade.ir.control.waveform.Smooth]</li> <li>[<code>&lt;slice&gt;</code>][bloqade.ir.control.waveform.Slice]</li> <li>[<code>&lt;apppend&gt;</code>][bloqade.ir.control.waveform.Append]</li> <li>[<code>&lt;negative&gt;</code>][bloqade.ir.control.waveform.Negative]</li> <li>[<code>&lt;scale&gt;</code>][bloqade.ir.control.waveform.Scale]</li> <li>[<code>&lt;add&gt;</code>][bloqade.ir.control.waveform.Add]</li> <li>[<code>&lt;record&gt;</code>][bloqade.ir.control.waveform.Record]</li> <li>[<code>&lt;sample&gt;</code>][bloqade.ir.control.waveform.Sample]</li> </ul> <pre><code>&lt;waveform&gt; ::= &lt;instruction&gt;\n    | &lt;smooth&gt;\n    | &lt;slice&gt;\n    | &lt;append&gt;\n    | &lt;negative&gt;\n    | &lt;scale&gt;\n    | &lt;add&gt;\n    | &lt;record&gt;\n    | &lt;sample&gt;\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/waveform/#bloqade.analog.ir.control.waveform.Waveform.figure","title":"figure","text":"<pre><code>figure(**assignments)\n</code></pre> <p>get figure of the plotting the waveform.</p> <p>Returns:</p> Name Type Description <code>figure</code> <p>a bokeh figure</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/control/waveform.py</code> <pre><code>def figure(self, **assignments):\n    \"\"\"get figure of the plotting the waveform.\n\n    Returns:\n        figure: a bokeh figure\n    \"\"\"\n    return get_ir_figure(self, **assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/#bloqade.analog.ir.control.traits.SliceTrait","title":"SliceTrait","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/#bloqade.analog.ir.control.traits.SliceTrait.start","title":"start  <code>cached</code> <code>property</code>","text":"<pre><code>start: Scalar\n</code></pre> <p>Start time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The starting time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/#bloqade.analog.ir.control.traits.SliceTrait.stop","title":"stop  <code>cached</code> <code>property</code>","text":"<pre><code>stop: Scalar\n</code></pre> <p>Stop time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The stopping time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/append/","title":"Append","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/canonicalize/","title":"Canonicalize","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/hash/","title":"Hash","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/slice/","title":"Slice","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/slice/#bloqade.analog.ir.control.traits.slice.SliceTrait","title":"SliceTrait","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/slice/#bloqade.analog.ir.control.traits.slice.SliceTrait.start","title":"start  <code>cached</code> <code>property</code>","text":"<pre><code>start: Scalar\n</code></pre> <p>Start time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The starting time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/control/traits/slice/#bloqade.analog.ir.control.traits.slice.SliceTrait.stop","title":"stop  <code>cached</code> <code>property</code>","text":"<pre><code>stop: Scalar\n</code></pre> <p>Stop time of the sliced object</p> <p>Returns:</p> Name Type Description <code>Scalar</code> <code>Scalar</code> <p>The stopping time of the sliced object as a</p> <code>Scalar</code> <p>Scalar Expression</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.start","title":"start  <code>module-attribute</code>","text":"<pre><code>start = ListOfLocations()\n</code></pre> <p>A Program starting point, alias of empty [<code>ListOfLocations</code>][bloqade.ir.location.list.ListOfLocations].</p> <ul> <li>Next possible steps to build your program are:</li> <li>Specify which level coupling to address with:<ul> <li><code>start.rydberg</code>: for [<code>Rydberg</code>][bloqade.builder.coupling.Rydberg]     Level coupling</li> <li><code>start.hyperfine</code>: for [<code>Hyperfine</code>][bloqade.builder.coupling.Hyperfine]     Level coupling</li> <li>LOCKOUT: You cannot add atoms to your geometry after specifying level coupling.</li> </ul> </li> <li>continue/start building your geometry with:<ul> <li><code>start.add_position()</code>: to add atom(s) to current register. It will accept:<ul> <li>A single coordinate, represented as a tuple (e.g. <code>(5,6)</code>) with a value that   can either be:<ul> <li>integers: <code>(5,6)</code></li> <li>floats: <code>(5.1, 2.5)</code></li> <li>strings (for later variable assignment): <code>(\"x\", \"y\")</code></li> <li>[<code>Scalar</code>][bloqade.ir.scalar.Scalar] objects: <code>(2*cast(\"x\"), 5+cast(\"y\"))</code></li> </ul> </li> <li>A list of coordinates, represented as a list of types mentioned previously.</li> <li>A numpy array with shape (n, 2) where n is the total number of atoms</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.ir.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims: int\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[\n        Union[BoolArray, List[bool], bool]\n    ] = None,\n) -&gt; ListOfLocations\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(\n    n_defects: int, rng: Generator = np.random.default_rng()\n)\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability: float,\n    rng: Generator = np.random.default_rng(),\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments) -&gt; NDArray\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.analog.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale: ScalarType)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.AtomArrangement.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.ir.location.BoundedBravais href \"\" \"bloqade.analog.ir.location.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices [<code>AtomArrangement</code>][bloqade.ir.location.base.AtomArrangement].</p> <ul> <li>[<code>Square</code>][bloqade.ir.location.bravais.Square]</li> <li>[<code>Chain</code>][bloqade.ir.location.bravais.Chain]</li> <li>[<code>Honeycomb</code>][bloqade.ir.location.bravais.Honeycomb]</li> <li>[<code>Triangular</code>][bloqade.ir.location.bravais.Triangular]</li> <li>[<code>Lieb</code>][bloqade.ir.location.bravais.Lieb]</li> <li>[<code>Kagome</code>][bloqade.ir.location.bravais.Kagome]</li> <li>[<code>Rectangular</code>][bloqade.ir.location.bravais.Rectangular]</li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.n_atoms","title":"n_atoms  <code>cached</code> <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index: List[int]) -&gt; NDArray\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    for index in itertools.product(*[range(n) for n in self.shape]):\n        for pos in self.coordinates(list(index)):\n            position = tuple(self.lattice_spacing * pos)\n            yield LocationInfo.create(position, True)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor: ScalarType) -&gt; BoundedBravais\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Chain","title":"Chain","text":"<pre><code>Chain(\n    L: int,\n    *,\n    lattice_spacing: ScalarType = 1.0,\n    vertical_chain: bool = False\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Chain[Chain]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Chain\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Chain href \"\" \"bloqade.analog.ir.location.Chain\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Honeycomb[Honeycomb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Honeycomb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Honeycomb href \"\" \"bloqade.analog.ir.location.Honeycomb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (1/2, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Kagome","title":"Kagome","text":"<pre><code>Kagome(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Kagome[Kagome]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Kagome\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Kagome href \"\" \"bloqade.analog.ir.location.Kagome\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Lieb","title":"Lieb","text":"<pre><code>Lieb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Lieb[Lieb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Lieb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Lieb href \"\" \"bloqade.analog.ir.location.Lieb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ListOfLocations","title":"ListOfLocations","text":"<pre><code>ListOfLocations(\n    location_list: List[\n        Union[LocationInfo, Tuple[ScalarType, ScalarType]]\n    ] = [],\n)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.ListOfLocations[ListOfLocations]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.ListOfLocations\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.ir.location.ListOfLocations href \"\" \"bloqade.analog.ir.location.ListOfLocations\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    location_list: List[Union[LocationInfo, Tuple[ScalarType, ScalarType]]] = [],\n):\n    self.location_list = []\n    for ele in location_list:\n        if isinstance(ele, LocationInfo):\n            self.location_list.append(ele)\n        else:\n            self.location_list.append(LocationInfo.create(ele, True))\n\n    if self.location_list:\n        self.__n_atoms = sum(\n            1 for loc in self.location_list if loc.filling == SiteFilling.filled\n        )\n        self.__n_sites = len(self.location_list)\n        self.__n_vacant = self.__n_sites - self.__n_atoms\n        self.__n_dims = len(self.location_list[0].position)\n    else:\n        self.__n_sites = 0\n        self.__n_atoms = 0\n        self.__n_dims = None\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ListOfLocations.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ListOfLocations.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ListOfLocations.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ListOfLocations.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ListOfLocations.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self):\n    return iter(self.location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.ParallelRegister[ParallelRegister]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.ParallelRegister\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.ir.location.ParallelRegister href \"\" \"bloqade.analog.ir.location.ParallelRegister\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ParallelRegister.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>Return the number of atoms in the program.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of atoms in the parsed register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register type is unsupported.</p> Note <p>If the register is of type ParallelRegister, the number of atoms is extracted from its internal register.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Parse):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; n_atoms = builder.n_atoms\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.ParallelRegister.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Rectangular[Rectangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Rectangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Rectangular href \"\" \"bloqade.analog.ir.location.Rectangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Square","title":"Square","text":"<pre><code>Square(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Square[Square]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Square\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Square href \"\" \"bloqade.analog.ir.location.Square\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/#bloqade.analog.ir.location.Triangular","title":"Triangular","text":"<pre><code>Triangular(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.Triangular[Triangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.Triangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.Triangular href \"\" \"bloqade.analog.ir.location.Triangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/","title":"Bravais","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais","title":"BoundedBravais","text":"<pre><code>BoundedBravais(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.__match_args__","title":"__match_args__  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>__match_args__ = ('shape', 'lattice_spacing')\n</code></pre> <p>Base classe for Bravais lattices [<code>AtomArrangement</code>][bloqade.ir.location.base.AtomArrangement].</p> <ul> <li>[<code>Square</code>][bloqade.ir.location.bravais.Square]</li> <li>[<code>Chain</code>][bloqade.ir.location.bravais.Chain]</li> <li>[<code>Honeycomb</code>][bloqade.ir.location.bravais.Honeycomb]</li> <li>[<code>Triangular</code>][bloqade.ir.location.bravais.Triangular]</li> <li>[<code>Lieb</code>][bloqade.ir.location.bravais.Lieb]</li> <li>[<code>Kagome</code>][bloqade.ir.location.bravais.Kagome]</li> <li>[<code>Rectangular</code>][bloqade.ir.location.bravais.Rectangular]</li> </ul>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.n_atoms","title":"n_atoms  <code>cached</code> <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>dimension of the lattice</p> <p>Returns:</p> Name Type Description <code>int</code> <p>dimension of the lattice</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.coordinates","title":"coordinates","text":"<pre><code>coordinates(index: List[int]) -&gt; NDArray\n</code></pre> <p>calculate the coordinates of a cell in the lattice given the cell index.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef coordinates(self, index: List[int]) -&gt; NDArray:\n    \"\"\"calculate the coordinates of a cell in the lattice\n    given the cell index.\n    \"\"\"\n    # damn! this is like stone age broadcasting\n    vectors = np.array(self.cell_vectors())\n    index = np.array(index)\n    pos = np.sum(vectors.T * index, axis=1)\n    return pos + np.array(self.cell_atoms())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    for index in itertools.product(*[range(n) for n in self.shape]):\n        for pos in self.coordinates(list(index)):\n            position = tuple(self.lattice_spacing * pos)\n            yield LocationInfo.create(position, True)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.BoundedBravais.scale","title":"scale","text":"<pre><code>scale(factor: ScalarType) -&gt; BoundedBravais\n</code></pre> <p>Scale the current location with a factor.</p> <p>(x,y) -&gt; factor*(x,y)</p> <p>Parameters:</p> Name Type Description Default <code>factor</code> <code>str | Real | Decimal | Scalar</code> <p>scale factor</p> required <p>Returns:</p> Name Type Description <code>BoundedBravais</code> <code>BoundedBravais</code> <p>The lattice with the scaled locations</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef scale(self, factor: ScalarType) -&gt; \"BoundedBravais\":\n    \"\"\"Scale the current location with a factor.\n\n    (x,y) -&gt; factor*(x,y)\n\n    Args:\n        factor (str | Real | Decimal | Scalar): scale factor\n\n    Returns:\n        BoundedBravais: The lattice with the scaled locations\n    \"\"\"\n    factor = cast(factor)\n    obj = self.__new__(type(self))\n    for f in fields(self):\n        if f.name == \"lattice_spacing\":\n            obj.lattice_spacing = factor * self.lattice_spacing\n        else:\n            setattr(obj, f.name, getattr(self, f.name))\n    return obj\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Chain","title":"Chain","text":"<pre><code>Chain(\n    L: int,\n    *,\n    lattice_spacing: ScalarType = 1.0,\n    vertical_chain: bool = False\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Chain[Chain]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Chain\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Chain href \"\" \"bloqade.analog.ir.location.bravais.Chain\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Chain lattice.</p> <ul> <li>1D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0).</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in the chain</p> required <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L: int, *, lattice_spacing: ScalarType = 1.0, vertical_chain: bool = False\n):\n    self.L = L\n    self.lattice_spacing = cast(lattice_spacing)\n    self.vertical_chain = vertical_chain\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Honeycomb","title":"Honeycomb","text":"<pre><code>Honeycomb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Honeycomb[Honeycomb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Honeycomb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Honeycomb href \"\" \"bloqade.analog.ir.location.bravais.Honeycomb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Honeycomb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (2 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (1/2, 1/(2*sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = L1 * L1 * 2.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells in direction a2. n_atoms = L1 * L2 * 2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Kagome","title":"Kagome","text":"<pre><code>Kagome(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Kagome[Kagome]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Kagome\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Kagome href \"\" \"bloqade.analog.ir.location.bravais.Kagome\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Kagome lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0.25 ,0.25sqrt(3))</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = 3 * L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Lieb","title":"Lieb","text":"<pre><code>Lieb(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Lieb[Lieb]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Lieb\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Lieb href \"\" \"bloqade.analog.ir.location.bravais.Lieb\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Lieb lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (0, 1)</li> </ul> </li> <li>unit cell (3 atom(s))<ul> <li>loc1 (0, 0)</li> <li>loc2 (0.5, 0)</li> <li>loc3 (0 ,0.5)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of unit cells in linear direction. n_atoms = 3* L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of unit cells along a2 direction, n_atoms = 3 * L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Rectangular","title":"Rectangular","text":"<pre><code>Rectangular(\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Rectangular[Rectangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Rectangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Rectangular href \"\" \"bloqade.analog.ir.location.bravais.Rectangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Rectangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>int</code> <p>number of sites in x direction.</p> required <code>height</code> <code>int</code> <p>number of sites in y direction.</p> required <code>lattice_spacing_x</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <code>lattice_spacing_y</code> <code>(Scalar, Real)</code> <p>lattice spacing in y direction. optional.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    width: int,\n    height: int,\n    *,\n    lattice_spacing_x: ScalarType = 1.0,\n    lattice_spacing_y: ScalarType = 1.0,\n):\n    self.width = width\n    self.height = height\n    self.lattice_spacing_x = cast(lattice_spacing_x)\n    self.lattice_spacing_y = (\n        cast(lattice_spacing_y)\n        if lattice_spacing_y is not None\n        else self.lattice_spacing_x\n    )\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Square","title":"Square","text":"<pre><code>Square(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Square[Square]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Square\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Square href \"\" \"bloqade.analog.ir.location.bravais.Square\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Square lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1,0)</li> <li>a2 = (0,1)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0,0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L1</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L1 * L1.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites in direction a2. n_atoms = L1 * L2, default is L1</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/bravais/#bloqade.analog.ir.location.bravais.Triangular","title":"Triangular","text":"<pre><code>Triangular(\n    L1: int,\n    L2: Optional[int] = None,\n    *,\n    lattice_spacing: ScalarType = 1.0\n)\n</code></pre> <p>               Bases: <code>BoundedBravais</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.bravais.Triangular[Triangular]\n              bloqade.analog.ir.location.bravais.BoundedBravais[BoundedBravais]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.bravais.BoundedBravais --&gt; bloqade.analog.ir.location.bravais.Triangular\n                                bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.bravais.BoundedBravais\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n\n              click bloqade.analog.ir.location.bravais.Triangular href \"\" \"bloqade.analog.ir.location.bravais.Triangular\"\n              click bloqade.analog.ir.location.bravais.BoundedBravais href \"\" \"bloqade.analog.ir.location.bravais.BoundedBravais\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Triangular lattice.</p> <ul> <li>2D lattice</li> <li>primitive (cell) vector(s)<ul> <li>a1 = (1, 0)</li> <li>a2 = (1/2, sqrt(3)/2)</li> </ul> </li> <li>unit cell (1 atom(s))<ul> <li>loc (0, 0)</li> </ul> </li> </ul> <p>Parameters:</p> Name Type Description Default <code>L</code> <code>int</code> <p>number of sites in linear direction. n_atoms = L * L.</p> required <code>L2</code> <code>Optional[int]</code> <p>number of sites along a2 direction, n_atoms = L1 * L2, default is L1.</p> <code>None</code> <code>lattice_spacing</code> <code>(Scalar, Real)</code> <p>lattice spacing. Defaults to 1.0.</p> <code>1.0</code> <ul> <li>Possible Next:     continue with <code>.</code> to see possible next step in auto-prompt     supported setting (IPython, IDE ...)</li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/bravais.py</code> <pre><code>@beartype\ndef __init__(\n    self, L1: int, L2: Optional[int] = None, *, lattice_spacing: ScalarType = 1.0\n):\n    if L2 is None:\n        L2 = L1\n    self.L1 = L1\n    self.L2 = L2\n    self.lattice_spacing = cast(lattice_spacing)\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/","title":"Location","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement","title":"AtomArrangement","text":"<pre><code>AtomArrangement(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms: int\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims: int\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites: int\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant: int\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.add_position","title":"add_position","text":"<pre><code>add_position(\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[\n        Union[BoolArray, List[bool], bool]\n    ] = None,\n) -&gt; ListOfLocations\n</code></pre> <p>Add a position or multiple positions to a pre-existing geometry.</p> <p><code>add_position</code> is capable of accepting: - A single tuple for one atom coordinate: <code>(1.0, 2.5)</code> - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.] - A numpy array of shape (N, 2) where N is the number of atoms</p> <p>You may also intersperse variables anywhere a value may be present.</p> <p>You can also pass in an optional argument which determines the atom \"filling\" (whether or not at a specified coordinate an atom should be present).</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.add_position--usage-example","title":"Usage Example:","text":"<pre><code># single coordinate\n&gt;&gt;&gt; reg = start.add_position((0,0))\n# you may chain add_position calls\n&gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n# you can add variables anywhere a value may be present\n&gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n# and specify your atom fillings\n&gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n[True, False])\n# alternatively you could use one boolean to specify\n# all coordinates should be empty/filled\n&gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n(5.2, 2.2)], False)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def add_position(\n    self,\n    position: Union[\n        PositionArray,\n        List[Tuple[ScalarType, ScalarType]],\n        Tuple[ScalarType, ScalarType],\n    ],\n    filling: Optional[Union[BoolArray, List[bool], bool]] = None,\n) -&gt; \"ListOfLocations\":\n    \"\"\"\n    Add a position or multiple positions to a pre-existing geometry.\n\n    `add_position` is capable of accepting:\n    - A single tuple for one atom coordinate: `(1.0, 2.5)`\n    - A list of tuples: `[(0.0, 1.0), (2.0,1.5), etc.]\n    - A numpy array of shape (N, 2) where N is the number of atoms\n\n    You may also intersperse variables anywhere a value may be present.\n\n    You can also pass in an optional argument which determines the atom \"filling\"\n    (whether or not at a specified coordinate an atom should be present).\n\n    ### Usage Example:\n    ```\n    # single coordinate\n    &gt;&gt;&gt; reg = start.add_position((0,0))\n    # you may chain add_position calls\n    &gt;&gt;&gt; reg_plus_two = reg.add_position([(2,2),(5.0, 2.1)])\n    # you can add variables anywhere a value may be present\n    &gt;&gt;&gt; reg_with_var = reg_plus_two.add_position((\"x\", \"y\"))\n    # and specify your atom fillings\n    &gt;&gt;&gt; reg_with_filling = reg_with_var.add_position([(3.1, 0.0), (4.1, 2.2)],\n    [True, False])\n    # alternatively you could use one boolean to specify\n    # all coordinates should be empty/filled\n    &gt;&gt;&gt; reg_with_more_filling = reg_with_filling.add_positions([(3.1, 2.9),\n    (5.2, 2.2)], False)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`: to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`: to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    if is_bearable(position, PositionArray) and is_bearable(\n        filling, Optional[BoolArray]\n    ):\n        return self.add_position_ndarray(position, filling)\n    elif is_bearable(position, List[Tuple[ScalarType, ScalarType]]) and is_bearable(\n        filling, Optional[List[bool]]\n    ):\n        return self.add_position_list_tuples(position, filling)\n    elif is_bearable(position, Tuple[ScalarType, ScalarType]) and is_bearable(\n        filling, Optional[bool]\n    ):\n        return self.add_position_single_tupe(position, filling)\n    else:\n        raise TypeError(\"Invalid input types for add_position provided!\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.apply_defect_count","title":"apply_defect_count","text":"<pre><code>apply_defect_count(\n    n_defects: int, rng: Generator = np.random.default_rng()\n)\n</code></pre> <p>Drop <code>n_defects</code> atoms from the geometry randomly. Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.apply_defect_count--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n# you may also chain apply_defect_count calls\n&gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n# you can also use apply_defect_count on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>:     to add more positions</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts)     .apply_defect_density(defect_probability)</code>:     to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>:     to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify     Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>:     to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>:     shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_count(\n    self, n_defects: int, rng: np.random.Generator = np.random.default_rng()\n):\n    \"\"\"\n    Drop `n_defects` atoms from the geometry randomly. Internally this occurs\n    by setting certain sites to have a SiteFilling set to false indicating\n    no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_count(2, custom_rng)\n    # you may also chain apply_defect_count calls\n    &gt;&gt;&gt; reg.apply_defect_count(2, custom_rng)\n    # you can also use apply_defect_count on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)]).apply_defect_count(1, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n            to add more positions\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_count(n_defects)`: to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n            .apply_defect_density(defect_probability)`:\n            to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n            to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`: to specify\n            Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n            to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n            shows your geometry in your web browser\n    \"\"\"\n\n    location_list = []\n    for location_info in self.enumerate():\n        location_list.append(location_info)\n\n    filled_sites = []\n\n    for index, location_info in enumerate(location_list):\n        if location_info.filling is SiteFilling.filled:\n            filled_sites.append(index)\n\n    if n_defects &gt;= len(filled_sites):\n        raise ValueError(\n            f\"n_defects {n_defects} must be less than the number of filled sites \"\n            f\"({len(filled_sites)})\"\n        )\n\n    for _ in range(n_defects):\n        index = rng.choice(filled_sites)\n        location_list[index] = LocationInfo.create(\n            location_list[index].position,\n            (False if location_list[index].filling is SiteFilling.filled else True),\n        )\n        filled_sites.remove(index)\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.apply_defect_density","title":"apply_defect_density","text":"<pre><code>apply_defect_density(\n    defect_probability: float,\n    rng: Generator = np.random.default_rng(),\n)\n</code></pre> <p>Drop atoms randomly with <code>defect_probability</code> probability (range of 0 to 1). Internally this occurs by setting certain sites to have a SiteFilling set to false indicating no atom is present at the coordinate.</p> <p>A default numpy-based Random Number Generator is used but you can explicitly override this by passing in your own.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.apply_defect_density--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n&gt;&gt;&gt; import numpy as np\n# set a custom seed for a numpy-based RNG\n&gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n# randomly remove two atoms from the geometry\n&gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n# you may also chain apply_defect_density calls\n&gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n# you can also use apply_defect_density on custom geometries\n&gt;&gt;&gt; from bloqade import start\n&gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n.apply_defect_density(0.5, custom_rng)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...apply_defect_count(defect_counts).add_position(positions)</code>: to add more positions</li> <li><code>...apply_defect_count(defect_counts).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...apply_defect_count(defect_counts) .apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...apply_defect_count(defect_counts).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).rydberg</code>: to specify Rydberg coupling</li> <li><code>...apply_defect_count(defect_counts).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...apply_defect_count(defect_counts).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef apply_defect_density(\n    self,\n    defect_probability: float,\n    rng: np.random.Generator = np.random.default_rng(),\n):\n    \"\"\"\n    Drop atoms randomly with `defect_probability` probability (range of 0 to 1).\n    Internally this occurs by setting certain sites to have a SiteFilling\n    set to false indicating no atom is present at the coordinate.\n\n    A default numpy-based Random Number Generator is used but you can\n    explicitly override this by passing in your own.\n\n    ### Usage Example:\n\n    ```\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    &gt;&gt;&gt; import numpy as np\n    # set a custom seed for a numpy-based RNG\n    &gt;&gt;&gt; custom_rng = np.random.default_rng(888)\n    # randomly remove two atoms from the geometry\n    &gt;&gt;&gt; reg = Chain(11).apply_defect_density(0.2, custom_rng)\n    # you may also chain apply_defect_density calls\n    &gt;&gt;&gt; reg.apply_defect_count(0.1, custom_rng)\n    # you can also use apply_defect_density on custom geometries\n    &gt;&gt;&gt; from bloqade import start\n    &gt;&gt;&gt; start.add_position([(0,0), (1,1)])\n    .apply_defect_density(0.5, custom_rng)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...apply_defect_count(defect_counts).add_position(positions)`:\n        to add more positions\n        - `...apply_defect_count(defect_counts).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...apply_defect_count(defect_counts)\n        .apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...apply_defect_count(defect_counts).scale(scale)`:\n        to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...apply_defect_count(defect_counts).rydberg`:\n        to specify Rydberg coupling\n        - `...apply_defect_count(defect_counts).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...apply_defect_count(defect_counts).show()`:\n        shows your geometry in your web browser\n    \"\"\"\n\n    p = min(1, max(0, defect_probability))\n    location_list = []\n\n    for location_info in self.enumerate():\n        if rng.random() &lt; p:\n            location_list.append(\n                LocationInfo.create(\n                    location_info.position,\n                    (\n                        False\n                        if location_info.filling is SiteFilling.filled\n                        else True\n                    ),\n                )\n            )\n        else:\n            location_list.append(location_info)\n\n    return ListOfLocations(location_list=location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.enumerate","title":"enumerate","text":"<pre><code>enumerate() -&gt; Generator[LocationInfo, None, None]\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self) -&gt; Generator[LocationInfo, None, None]:\n    \"\"\"enumerate all locations in the register.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.figure","title":"figure","text":"<pre><code>figure(fig_kwargs=None, **assignments)\n</code></pre> <p>obtain a figure object from the atom arrangement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def figure(self, fig_kwargs=None, **assignments):\n    \"\"\"obtain a figure object from the atom arrangement.\"\"\"\n    return get_atom_arrangement_figure(self, fig_kwargs=fig_kwargs, **assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.rydberg_interaction","title":"rydberg_interaction","text":"<pre><code>rydberg_interaction(**assignments) -&gt; NDArray\n</code></pre> <p>calculate the Rydberg interaction matrix.</p> <p>Parameters:</p> Name Type Description Default <code>**assignments</code> <p>the values to assign to the variables in the register.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the Rydberg interaction matrix in the lower triangular form.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def rydberg_interaction(self, **assignments) -&gt; NDArray:\n    \"\"\"calculate the Rydberg interaction matrix.\n\n    Args:\n        **assignments: the values to assign to the variables in the register.\n\n    Returns:\n        NDArray: the Rydberg interaction matrix in the lower triangular form.\n\n    \"\"\"\n\n    from bloqade.analog.constants import RB_C6\n\n    # calculate the Interaction matrix\n    V_ij = np.zeros((self.n_sites, self.n_sites))\n    for i, site_i in enumerate(self.enumerate()):\n        pos_i = np.array([float(ele(**assignments)) for ele in site_i.position])\n\n        for j, site_j in enumerate(self.enumerate()):\n            if j &gt;= i:\n                break  # enforce lower triangular form\n\n            pos_j = np.array([float(ele(**assignments)) for ele in site_j.position])\n            r_ij = np.linalg.norm(pos_i - pos_j)\n\n            V_ij[i, j] = RB_C6 / r_ij**6\n\n    return V_ij\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.scale","title":"scale","text":"<pre><code>scale(scale: ScalarType)\n</code></pre> <p>Scale the geometry of your atoms.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.scale--usage-example","title":"Usage Example:","text":"<pre><code>&gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n# atom positions are now (0,0), (2,2)\n&gt;&gt;&gt; new_reg = reg.scale(2)\n# you may also use scale on pre-defined geometries\n&gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n# atoms in the chain will now be 2 um apart versus\n# the default 1 um\n&gt;&gt;&gt; Chain(11).scale(2)\n</code></pre> <ul> <li>Next possible steps are:</li> <li>Continuing to build your geometry via:<ul> <li><code>...add_position(positions).add_position(positions)</code>:     to add more positions</li> <li><code>...add_position(positions).apply_defect_count(n_defects)</code>: to randomly drop out n_atoms</li> <li><code>...add_position(positions).apply_defect_density(defect_probability)</code>: to drop out atoms with a certain probability</li> <li><code>...add_position(positions).scale(scale)</code>: to scale the geometry</li> </ul> </li> <li>Targeting a level coupling once you're done with the atom geometry:<ul> <li><code>...add_position(positions).rydberg</code>: to specify Rydberg coupling</li> <li><code>...add_position(positions).hyperfine</code>: to specify Hyperfine coupling</li> </ul> </li> <li>Visualizing your atom geometry:<ul> <li><code>...add_position(positions).show()</code>: shows your geometry in your web browser</li> </ul> </li> </ul> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef scale(self, scale: ScalarType):\n    \"\"\"\n    Scale the geometry of your atoms.\n\n    ### Usage Example:\n    ```\n    &gt;&gt;&gt; reg = start.add_position([(0,0), (1,1)])\n    # atom positions are now (0,0), (2,2)\n    &gt;&gt;&gt; new_reg = reg.scale(2)\n    # you may also use scale on pre-defined geometries\n    &gt;&gt;&gt; from bloqade.analog.atom_arrangement import Chain\n    # atoms in the chain will now be 2 um apart versus\n    # the default 1 um\n    &gt;&gt;&gt; Chain(11).scale(2)\n    ```\n\n    - Next possible steps are:\n    - Continuing to build your geometry via:\n        - `...add_position(positions).add_position(positions)`:\n            to add more positions\n        - `...add_position(positions).apply_defect_count(n_defects)`:\n        to randomly drop out n_atoms\n        - `...add_position(positions).apply_defect_density(defect_probability)`:\n        to drop out atoms with a certain probability\n        - `...add_position(positions).scale(scale)`: to scale the geometry\n    - Targeting a level coupling once you're done with the atom geometry:\n        - `...add_position(positions).rydberg`:\n        to specify Rydberg coupling\n        - `...add_position(positions).hyperfine`:\n        to specify Hyperfine coupling\n    - Visualizing your atom geometry:\n        - `...add_position(positions).show()`:\n        shows your geometry in your web browser\n\n    \"\"\"\n\n    scale = cast(scale)\n    location_list = []\n    for location_info in self.enumerate():\n        x, y = location_info.position\n        new_position = (scale * x, scale * y)\n        location_list.append(\n            LocationInfo.create(new_position, bool(location_info.filling.value))\n        )\n\n    return ListOfLocations(location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.AtomArrangement.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ListOfLocations","title":"ListOfLocations","text":"<pre><code>ListOfLocations(\n    location_list: List[\n        Union[LocationInfo, Tuple[ScalarType, ScalarType]]\n    ] = [],\n)\n</code></pre> <p>               Bases: <code>AtomArrangement</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.location.ListOfLocations[ListOfLocations]\n              bloqade.analog.ir.location.location.AtomArrangement[AtomArrangement]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.location.location.AtomArrangement --&gt; bloqade.analog.ir.location.location.ListOfLocations\n                                bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.AtomArrangement\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n\n              click bloqade.analog.ir.location.location.ListOfLocations href \"\" \"bloqade.analog.ir.location.location.ListOfLocations\"\n              click bloqade.analog.ir.location.location.AtomArrangement href \"\" \"bloqade.analog.ir.location.location.AtomArrangement\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>@beartype\ndef __init__(\n    self,\n    location_list: List[Union[LocationInfo, Tuple[ScalarType, ScalarType]]] = [],\n):\n    self.location_list = []\n    for ele in location_list:\n        if isinstance(ele, LocationInfo):\n            self.location_list.append(ele)\n        else:\n            self.location_list.append(LocationInfo.create(ele, True))\n\n    if self.location_list:\n        self.__n_atoms = sum(\n            1 for loc in self.location_list if loc.filling == SiteFilling.filled\n        )\n        self.__n_sites = len(self.location_list)\n        self.__n_vacant = self.__n_sites - self.__n_atoms\n        self.__n_dims = len(self.location_list[0].position)\n    else:\n        self.__n_sites = 0\n        self.__n_atoms = 0\n        self.__n_dims = None\n\n    super().__init__()\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ListOfLocations.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>number of atoms (filled sites) in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ListOfLocations.n_dims","title":"n_dims  <code>property</code>","text":"<pre><code>n_dims\n</code></pre> <p>number of dimensions in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ListOfLocations.n_sites","title":"n_sites  <code>property</code>","text":"<pre><code>n_sites\n</code></pre> <p>number of sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ListOfLocations.n_vacant","title":"n_vacant  <code>property</code>","text":"<pre><code>n_vacant\n</code></pre> <p>number of vacant sites in the register.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ListOfLocations.enumerate","title":"enumerate","text":"<pre><code>enumerate()\n</code></pre> <p>enumerate all locations in the register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def enumerate(self):\n    return iter(self.location_list)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ParallelRegister","title":"ParallelRegister","text":"<pre><code>ParallelRegister(parent: Optional[Builder] = None)\n</code></pre> <p>               Bases: <code>ProgramStart</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.location.location.ParallelRegister[ParallelRegister]\n              bloqade.analog.builder.start.ProgramStart[ProgramStart]\n              bloqade.analog.builder.drive.Drive[Drive]\n              bloqade.analog.builder.base.Builder[Builder]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.start.ProgramStart --&gt; bloqade.analog.ir.location.location.ParallelRegister\n                                bloqade.analog.builder.drive.Drive --&gt; bloqade.analog.builder.start.ProgramStart\n                \n                bloqade.analog.builder.base.Builder --&gt; bloqade.analog.builder.start.ProgramStart\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.builder.base.Builder\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.builder.base.Builder\n                \n\n\n\n\n              click bloqade.analog.ir.location.location.ParallelRegister href \"\" \"bloqade.analog.ir.location.location.ParallelRegister\"\n              click bloqade.analog.builder.start.ProgramStart href \"\" \"bloqade.analog.builder.start.ProgramStart\"\n              click bloqade.analog.builder.drive.Drive href \"\" \"bloqade.analog.builder.drive.Drive\"\n              click bloqade.analog.builder.base.Builder href \"\" \"bloqade.analog.builder.base.Builder\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/builder/base.py</code> <pre><code>def __init__(\n    self,\n    parent: Optional[\"Builder\"] = None,\n) -&gt; None:\n    self.__parent__ = parent\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ParallelRegister.n_atoms","title":"n_atoms  <code>property</code>","text":"<pre><code>n_atoms\n</code></pre> <p>Return the number of atoms in the program.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of atoms in the parsed register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register type is unsupported.</p> Note <p>If the register is of type ParallelRegister, the number of atoms is extracted from its internal register.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Parse):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; n_atoms = builder.n_atoms\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ParallelRegister.show","title":"show","text":"<pre><code>show(**assignments) -&gt; None\n</code></pre> <p>Display the current program being defined with the given arguments and batch ID.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Additional arguments for display.</p> <code>()</code> <code>batch_id</code> <code>int</code> <p>The batch ID to be displayed. Defaults to 0.</p> <code>0</code> Note <p>This method uses the <code>display_builder</code> function to render the builder's state.</p> <p>Example:</p> <pre><code>&gt;&gt;&gt; class MyBuilder(Show):\n...     pass\n&gt;&gt;&gt; builder = MyBuilder()\n&gt;&gt;&gt; builder.show()\n&gt;&gt;&gt; builder.show(batch_id=1)\n&gt;&gt;&gt; builder.show('arg1', 'arg2', batch_id=2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def show(self, **assignments) -&gt; None:\n    display_ir(self, assignments)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/location/location/#bloqade.analog.ir.location.location.ParallelRegisterInfo","title":"ParallelRegisterInfo","text":"<pre><code>ParallelRegisterInfo(parallel_register: ParallelRegister)\n</code></pre> <p>ParallelRegisterInfo</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/location/location.py</code> <pre><code>def __init__(self, parallel_register: ParallelRegister):\n    atom_arrangement = parallel_register.atom_arrangement\n    cluster_spacing = parallel_register.cluster_spacing\n\n    if atom_arrangement.n_atoms &gt; 0:\n        # calculate bounding box\n        # of this register\n        location_iter = atom_arrangement.enumerate()\n        (x, y) = next(location_iter).position\n        x_min = x\n        x_max = x\n        y_min = y\n        y_max = y\n\n        for location_info in location_iter:\n            (x, y) = location_info.position\n            x_min = x.min(x_min)\n            x_max = x.max(x_max)\n            y_min = y.min(y_min)\n            y_max = y.max(y_max)\n\n        shift_x = (x_max - x_min) + cluster_spacing\n        shift_y = (y_max - y_min) + cluster_spacing\n\n        register_locations = [\n            list(location_info.position)\n            for location_info in atom_arrangement.enumerate()\n        ]\n        register_filling = [\n            location_info.filling.value\n            for location_info in atom_arrangement.enumerate()\n        ]\n        shift_vectors = [[shift_x, cast(0)], [cast(0), shift_y]]\n    else:\n        raise ValueError(\"No locations to parallelize.\")\n\n    self.register_locations = register_locations\n    self.register_filling = register_filling\n    self.shift_vectors = shift_vectors\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/","title":"Base","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.Routine","title":"Routine","text":"<p>               Bases: <code>RoutineBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.base.Routine[Routine]\n              bloqade.analog.ir.routine.base.RoutineBase[RoutineBase]\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.routine.base.RoutineBase --&gt; bloqade.analog.ir.routine.base.Routine\n                                bloqade.analog.ir.routine.base.RoutineParse --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n                bloqade.analog.ir.routine.base.RoutineShow --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n\n\n              click bloqade.analog.ir.routine.base.Routine href \"\" \"bloqade.analog.ir.routine.base.Routine\"\n              click bloqade.analog.ir.routine.base.RoutineBase href \"\" \"bloqade.analog.ir.routine.base.RoutineBase\"\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre> <p>Result of parsing a completed Builder string.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineParse","title":"RoutineParse","text":"<p>               Bases: <code>Parse</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n\n                              bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineParse.parse","title":"parse","text":"<pre><code>parse() -&gt; Routine\n</code></pre> <p>Parse the program to return a Routine object.</p> <p>Returns:</p> Name Type Description <code>Routine</code> <code>Routine</code> <p>The parsed routine object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the routine cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/base.py</code> <pre><code>def parse(self: \"RoutineBase\") -&gt; \"Routine\":\n    if self.source is None:\n        raise ValueError(\"Cannot parse a routine without a source Builder.\")\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineParse.parse_circuit","title":"parse_circuit","text":"<pre><code>parse_circuit() -&gt; AnalogCircuit\n</code></pre> <p>Parse the analog circuit from the program.</p> <p>Returns:</p> Name Type Description <code>AnalogCircuit</code> <code>AnalogCircuit</code> <p>The parsed analog circuit.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the circuit cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/base.py</code> <pre><code>def parse_circuit(self: \"RoutineBase\") -&gt; AnalogCircuit:\n    return self.circuit\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineParse.parse_register","title":"parse_register","text":"<pre><code>parse_register() -&gt; (\n    Union[AtomArrangement, ParallelRegister]\n)\n</code></pre> <p>Parse the arrangement of atoms in the program.</p> <p>Returns:</p> Type Description <code>Union[AtomArrangement, ParallelRegister]</code> <p>Union[AtomArrangement, ParallelRegister]: The parsed atom arrangement or parallel register.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the register cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/base.py</code> <pre><code>def parse_register(self: \"RoutineBase\") -&gt; Union[AtomArrangement, ParallelRegister]:\n    return self.circuit.register\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineParse.parse_sequence","title":"parse_sequence","text":"<pre><code>parse_sequence() -&gt; Sequence\n</code></pre> <p>Parse the pulse sequence part of the program.</p> <p>Returns:</p> Name Type Description <code>Sequence</code> <code>Sequence</code> <p>The parsed pulse sequence.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the sequence cannot be parsed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/base.py</code> <pre><code>def parse_sequence(self: \"RoutineBase\") -&gt; Sequence:\n    return self.circuit.sequence\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineShow","title":"RoutineShow","text":"<p>               Bases: <code>Show</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/base/#bloqade.analog.ir.routine.base.RoutineShow.show","title":"show","text":"<pre><code>show(*args, batch_index: int = 0)\n</code></pre> <p>Show an interactive plot of the routine.</p> int <p>which parameter set out of the batch to use. Default is 0. If there are no batch parameters, use 0.</p> <p>*args: Any     Specify the parameters that are defined in the <code>.args([...])</code> build step.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/base.py</code> <pre><code>def show(self: \"RoutineBase\", *args, batch_index: int = 0):\n    \"\"\"Show an interactive plot of the routine.\n\n    batch_index: int\n        which parameter set out of the batch to use. Default is 0.\n        If there are no batch parameters, use 0.\n\n    *args: Any\n        Specify the parameters that are defined in the `.args([...])` build step.\n\n    \"\"\"\n    if self.source is None:\n        raise ValueError(\"Cannot show a routine without a source Builder.\")\n\n    return self.source.show(*args, batch_id=batch_index)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadeEmulation","title":"BloqadeEmulation  <code>dataclass</code>","text":"<pre><code>BloqadeEmulation(\n    task_data: TaskData,\n    compile_cache: Optional[CompileCache] = None,\n)\n</code></pre> <p>Data class to hold the Hamiltonian and metadata for a given set of parameters</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadeEmulation.hamiltonian","title":"hamiltonian  <code>property</code>","text":"<pre><code>hamiltonian: RydbergHamiltonian\n</code></pre> <p>Return the Hamiltonian object for the given task data.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadeEmulation.metadata","title":"metadata  <code>property</code>","text":"<pre><code>metadata: NamedTuple\n</code></pre> <p>The metadata for the given task data.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadeEmulation.evolve","title":"evolve","text":"<pre><code>evolve(\n    state: Optional[StateVector] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-07,\n    rtol: float = 1e-14,\n    nsteps: int = 2147483647,\n    times: Sequence[float] = (),\n    interaction_picture: bool = False,\n) -&gt; Iterator[StateVector]\n</code></pre> <p>Evolve an initial state vector using the Hamiltonian</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>Optional[StateVector]</code> <p>The initial state vector to</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults</p> <code>1e-07</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in</p> <code>1e-14</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <code>times</code> <code>Sequence[float]</code> <p>The times to evaluate the state vector</p> <code>()</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <p>Returns:</p> Type Description <code>Iterator[StateVector]</code> <p>Iterator[StateVector]: An iterator of the state vectors at each time step.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/bloqade.py</code> <pre><code>def evolve(\n    self,\n    state: Optional[StateVector] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-7,\n    rtol: float = 1e-14,\n    nsteps: int = 2147483647,\n    times: Sequence[float] = (),\n    interaction_picture: bool = False,\n) -&gt; Iterator[StateVector]:\n    \"\"\"Evolve an initial state vector using the Hamiltonian\n\n    Args:\n        state (Optional[StateVector], optional): The initial state vector to\n        evolve. if not provided, the zero state will be used. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults\n        to 1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in\n        ODE solver. Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2147483647.\n        times (Sequence[float], optional): The times to evaluate the state vector\n        at. Defaults to (). If not provided the state will be evaluated at\n        the end of the bloqade program.\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n\n    Returns:\n        Iterator[StateVector]: An iterator of the state vectors at each time step.\n\n    \"\"\"\n    state = self.zero_state(np.complex128) if state is None else state\n\n    U = AnalogGate(self.hamiltonian)\n\n    return U.apply(\n        state,\n        times=times,\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadeEmulation.fock_state","title":"fock_state","text":"<pre><code>fock_state(\n    fock_state_str: str, dtype: dtype = np.float64\n) -&gt; StateVector\n</code></pre> <p>Return the fock state for the given Hamiltonian.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/bloqade.py</code> <pre><code>def fock_state(\n    self, fock_state_str: str, dtype: np.dtype = np.float64\n) -&gt; StateVector:\n    \"\"\"Return the fock state for the given Hamiltonian.\"\"\"\n    index = self.hamiltonian.space.fock_state_to_index(fock_state_str)\n    data = np.zeros(self.hamiltonian.space.size, dtype=dtype)\n    data[index] = 1\n    return StateVector(data, self.hamiltonian.space)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadeEmulation.zero_state","title":"zero_state","text":"<pre><code>zero_state(dtype: dtype = np.float64) -&gt; StateVector\n</code></pre> <p>Return the zero state for the given Hamiltonian.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/bloqade.py</code> <pre><code>def zero_state(self, dtype: np.dtype = np.float64) -&gt; StateVector:\n    \"\"\"Return the zero state for the given Hamiltonian.\"\"\"\n    return self.hamiltonian.space.zero_state(dtype)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine","title":"BloqadePythonRoutine","text":"<p>               Bases: <code>RoutineBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine[BloqadePythonRoutine]\n              bloqade.analog.ir.routine.base.RoutineBase[RoutineBase]\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.routine.base.RoutineBase --&gt; bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine\n                                bloqade.analog.ir.routine.base.RoutineParse --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n                bloqade.analog.ir.routine.base.RoutineShow --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n\n\n              click bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine href \"\" \"bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineBase href \"\" \"bloqade.analog.ir.routine.base.RoutineBase\"\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine.hamiltonian","title":"hamiltonian","text":"<pre><code>hamiltonian(\n    *args: LiteralType,\n    blockade_radius: float = 0.0,\n    use_hyperfine: bool = False,\n    waveform_runtime: str = \"interpret\",\n    cache_matrices: bool = False\n) -&gt; List[BloqadeEmulation]\n</code></pre> <p>Generates a list of BloqadeEmulation objects which contain the Hamiltonian of your program.</p> <p>If you have a variable(s) in your program you have assigned multiple values via <code>batch_assign()</code> there will be multiple <code>BloqadeEmulation</code> objects, one for each value. On the other hand if the program only assumes a singular value per each variable, there will only be one <code>BloqadeEmulation</code> object but it will still be encapsulated in a list.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>LiteralType</code> <p>If your program has a variable that was declared as run-time assignable via <code>.args</code> you may pass a value to it here. If there are multiple variables declared via <code>.args</code> the order in which you assign values to those variables through this argument should follow the order in which the declaration occurred.</p> <code>()</code> <code>blockade_radius</code> <code>float</code> <p>The radius in which atoms blockade eachother. Default value is 0.0 micrometers.</p> <code>0.0</code> <code>use_hyperfine</code> <code>bool</code> <p>Should the Hamiltonian account for hyperfine levels. Default value is False.</p> <code>False</code> <code>waveform_runtime</code> <code>str</code> <p>Specify which runtime to use for waveforms. If \"numba\" is specify the waveform is compiled, otherwise it is interpreted via the \"interpret\" argument. Defaults to \"interpret\".</p> <code>'interpret'</code> <code>cache_matrices</code> <code>bool</code> <p>Speed up Hamiltonian generation by reusing data (when possible) from previously generated Hamiltonians. Default value is False.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[BloqadeEmulation]</code> <p>List[BloqadeEmulation]</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/bloqade.py</code> <pre><code>def hamiltonian(\n    self,\n    *args: LiteralType,\n    blockade_radius: float = 0.0,\n    use_hyperfine: bool = False,\n    waveform_runtime: str = \"interpret\",\n    cache_matrices: bool = False,\n) -&gt; List[BloqadeEmulation]:\n    \"\"\"\n    Generates a list of BloqadeEmulation objects which contain the Hamiltonian of your program.\n\n    If you have a variable(s) in your program you have assigned multiple values via `batch_assign()`\n    there will be multiple `BloqadeEmulation` objects, one for each value. On the other hand\n    if the program only assumes a singular value per each variable, there will only be\n    one `BloqadeEmulation` object but it will still be encapsulated in a list.\n\n\n    Args:\n        *args (LiteralType): If your program has a variable that was declared as run-time assignable\n            via `.args` you may pass a value to it here. If there are multiple\n            variables declared via `.args` the order in which you assign values to those variables\n            through this argument should follow the order in which the declaration occurred.\n        blockade_radius (float): The radius in which atoms blockade eachother. Default value is 0.0 micrometers.\n        use_hyperfine (bool): Should the Hamiltonian account for hyperfine levels. Default value is False.\n        waveform_runtime (str): Specify which runtime to use for waveforms. If \"numba\" is specify the waveform\n            is compiled, otherwise it is interpreted via the \"interpret\" argument. Defaults to \"interpret\".\n        cache_matrices (bool): Speed up Hamiltonian generation by reusing data (when possible) from previously generated Hamiltonians.\n            Default value is False.\n\n    Returns:\n        List[BloqadeEmulation]\n\n    \"\"\"\n    ir_iter = self._generate_ir(\n        args, blockade_radius, waveform_runtime, use_hyperfine\n    )\n\n    if cache_matrices:\n        compile_cache = CompileCache()\n    else:\n        compile_cache = None\n\n    return [\n        BloqadeEmulation(task_data, compile_cache=compile_cache)\n        for task_data in ir_iter\n    ]\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine.run","title":"run","text":"<pre><code>run(\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    blockade_radius: float = 0.0,\n    waveform_runtime: str = \"interpret\",\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-07,\n    rtol: float = 1e-14,\n    nsteps: int = 2147483647,\n) -&gt; LocalBatch\n</code></pre> <p>Run the current program using bloqade python backend</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots after running state vector simulation</p> required <code>args</code> <code>Tuple[LiteralType, ...]</code> <p>The values for parameters defined</p> <code>()</code> <code>name</code> <code>Optional[str]</code> <p>Name to give this run. Defaults to None.</p> <code>None</code> <code>blockade_radius</code> <code>float</code> <p>Use the Blockade subspace given a</p> <code>0.0</code> <code>waveform_runtime</code> <code>str</code> <p>(bool, optional): Use Numba to compile the waveforms,</p> <code>'interpret'</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <code>cache_matrices</code> <code>bool</code> <p>Reuse previously evaluated matrcies when</p> <code>False</code> <code>multiprocessing</code> <code>bool</code> <p>Use multiple processes to process the</p> <code>False</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of processes to run with</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults to</p> <code>1e-07</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in ODE solver.</p> <code>1e-14</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>Cannot use multiprocessing and cache_matrices at the same time.</p> <p>Returns:</p> Name Type Description <code>LocalBatch</code> <code>LocalBatch</code> <p>Batch of local tasks that have been executed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/bloqade.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    blockade_radius: float = 0.0,\n    waveform_runtime: str = \"interpret\",\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-7,\n    rtol: float = 1e-14,\n    nsteps: int = 2_147_483_647,\n) -&gt; LocalBatch:\n    \"\"\"Run the current program using bloqade python backend\n\n    Args:\n        shots (int): number of shots after running state vector simulation\n        args (Tuple[LiteralType, ...], optional): The values for parameters defined\n        in `args`. Defaults to ().\n        name (Optional[str], optional): Name to give this run. Defaults to None.\n        blockade_radius (float, optional): Use the Blockade subspace given a\n        particular radius. Defaults to 0.0.\n        waveform_runtime: (bool, optional): Use Numba to compile the waveforms,\n        Defaults to False.\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n        cache_matrices (bool, optional): Reuse previously evaluated matrcies when\n        possible. Defaults to False.\n        multiprocessing (bool, optional): Use multiple processes to process the\n        batches. Defaults to False.\n        num_workers (Optional[int], optional): Number of processes to run with\n        multiprocessing. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults to\n        1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in ODE solver.\n        Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2_147_483_647, the maximum value.\n\n    Raises:\n        ValueError: Cannot use multiprocessing and cache_matrices at the same time.\n\n    Returns:\n        LocalBatch: Batch of local tasks that have been executed.\n    \"\"\"\n    if multiprocessing and cache_matrices:\n        raise ValueError(\n            \"Cannot use multiprocessing and cache_matrices at the same time.\"\n        )\n\n    compile_options = dict(\n        shots=shots,\n        args=args,\n        name=name,\n        blockade_radius=blockade_radius,\n        cache_matrices=cache_matrices,\n        waveform_runtime=waveform_runtime,\n    )\n\n    solver_options = dict(\n        multiprocessing=multiprocessing,\n        num_workers=num_workers,\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    batch = self._compile(**compile_options)\n    batch._run(**solver_options)\n\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.BloqadePythonRoutine.run_callback","title":"run_callback","text":"<pre><code>run_callback(\n    callback: Callable[\n        [StateVector, NamedTuple, RydbergHamiltonian, Any],\n        Any,\n    ],\n    program_args: Tuple[LiteralType, ...] = (),\n    callback_args: Tuple = (),\n    ignore_exceptions: bool = False,\n    blockade_radius: float = 0.0,\n    waveform_runtime: str = \"interpret\",\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-07,\n    rtol: float = 1e-14,\n    nsteps: int = 2147483647,\n    use_hyperfine: bool = False,\n) -&gt; List\n</code></pre> <p>Run state-vector simulation with a callback to access full state-vector from emulator</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[StateVector, Metadata, RydbergHamiltonian, Any], Any]</code> required <code>program_args</code> <code>Tuple[LiteralType, ...]</code> <p>The values for parameters</p> <code>()</code> <code>callback_args</code> <code>Tuple[Any, ...]</code> <p>Extra arguments to pass into</p> <code>()</code> <code>ignore_exceptions</code> <code>bool</code> <p>(bool, optional) If <code>True</code> any exception raised during</p> <code>False</code> <code>blockade_radius</code> <code>float</code> <p>Use the Blockade subspace given a</p> <code>0.0</code> <code>waveform_runtime</code> <code>str</code> <p>(str, optional): Specify which runtime to use for</p> <code>'interpret'</code> <code>interaction_picture</code> <code>bool</code> <p>Use the interaction picture when</p> <code>False</code> <code>cache_matrices</code> <code>bool</code> <p>Reuse previously evaluated matrcies when</p> <code>False</code> <code>multiprocessing</code> <code>bool</code> <p>Use multiple processes to process the</p> <code>False</code> <code>num_workers</code> <code>Optional[int]</code> <p>Number of processes to run with</p> <code>None</code> <code>solver_name</code> <code>str</code> <p>Which SciPy Solver to use. Defaults to</p> <code>'dop853'</code> <code>atol</code> <code>float</code> <p>Absolute tolerance for ODE solver. Defaults to</p> <code>1e-07</code> <code>rtol</code> <code>float</code> <p>Relative tolerance for adaptive step in ODE solver.</p> <code>1e-14</code> <code>nsteps</code> <code>int</code> <p>Maximum number of steps allowed per integration</p> <code>2147483647</code> <p>Returns:</p> Name Type Description <code>List</code> <code>List</code> <p>List of resulting outputs from the callbacks</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>Raises the first error that occurs, only if</p> Note <p>For the <code>callback</code> function, first argument is the many-body wavefunction as a 1D complex numpy array, the second argument is of type <code>Metadata</code> which is a Named Tuple where the fields correspond to the parameters of that given task, RydbergHamiltonian is the object that contains the Hamiltonian used to generate the evolution for that task, Finally any optional positional arguments are allowed after that. The return value can be anything, the results will be collected in a list for each task in the batch.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/bloqade.py</code> <pre><code>@beartype\ndef run_callback(\n    self,\n    callback: Callable[[StateVector, NamedTuple, RydbergHamiltonian, Any], Any],\n    program_args: Tuple[LiteralType, ...] = (),\n    callback_args: Tuple = (),\n    ignore_exceptions: bool = False,\n    blockade_radius: float = 0.0,\n    waveform_runtime: str = \"interpret\",\n    interaction_picture: bool = False,\n    cache_matrices: bool = False,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    solver_name: str = \"dop853\",\n    atol: float = 1e-7,\n    rtol: float = 1e-14,\n    nsteps: int = 2_147_483_647,\n    use_hyperfine: bool = False,\n) -&gt; List:\n    \"\"\"Run state-vector simulation with a callback to access full state-vector from\n    emulator\n\n    Args:\n        callback (Callable[[StateVector, Metadata, RydbergHamiltonian, Any], Any]):\n        The callback function to run for each task in batch. See note below for more\n        details about the signature of the function.\n        program_args (Tuple[LiteralType, ...], optional): The values for parameters\n        defined in `args`. Defaults to ().\n        callback_args (Tuple[Any,...], optional): Extra arguments to pass into\n        ignore_exceptions: (bool, optional) If `True` any exception raised during\n        a task will be saved instead of the resulting output of the callback,\n        otherwise the first exception by task number will be raised after *all*\n        tasks have executed. Defaults to False.\n        blockade_radius (float, optional): Use the Blockade subspace given a\n        particular radius. Defaults to 0.0.\n        waveform_runtime: (str, optional): Specify which runtime to use for\n        waveforms. Defaults to \"interpret\".\n        interaction_picture (bool, optional): Use the interaction picture when\n        solving schrodinger equation. Defaults to False.\n        cache_matrices (bool, optional): Reuse previously evaluated matrcies when\n        possible. Defaults to False.\n        multiprocessing (bool, optional): Use multiple processes to process the\n        batches. Defaults to False.\n        num_workers (Optional[int], optional): Number of processes to run with\n        multiprocessing. Defaults to None.\n        solver_name (str, optional): Which SciPy Solver to use. Defaults to\n        \"dop853\".\n        atol (float, optional): Absolute tolerance for ODE solver. Defaults to\n        1e-14.\n        rtol (float, optional): Relative tolerance for adaptive step in ODE solver.\n        Defaults to 1e-7.\n        nsteps (int, optional): Maximum number of steps allowed per integration\n        step. Defaults to 2_147_483_647, the maximum value.\n\n    Returns:\n        List: List of resulting outputs from the callbacks\n\n    Raises:\n        RuntimeError: Raises the first error that occurs, only if\n        `ignore_exceptions=False`.\n\n    Note:\n        For the `callback` function, first argument is the many-body wavefunction\n        as a 1D complex numpy array, the second argument is of type `Metadata` which\n        is a Named Tuple where the fields correspond to the parameters of that given\n        task, RydbergHamiltonian is the object that contains the Hamiltonian used to\n        generate the evolution for that task, Finally any optional positional\n        arguments are allowed after that. The return value can be anything, the\n        results will be collected in a list for each task in the batch.\n\n\n    \"\"\"\n    if multiprocessing:\n        from multiprocessing import Queue, Process, cpu_count\n    else:\n        from queue import Queue\n\n    if cache_matrices:\n        compile_cache = CompileCache()\n    else:\n        compile_cache = None\n\n    solver_args = dict(\n        solver_name=solver_name,\n        atol=atol,\n        rtol=rtol,\n        nsteps=nsteps,\n        interaction_picture=interaction_picture,\n    )\n\n    runner = self.EmuRunner(\n        compile_cache=compile_cache,\n        solver_args=solver_args,\n        callback=callback,\n        callback_args=callback_args,\n    )\n\n    tasks = Queue()\n    results = Queue()\n\n    total_tasks = 0\n    ir_iter = self._generate_ir(\n        program_args, blockade_radius, waveform_runtime, use_hyperfine\n    )\n    for task_data in ir_iter:\n        task_number = task_data.task_id\n        emulator_ir = task_data.emulator_ir\n        metadata = task_data.metadata_dict\n        total_tasks += 1\n        tasks.put((task_number, (emulator_ir, metadata)))\n\n    workers = []\n    if multiprocessing:\n        num_workers = max(int(num_workers or cpu_count()), 1)\n        num_workers = min(total_tasks, num_workers)\n\n        for _ in range(num_workers):\n            worker = Process(\n                target=BloqadePythonRoutine.process_tasks,\n                args=(runner, tasks, results),\n            )\n            worker.start()\n\n            workers.append(worker)\n    else:\n        self.process_tasks(runner, tasks, results)\n\n    # blocks until all\n    # results have been fetched\n    # from the id_results Queue\n    id_results = []\n    for i in range(total_tasks):\n        id_results.append(results.get())\n\n    if workers:\n        for worker in workers:\n            worker.join()\n\n        tasks.close()\n        results.close()\n\n    id_results.sort(key=lambda x: x[0])\n    results = []\n\n    for task_id, result in id_results:\n        if not ignore_exceptions and isinstance(result, BaseException):\n            try:\n                raise result\n            except BaseException:\n                raise RuntimeError(\n                    f\"{result.__class__.__name__} occured during child process \"\n                    f\"running for task number {task_id}:\\n{traceback.format_exc()}\"\n                )\n\n        results.append(result)\n\n    return results\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/bloqade/#bloqade.analog.ir.routine.bloqade.TaskData","title":"TaskData  <code>dataclass</code>","text":"<pre><code>TaskData(\n    task_id: int,\n    emulator_ir: EmulatorProgram,\n    metadata_dict: Dict[str, LiteralType],\n)\n</code></pre> <p>Data class to hold the program ir and metadata for a given set of parameters</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/","title":"Braket","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketHardwareRoutine","title":"BraketHardwareRoutine","text":"<p>               Bases: <code>RoutineBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.braket.BraketHardwareRoutine[BraketHardwareRoutine]\n              bloqade.analog.ir.routine.base.RoutineBase[RoutineBase]\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.routine.base.RoutineBase --&gt; bloqade.analog.ir.routine.braket.BraketHardwareRoutine\n                                bloqade.analog.ir.routine.base.RoutineParse --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n                bloqade.analog.ir.routine.base.RoutineShow --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n\n\n              click bloqade.analog.ir.routine.braket.BraketHardwareRoutine href \"\" \"bloqade.analog.ir.routine.braket.BraketHardwareRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineBase href \"\" \"bloqade.analog.ir.routine.base.RoutineBase\"\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketHardwareRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs\n)\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for args variables.</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\n    self,\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs,\n):\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    return self.run(shots, args, name, use_experimental, shuffle, **kwargs)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketHardwareRoutine.run","title":"run","text":"<pre><code>run(\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs\n) -&gt; RemoteBatch\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, run_async to Braket, and wait until the results are coming back.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, run_async to Braket,\n    and wait until the results are coming back.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n\n    batch = self.run_async(shots, args, name, use_experimental, shuffle, **kwargs)\n    batch.pull()\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs\n) -&gt; RemoteBatch\n</code></pre> <p>Compile to a RemoteBatch, which contain Braket backend specific tasks, and run_async to Braket.</p> Note <p>This is async.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>Values of the parameter defined in <code>args</code>, defaults to ()</p> <code>()</code> <code>name</code> <code>str | None</code> <p>custom name of the batch, defaults to None</p> <code>None</code> <code>use_experimental</code> <code>bool</code> <p>Use experimental hardware capabilities</p> <code>False</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/braket.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n    Braket backend specific tasks, and run_async to Braket.\n\n    Note:\n        This is async.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): Values of the parameter defined in `args`, defaults to ()\n        name (str | None): custom name of the batch, defaults to None\n        use_experimental (bool): Use experimental hardware capabilities\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n\n    batch = self._compile(shots, use_experimental, args, name)\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine","title":"BraketLocalEmulatorRoutine","text":"<p>               Bases: <code>RoutineBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine[BraketLocalEmulatorRoutine]\n              bloqade.analog.ir.routine.base.RoutineBase[RoutineBase]\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.routine.base.RoutineBase --&gt; bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine\n                                bloqade.analog.ir.routine.base.RoutineParse --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n                bloqade.analog.ir.routine.base.RoutineShow --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n\n\n              click bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine href \"\" \"bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineBase href \"\" \"bloqade.analog.ir.routine.base.RoutineBase\"\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine.__call__","title":"__call__","text":"<pre><code>__call__(\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs\n)\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> <code>1</code> <code>args</code> <code>LiteralType</code> <p>additional arguments for args variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/braket.py</code> <pre><code>@beartype\ndef __call__(\n    self,\n    *args: LiteralType,\n    shots: int = 1,\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs,\n):\n    \"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n\n    Return:\n        LocalBatch\n\n    \"\"\"\n    return self.run(\n        shots,\n        args,\n        name,\n        multiprocessing=multiprocessing,\n        num_workers=num_workers,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/braket/#bloqade.analog.ir.routine.braket.BraketLocalEmulatorRoutine.run","title":"run","text":"<pre><code>run(\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs\n) -&gt; LocalBatch\n</code></pre> <p>Compile to a LocalBatch, and run. The LocalBatch contain tasks to run on local emulator.</p> Note <p>This is sync, and will wait until remote results finished.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple[LiteralType, ...]</code> <p>additional arguments for args variables.</p> <code>()</code> <code>multiprocessing</code> <code>bool</code> <p>enable multi-process</p> <code>False</code> <code>num_workers</code> <code>int</code> <p>number of workers to run the emulator</p> <code>None</code> Return <p>LocalBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/braket.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs,\n) -&gt; LocalBatch:\n    \"\"\"\n    Compile to a LocalBatch, and run.\n    The LocalBatch contain tasks to run on local emulator.\n\n    Note:\n        This is sync, and will wait until remote results\n        finished.\n\n    Args:\n        shots (int): number of shots\n        args: additional arguments for args variables.\n        multiprocessing (bool): enable multi-process\n        num_workers (int): number of workers to run the emulator\n\n    Return:\n        LocalBatch\n\n    \"\"\"\n\n    batch = self._compile(shots, args, name)\n    batch._run(multiprocessing=multiprocessing, num_workers=num_workers, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/params/","title":"Params","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/","title":"Quera","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/#bloqade.analog.ir.routine.quera.CustomSubmissionRoutine","title":"CustomSubmissionRoutine","text":"<p>               Bases: <code>RoutineBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.quera.CustomSubmissionRoutine[CustomSubmissionRoutine]\n              bloqade.analog.ir.routine.base.RoutineBase[RoutineBase]\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.routine.base.RoutineBase --&gt; bloqade.analog.ir.routine.quera.CustomSubmissionRoutine\n                                bloqade.analog.ir.routine.base.RoutineParse --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n                bloqade.analog.ir.routine.base.RoutineShow --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n\n\n              click bloqade.analog.ir.routine.quera.CustomSubmissionRoutine href \"\" \"bloqade.analog.ir.routine.quera.CustomSubmissionRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineBase href \"\" \"bloqade.analog.ir.routine.base.RoutineBase\"\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/#bloqade.analog.ir.routine.quera.CustomSubmissionRoutine.run","title":"run","text":"<pre><code>run(\n    shots: int,\n    RemoteTask: type[RemoteTaskType],\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs\n) -&gt; RemoteBatch\n</code></pre> <p>Run the custom task and return the result.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>RemoteTask</code> <code>type</code> <p>type of the remote task, must subclass of CustomRemoteTaskABC</p> required <code>args</code> <code>Tuple</code> <p>additional arguments for remaining un</p> <code>()</code> <code>name</code> <code>str</code> <p>name of the batch object</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/quera.py</code> <pre><code>@beartype\ndef run(\n    self,\n    shots: int,\n    RemoteTask: type[RemoteTaskType],\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"Run the custom task and return the result.\n\n    Args:\n        shots (int): number of shots\n        RemoteTask (type): type of the remote task, must subclass of CustomRemoteTaskABC\n        args (Tuple): additional arguments for remaining un\n        name (str): name of the batch object\n        shuffle (bool): shuffle the order of jobs\n    \"\"\"\n    if not callable(getattr(RemoteTask, \"pull\", None)):\n        raise TypeError(\n            f\"{RemoteTask} must have a `pull` method for executing `run`.\"\n        )\n\n    batch = self.run_async(\n        shots, RemoteTask, args, name, use_experimental, shuffle, **kwargs\n    )\n    batch.pull()\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/#bloqade.analog.ir.routine.quera.CustomSubmissionRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots: int,\n    RemoteTask: type[RemoteTaskType],\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs\n) -&gt; RemoteBatch\n</code></pre> <p>Compile to a RemoteBatch, which contain     QuEra backend specific tasks,     and run_async through QuEra service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/quera.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    RemoteTask: type[RemoteTaskType],\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n        QuEra backend specific tasks,\n        and run_async through QuEra service.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    batch = self._compile_custom_batch(\n        shots, RemoteTask, use_experimental, args, name\n    )\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/#bloqade.analog.ir.routine.quera.CustomSubmissionRoutine.submit","title":"submit","text":"<pre><code>submit(\n    shots: int,\n    url: str,\n    json_body_template: str,\n    method: str = \"POST\",\n    args: Tuple[LiteralType] = (),\n    request_options: Dict[str, Any] = {},\n    use_experimental: bool = False,\n    sleep_time: float = 0.1,\n) -&gt; List[Tuple[NamedTuple, Response]]\n</code></pre> <p>Compile to QuEraTaskSpecification and submit to a custom service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>url</code> <code>str</code> <p>url of the custom service</p> required <code>json_body_template</code> <code>str</code> <p>json body template, must contain '{task_ir}'</p> required <code>method</code> <code>str</code> <p>http method to be used. Defaults to \"POST\".</p> <code>'POST'</code> <code>args</code> <code>Tuple[LiteralType]</code> <p>additional arguments to be passed into the</p> <code>()</code> <code>request_options</code> <code>Dict[str, Any]</code> <p>additional options to be passed into the request method,</p> <code>{}</code> <code>use_experimental</code> <code>bool</code> <p>Enable experimental hardware capabilities</p> <code>False</code> <code>sleep_time</code> <code>float</code> <p>time to sleep between each request. Defaults to 0.1.</p> <code>0.1</code> <p>Returns:</p> Type Description <code>List[Tuple[NamedTuple, Response]]</code> <p>List[Tuple[NamedTuple, Response]]: List of parameters for each batch in</p> <code>List[Tuple[NamedTuple, Response]]</code> <p>the task and the response from the post request.</p> <p>Examples:</p> <p>Here is a simple example of how to use this method. Note the body_template has double curly braces on the outside to escape the string formatting.</p> <pre><code>&gt;&gt;&gt; body_template = \"{{\"token\": \"my_token\", \"task\": {task_ir}}}\"\n&gt;&gt;&gt; responses = (\n    program.quera.custom.submit(\n        100,\n        \"http://my_custom_service.com\",\n        body_template\n    )\n)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/quera.py</code> <pre><code>def submit(\n    self,\n    shots: int,\n    url: str,\n    json_body_template: str,\n    method: str = \"POST\",\n    args: Tuple[LiteralType] = (),\n    request_options: Dict[str, Any] = {},\n    use_experimental: bool = False,\n    sleep_time: float = 0.1,\n) -&gt; List[Tuple[NamedTuple, Response]]:\n    \"\"\"Compile to QuEraTaskSpecification and submit to a custom service.\n\n    Args:\n        shots (int): number of shots\n        url (str): url of the custom service\n        json_body_template (str): json body template, must contain '{task_ir}'\n        which is a placeholder for a string representation of the task ir.\n        The task ir string will be inserted into the template with\n        `json_body_template.format(task_ir=task_ir_string)`.\n        to be replaced by QuEraTaskSpecification\n        method (str): http method to be used. Defaults to \"POST\".\n        args (Tuple[LiteralType]): additional arguments to be passed into the\n        compiler coming from `args` option of the build. Defaults to ().\n        request_options: additional options to be passed into the request method,\n        Note the `data` option will be overwritten by the\n        `json_body_template.format(task_ir=task_ir_string)`.\n        use_experimental (bool): Enable experimental hardware capabilities\n        sleep_time (float): time to sleep between each request. Defaults to 0.1.\n\n    Returns:\n        List[Tuple[NamedTuple, Response]]: List of parameters for each batch in\n        the task and the response from the post request.\n\n    Examples:\n        Here is a simple example of how to use this method. Note the body_template\n        has double curly braces on the outside to escape the string formatting.\n\n    ```python\n    &gt;&gt;&gt; body_template = \"{{\"token\": \"my_token\", \"task\": {task_ir}}}\"\n    &gt;&gt;&gt; responses = (\n        program.quera.custom.submit(\n            100,\n            \"http://my_custom_service.com\",\n            body_template\n        )\n    )\n    ```\n    \"\"\"\n\n    if r\"{task_ir}\" not in json_body_template:\n        raise ValueError(r\"body_template must contain '{task_ir}'\")\n\n    partial_eval = json_body_template.format(task_ir='\"task_ir\"')\n    try:\n        _ = json.loads(partial_eval)\n    except json.JSONDecodeError as e:\n        raise ValueError(\n            \"body_template must be a valid json template. \"\n            'When evaluating template with task_ir=\"task_ir\", '\n            f\"the template evaluated to: {partial_eval!r}.\\n\"\n            f\"JSONDecodeError: {e}\"\n        )\n\n    out = []\n    for metadata, task_ir in self._compile_single(shots, use_experimental, args):\n        json_request_body = json_body_template.format(\n            task_ir=task_ir.json(exclude_none=True, exclude_unset=True)\n        )\n        request_options.update(data=json_request_body)\n        response = request(method, url, **request_options)\n        out.append((metadata, response))\n        time.sleep(sleep_time)\n\n    return out\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/#bloqade.analog.ir.routine.quera.QuEraHardwareRoutine","title":"QuEraHardwareRoutine","text":"<p>               Bases: <code>RoutineBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.ir.routine.quera.QuEraHardwareRoutine[QuEraHardwareRoutine]\n              bloqade.analog.ir.routine.base.RoutineBase[RoutineBase]\n              bloqade.analog.ir.routine.base.RoutineParse[RoutineParse]\n              bloqade.analog.builder.parse.trait.Parse[Parse]\n              bloqade.analog.builder.parse.trait.ParseRegister[ParseRegister]\n              bloqade.analog.builder.parse.trait.ParseSequence[ParseSequence]\n              bloqade.analog.builder.parse.trait.ParseCircuit[ParseCircuit]\n              bloqade.analog.builder.parse.trait.ParseRoutine[ParseRoutine]\n              bloqade.analog.ir.routine.base.RoutineShow[RoutineShow]\n              bloqade.analog.builder.parse.trait.Show[Show]\n\n                              bloqade.analog.ir.routine.base.RoutineBase --&gt; bloqade.analog.ir.routine.quera.QuEraHardwareRoutine\n                                bloqade.analog.ir.routine.base.RoutineParse --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Parse --&gt; bloqade.analog.ir.routine.base.RoutineParse\n                                bloqade.analog.builder.parse.trait.ParseRegister --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseSequence --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseCircuit --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n                bloqade.analog.builder.parse.trait.ParseRoutine --&gt; bloqade.analog.builder.parse.trait.Parse\n                \n\n\n                bloqade.analog.ir.routine.base.RoutineShow --&gt; bloqade.analog.ir.routine.base.RoutineBase\n                                bloqade.analog.builder.parse.trait.Show --&gt; bloqade.analog.ir.routine.base.RoutineShow\n                \n\n\n\n\n              click bloqade.analog.ir.routine.quera.QuEraHardwareRoutine href \"\" \"bloqade.analog.ir.routine.quera.QuEraHardwareRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineBase href \"\" \"bloqade.analog.ir.routine.base.RoutineBase\"\n              click bloqade.analog.ir.routine.base.RoutineParse href \"\" \"bloqade.analog.ir.routine.base.RoutineParse\"\n              click bloqade.analog.builder.parse.trait.Parse href \"\" \"bloqade.analog.builder.parse.trait.Parse\"\n              click bloqade.analog.builder.parse.trait.ParseRegister href \"\" \"bloqade.analog.builder.parse.trait.ParseRegister\"\n              click bloqade.analog.builder.parse.trait.ParseSequence href \"\" \"bloqade.analog.builder.parse.trait.ParseSequence\"\n              click bloqade.analog.builder.parse.trait.ParseCircuit href \"\" \"bloqade.analog.builder.parse.trait.ParseCircuit\"\n              click bloqade.analog.builder.parse.trait.ParseRoutine href \"\" \"bloqade.analog.builder.parse.trait.ParseRoutine\"\n              click bloqade.analog.ir.routine.base.RoutineShow href \"\" \"bloqade.analog.ir.routine.base.RoutineShow\"\n              click bloqade.analog.builder.parse.trait.Show href \"\" \"bloqade.analog.builder.parse.trait.Show\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/ir/routine/quera/#bloqade.analog.ir.routine.quera.QuEraHardwareRoutine.run_async","title":"run_async","text":"<pre><code>run_async(\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs\n) -&gt; RemoteBatch\n</code></pre> <p>Compile to a RemoteBatch, which contain     QuEra backend specific tasks,     and run_async through QuEra service.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>number of shots</p> required <code>args</code> <code>Tuple</code> <p>additional arguments</p> <code>()</code> <code>name</code> <code>str</code> <p>custom name of the batch</p> <code>None</code> <code>shuffle</code> <code>bool</code> <p>shuffle the order of jobs</p> <code>False</code> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/ir/routine/quera.py</code> <pre><code>@beartype\ndef run_async(\n    self,\n    shots: int,\n    args: Tuple[LiteralType, ...] = (),\n    name: Optional[str] = None,\n    use_experimental: bool = False,\n    shuffle: bool = False,\n    **kwargs,\n) -&gt; RemoteBatch:\n    \"\"\"\n    Compile to a RemoteBatch, which contain\n        QuEra backend specific tasks,\n        and run_async through QuEra service.\n\n    Args:\n        shots (int): number of shots\n        args (Tuple): additional arguments\n        name (str): custom name of the batch\n        shuffle (bool): shuffle the order of jobs\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    batch = self._compile(shots, use_experimental, args, name)\n    batch._submit(shuffle, **kwargs)\n    return batch\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/base/","title":"Base","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/braket/","title":"Braket","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/load_config/","title":"Load config","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/mock/","title":"Mock","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/quera/","title":"Quera","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/","title":"Braket","text":"<p>Helper functions related to IR submission co-ordinations between Bloqade and Braket</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.BraketTaskSpecification","title":"BraketTaskSpecification","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.submission.ir.braket.BraketTaskSpecification[BraketTaskSpecification]\n\n              \n\n              click bloqade.analog.submission.ir.braket.BraketTaskSpecification href \"\" \"bloqade.analog.submission.ir.braket.BraketTaskSpecification\"\n            </code></pre> <p>Class representing geometry of an atom arrangement.</p> <p>Attributes:</p> Name Type Description <code>nshots</code> <code>int</code> <p>Number of shots</p> <code>program</code> <code>Program</code> <p>IR(Intermediate Representation) program suitable for braket</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.extract_braket_program","title":"extract_braket_program","text":"<pre><code>extract_braket_program(\n    quera_task_ir: QuEraTaskSpecification,\n)\n</code></pre> <p>Extracts the Braket program.</p> <p>Parameters:</p> Name Type Description Default <code>quera_task_ir</code> <code>QuEraTaskSpecification</code> <p>Quera IR(Intermediate representation) of the task.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def extract_braket_program(quera_task_ir: QuEraTaskSpecification):\n    \"\"\"Extracts the Braket program.\n\n    Args:\n        quera_task_ir (QuEraTaskSpecification):\n            Quera IR(Intermediate representation) of the task.\n    \"\"\"\n    lattice = quera_task_ir.lattice\n\n    rabi_amplitude = (\n        quera_task_ir.effective_hamiltonian.rydberg.rabi_frequency_amplitude.global_\n    )\n    rabi_phase = (\n        quera_task_ir.effective_hamiltonian.rydberg.rabi_frequency_phase.global_\n    )\n    global_detuning = quera_task_ir.effective_hamiltonian.rydberg.detuning.global_\n    local_detuning = quera_task_ir.effective_hamiltonian.rydberg.detuning.local\n\n    register = AtomArrangement()\n    for site, filled in zip(lattice.sites, lattice.filling):\n        site_type = SiteType.FILLED if filled == 1 else SiteType.VACANT\n        register.add(site, site_type)\n\n    hamiltonian = DrivingField(\n        amplitude=to_braket_field(rabi_amplitude),\n        phase=to_braket_field(rabi_phase),\n        detuning=to_braket_field(global_detuning),\n    )\n\n    if local_detuning:\n        hamiltonian = hamiltonian + ShiftingField(to_braket_field(local_detuning))\n\n    return AnalogHamiltonianSimulation(\n        register=register,\n        hamiltonian=hamiltonian,\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.from_braket_status_codes","title":"from_braket_status_codes","text":"<pre><code>from_braket_status_codes(\n    braket_status: str,\n) -&gt; QuEraTaskStatusCode\n</code></pre> <p>Gets the <code>QuEraTaskStatusCode</code> object for working with Bloqade SDK.</p> <p>Parameters:</p> Name Type Description Default <code>braket_status</code> <code>str</code> <p>str The value of status in metadata() in the Amazon Braket. <code>GetQuantumTask</code> operation. If <code>use_cached_value</code> is <code>True</code>, the value most recently returned from <code>GetQuantumTask</code> operation is used</p> required <p>Returns:</p> Type Description <code>QuEraTaskStatusCode</code> <p>An object of the type <code>Field</code> in Braket SDK</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def from_braket_status_codes(braket_status: str) -&gt; QuEraTaskStatusCode:\n    \"\"\"Gets the `QuEraTaskStatusCode` object for working with Bloqade SDK.\n\n    Args:\n        braket_status: str\n            The value of status in metadata() in the Amazon Braket.\n            `GetQuantumTask` operation. If `use_cached_value` is `True`,\n            the value most recently returned from\n            `GetQuantumTask` operation is used\n\n    Returns:\n        An object of the type `Field` in Braket SDK\n    \"\"\"\n    if braket_status == str(\"QUEUED\"):\n        return QuEraTaskStatusCode.Enqueued\n    else:\n        return QuEraTaskStatusCode(braket_status.lower().capitalize())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.from_braket_task_results","title":"from_braket_task_results","text":"<pre><code>from_braket_task_results(\n    braket_task_results: AnalogHamiltonianSimulationTaskResult,\n) -&gt; QuEraTaskResults\n</code></pre> <p>Get the <code>QuEraTaskResults</code> object for working with Bloqade SDK.</p> <p>Parameters:</p> Name Type Description Default <code>braket_task_results</code> <code>AnalogHamiltonianSimulationTaskResult</code> <p>AnalogHamiltonianSimulationTaskResult Quantum task result of braket system</p> required <p>Returns:</p> Type Description <code>QuEraTaskResults</code> <p>An object of the type <code>Field</code> in Braket SDK.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def from_braket_task_results(\n    braket_task_results: AnalogHamiltonianSimulationTaskResult,\n) -&gt; QuEraTaskResults:\n    \"\"\"Get the `QuEraTaskResults` object for working with Bloqade SDK.\n\n    Args:\n        braket_task_results: AnalogHamiltonianSimulationTaskResult\n            Quantum task result of braket system\n\n    Returns:\n        An object of the type `Field` in Braket SDK.\n    \"\"\"\n    shot_outputs = []\n    for measurement in braket_task_results.measurements:\n        shot_outputs.append(\n            QuEraShotResult(\n                shot_status=QuEraShotStatusCode.Completed,\n                pre_sequence=list(measurement.pre_sequence),\n                post_sequence=list(measurement.post_sequence),\n            )\n        )\n\n    return QuEraTaskResults(\n        task_status=QuEraTaskStatusCode.Completed, shot_outputs=shot_outputs\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.to_braket_field","title":"to_braket_field","text":"<pre><code>to_braket_field(\n    quera_field: Union[GlobalField, LocalField],\n) -&gt; Field\n</code></pre> <p>Converts to <code>TimeSeries</code> object supported by Braket.</p> <p>Parameters:</p> Name Type Description Default <code>quera_field (Union[GlobalField, LocalField)]</code> <p>Field supported by Quera</p> required <p>Returns:</p> Type Description <code>Field</code> <p>An object of the type <code>braket.ahs.field.Field</code></p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If field is not of the type <code>GlobalField</code> or <code>LocalField</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def to_braket_field(quera_field: Union[GlobalField, LocalField]) -&gt; Field:\n    \"\"\"Converts to `TimeSeries` object supported by Braket.\n\n    Args:\n        quera_field (Union[GlobalField, LocalField)]:\n            Field supported by Quera\n\n    Returns:\n        An object of the type `braket.ahs.field.Field`\n\n    Raises:\n        TypeError: If field is not of the type `GlobalField` or `LocalField`.\n    \"\"\"\n    if isinstance(quera_field, GlobalField):\n        times = quera_field.times\n        values = quera_field.values\n        time_series = to_braket_time_series(times, values)\n        return Field(pattern=\"uniform\", time_series=time_series)\n    elif isinstance(quera_field, LocalField):\n        times = quera_field.times\n        values = quera_field.values\n        pattern = quera_field.lattice_site_coefficients\n        time_series = to_braket_time_series(times, values)\n        pattern = Pattern(pattern)\n        return Field(pattern=pattern, time_series=time_series)\n    else:\n        raise TypeError\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.to_braket_task","title":"to_braket_task","text":"<pre><code>to_braket_task(\n    quera_task_ir: QuEraTaskSpecification,\n) -&gt; Tuple[int, AnalogHamiltonianSimulation]\n</code></pre> <p>Converts to <code>Tuple[int, AnalogHamiltonianSimulation]</code> object supported by Braket.</p> <p>Parameters:</p> Name Type Description Default <code>quera_task_ir</code> <code>QuEraTaskSpecification</code> <p>Quera IR(Intermediate representation) of the task.</p> required <p>Returns:</p> Type Description <code>Tuple[int, AnalogHamiltonianSimulation]</code> <p>An tuple  of the type <code>Tuple[int, AnalogHamiltonianSimulation]</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def to_braket_task(\n    quera_task_ir: QuEraTaskSpecification,\n) -&gt; Tuple[int, AnalogHamiltonianSimulation]:\n    \"\"\"Converts to `Tuple[int, AnalogHamiltonianSimulation]` object supported by Braket.\n\n    Args:\n        quera_task_ir (QuEraTaskSpecification):\n            Quera IR(Intermediate representation) of the task.\n\n    Returns:\n        An tuple  of the type `Tuple[int, AnalogHamiltonianSimulation]`.\n    \"\"\"\n    braket_ahs_program = extract_braket_program(quera_task_ir)\n    return quera_task_ir.nshots, braket_ahs_program\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.to_braket_task_ir","title":"to_braket_task_ir","text":"<pre><code>to_braket_task_ir(\n    quera_task_ir: QuEraTaskSpecification,\n) -&gt; BraketTaskSpecification\n</code></pre> <p>Converts quera IR(Intermendiate Representation) to to <code>BraketTaskSpecification</code> object.</p> <p>Parameters:</p> Name Type Description Default <code>quera_task_ir</code> <code>QuEraTaskSpecification</code> <p>Quera IR(Intermediate representation) of the task.</p> required <p>Returns:</p> Type Description <code>BraketTaskSpecification</code> <p>An object of the type <code>BraketTaskSpecification</code> in Braket SDK</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def to_braket_task_ir(quera_task_ir: QuEraTaskSpecification) -&gt; BraketTaskSpecification:\n    \"\"\"Converts quera IR(Intermendiate Representation) to\n    to `BraketTaskSpecification` object.\n\n    Args:\n        quera_task_ir (QuEraTaskSpecification):\n            Quera IR(Intermediate representation) of the task.\n\n    Returns:\n        An object of the type `BraketTaskSpecification` in Braket SDK\n\n    \"\"\"\n    nshots, braket_ahs_program = to_braket_task(quera_task_ir)\n    return BraketTaskSpecification(nshots=nshots, program=braket_ahs_program.to_ir())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.to_braket_time_series","title":"to_braket_time_series","text":"<pre><code>to_braket_time_series(\n    times: List[Decimal], values: List[Decimal]\n) -&gt; TimeSeries\n</code></pre> <p>Converts to <code>TimeSeries</code> object supported by Braket.</p> <p>Parameters:</p> Name Type Description Default <code>times</code> <code>List[Decimal]</code> <p>Times of the value.</p> required <code>values</code> <code>List[Decimal]</code> <p>Corresponding values to add to the time series</p> required <p>Returns:</p> Type Description <code>TimeSeries</code> <p>An object of the type <code>braket.timings.TimeSeries</code></p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def to_braket_time_series(times: List[Decimal], values: List[Decimal]) -&gt; TimeSeries:\n    \"\"\"Converts to `TimeSeries` object supported by Braket.\n\n    Args:\n        times (List[Decimal]): Times of the value.\n        values (List[Decimal]): Corresponding values to add to the time series\n\n    Returns:\n        An object of the type `braket.timings.TimeSeries`\n    \"\"\"\n    time_series = TimeSeries()\n    for time, value in zip(times, values):\n        time_series.put(time, value)\n\n    return time_series\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/braket/#bloqade.analog.submission.ir.braket.to_quera_capabilities","title":"to_quera_capabilities","text":"<pre><code>to_quera_capabilities(paradigm) -&gt; cp.QuEraCapabilities\n</code></pre> <p>Converts to <code>QuEraCapabilities</code> object supported by Braket.</p> <p>Parameters:</p> Name Type Description Default <code>paradigm</code> <p>The <code>paradigm</code> property of the <code>AwsDevice</code> object for Aquila</p> required <p>Returns:</p> Type Description <code>QuEraCapabilities</code> <p>An object of the type <code>QuEraCapabilities</code> in Bloqade SDK.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/braket.py</code> <pre><code>def to_quera_capabilities(paradigm) -&gt; cp.QuEraCapabilities:\n    \"\"\"Converts to `QuEraCapabilities` object supported by Braket.\n\n    Args:\n        paradigm: The `paradigm` property of the `AwsDevice` object for Aquila\n\n    Returns:\n        An object of the type `QuEraCapabilities` in Bloqade SDK.\n    \"\"\"\n    rydberg_global = paradigm.rydberg.rydbergGlobal\n\n    return cp.QuEraCapabilities(\n        version=paradigm.braketSchemaHeader.version,\n        capabilities=cp.DeviceCapabilities(\n            task=cp.TaskCapabilities(\n                number_shots_min=1,\n                number_shots_max=1000,\n            ),\n            lattice=cp.LatticeCapabilities(\n                number_qubits_max=paradigm.qubitCount,\n                geometry=cp.LatticeGeometryCapabilities(\n                    spacing_radial_min=paradigm.lattice.geometry.spacingRadialMin,\n                    spacing_vertical_min=paradigm.lattice.geometry.spacingVerticalMin,\n                    position_resolution=paradigm.lattice.geometry.positionResolution,\n                    number_sites_max=paradigm.lattice.geometry.numberSitesMax,\n                ),\n                area=cp.LatticeAreaCapabilities(\n                    width=paradigm.lattice.area.width,\n                    height=paradigm.lattice.area.height,\n                ),\n            ),\n            rydberg=cp.RydbergCapabilities(\n                c6_coefficient=paradigm.rydberg.c6Coefficient,\n                global_=cp.RydbergGlobalCapabilities(\n                    rabi_frequency_max=rydberg_global.rabiFrequencyRange[0],\n                    rabi_frequency_min=rydberg_global.rabiFrequencyRange[1],\n                    rabi_frequency_resolution=rydberg_global.rabiFrequencyResolution,\n                    rabi_frequency_slew_rate_max=rydberg_global.rabiFrequencySlewRateMax,\n                    detuning_max=rydberg_global.detuningRange[0],\n                    detuning_min=rydberg_global.detuningRange[1],\n                    detuning_resolution=rydberg_global.detuningResolution,\n                    detuning_slew_rate_max=rydberg_global.detuningSlewRateMax,\n                    phase_min=rydberg_global.phaseRange[0],\n                    phase_max=rydberg_global.phaseRange[1],\n                    phase_resolution=rydberg_global.phaseResolution,\n                    time_min=rydberg_global.timeMin,\n                    time_max=rydberg_global.timeMax,\n                    time_resolution=rydberg_global.timeResolution,\n                    time_delta_min=rydberg_global.timeDeltaMin,\n                ),\n                local=None,\n            ),\n        ),\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/capabilities/","title":"Capabilities","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/parallel/#bloqade.analog.submission.ir.parallel.ClusterLocationInfo","title":"ClusterLocationInfo","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.submission.ir.parallel.ClusterLocationInfo[ClusterLocationInfo]\n\n              \n\n              click bloqade.analog.submission.ir.parallel.ClusterLocationInfo href \"\" \"bloqade.analog.submission.ir.parallel.ClusterLocationInfo\"\n            </code></pre> <p>Class that stores the mapping of batched jobs.</p> <p>Parameters:</p> Name Type Description Default <code>cluster_index</code> <code>int</code> <p>the index of the cluster a site belongs to</p> required <code>global_location_index</code> <code>int</code> <p>the index of the site in the multplexed system</p> required <code>cluster_location_index</code> <code>int</code> <p>the index of the site in the original system</p> required"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/task_results/","title":"Task results","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/task_results/#bloqade.analog.submission.ir.task_results.QuEraTaskResults","title":"QuEraTaskResults","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.submission.ir.task_results.QuEraTaskResults[QuEraTaskResults]\n\n              \n\n              click bloqade.analog.submission.ir.task_results.QuEraTaskResults href \"\" \"bloqade.analog.submission.ir.task_results.QuEraTaskResults\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/task_results/#bloqade.analog.submission.ir.task_results.QuEraTaskResults.export_as_probabilities","title":"export_as_probabilities","text":"<pre><code>export_as_probabilities() -&gt; TaskProbabilities\n</code></pre> <p>converts from shot results to probabilities</p> <p>Returns:</p> Name Type Description <code>TaskProbabilities</code> <code>TaskProbabilities</code> <p>The task results as probabilties</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/submission/ir/task_results.py</code> <pre><code>def export_as_probabilities(self) -&gt; TaskProbabilities:\n    \"\"\"converts from shot results to probabilities\n\n    Returns:\n        TaskProbabilities: The task results as probabilties\n    \"\"\"\n    counts = dict()\n    nshots = len(self.shot_outputs)\n    for shot_result in self.shot_outputs:\n        pre_sequence_str = \"\".join(str(bit) for bit in shot_result.pre_sequence)\n\n        post_sequence_str = \"\".join(str(bit) for bit in shot_result.post_sequence)\n\n        configuration = (pre_sequence_str, post_sequence_str)\n        # iterative average\n        current_count = counts.get(configuration, 0)\n        counts[configuration] = current_count + 1\n\n    probabilities = [(config, count / nshots) for config, count in counts.items()]\n    return TaskProbabilities(probabilities=probabilities)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/task_results/#bloqade.analog.submission.ir.task_results.QuEraTaskStatusCode","title":"QuEraTaskStatusCode","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.submission.ir.task_results.QuEraTaskStatusCode[QuEraTaskStatusCode]\n\n              \n\n              click bloqade.analog.submission.ir.task_results.QuEraTaskStatusCode href \"\" \"bloqade.analog.submission.ir.task_results.QuEraTaskStatusCode\"\n            </code></pre> <p>An Enum representing the various states a task can be in within the QuEra system.</p> <p>Attributes:</p> Name Type Description <code>Created</code> <p>The task has been created but not yet started.</p> <code>Running</code> <p>The task is currently running.</p> <code>Completed</code> <p>The task has completed successfully.</p> <code>Failed</code> <p>The task has failed.</p> <code>Cancelled</code> <p>The task has been cancelled.</p> <code>Executing</code> <p>The task is currently being executed.</p> <code>Enqueued</code> <p>The task is in the queue waiting to be executed.</p> <code>Accepted</code> <p>The task has been accepted for execution.</p> <code>Unaccepted</code> <p>The task has not been accepted for execution.</p> <code>Partial</code> <p>The task has partially completed.</p> <code>Unsubmitted</code> <p>The task has not been submitted for execution.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/submission/ir/task_specification/","title":"Task specification","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/","title":"Index","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/","title":"Base","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Geometry","title":"Geometry","text":"<p>Class representing geometry of an atom arrangement.</p> <p>Attributes:</p> Name Type Description <code>sites</code> <code>List[Tuple[float, float]]</code> <p>Atom site arrangement</p> <code>filling</code> <code>List[int]</code> <p>Which sites are filled</p> <code>parallel_decoder</code> <code>Optional[ParallelDecoder]</code> <p>Decoder object for decoding Geometry object</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.LocalTask","title":"LocalTask","text":"<p>               Bases: <code>Task</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.task.base.LocalTask[LocalTask]\n              bloqade.analog.task.base.Task[Task]\n\n                              bloqade.analog.task.base.Task --&gt; bloqade.analog.task.base.LocalTask\n                \n\n\n              click bloqade.analog.task.base.LocalTask href \"\" \"bloqade.analog.task.base.LocalTask\"\n              click bloqade.analog.task.base.Task href \"\" \"bloqade.analog.task.base.Task\"\n            </code></pre> <p><code>Task</code> to use for local executions for simulation purposes..</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.RemoteTask","title":"RemoteTask","text":"<p>               Bases: <code>Task</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.task.base.RemoteTask[RemoteTask]\n              bloqade.analog.task.base.Task[Task]\n\n                              bloqade.analog.task.base.Task --&gt; bloqade.analog.task.base.RemoteTask\n                \n\n\n              click bloqade.analog.task.base.RemoteTask href \"\" \"bloqade.analog.task.base.RemoteTask\"\n              click bloqade.analog.task.base.Task href \"\" \"bloqade.analog.task.base.Task\"\n            </code></pre> <p><code>Task</code> to use for remote executions to run the program on Quera Quantum Computers.</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report","title":"Report","text":"<pre><code>Report(data, metas, geos, name='')\n</code></pre> <p>Report is a helper class for organizing and analysing data</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report--analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <p>The raw bitstrings measured per each execution of the program <pre><code>&gt;&gt;&gt; report.bitstrings()\n[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n</code></pre></p> <p>The number of times each unique bitstring occurred: <pre><code>&gt;&gt;&gt; report.counts()\n\n[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> <p>The Rydberg Density for each atom <pre><code>&gt;&gt;&gt; report.rydberg_densities()\n\n                0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/base.py</code> <pre><code>def __init__(self, data, metas, geos, name=\"\") -&gt; None:\n    self.dataframe = data  # df\n    self._bitstrings = None  # bitstring cache\n    self._counts = None  # counts cache\n    self.metas = metas\n    self.geos = geos\n    self.name = name + \" \" + str(datetime.datetime.now())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report.markdown","title":"markdown  <code>property</code>","text":"<pre><code>markdown: str\n</code></pre> <p>Get the markdown representation of the dataframe</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report.bitstrings","title":"bitstrings","text":"<pre><code>bitstrings(\n    filter_perfect_filling: bool = True,\n    clusters: Union[\n        tuple[int, int], List[tuple[int, int]]\n    ] = [],\n) -&gt; List[NDArray]\n</code></pre> <p>Get the bitstrings from the data.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will only contain perfect filling shots. Defaults to True.</p> <code>True</code> <code>clusters</code> <code>Union[tuple[int, int], List[tuple[int, int]]]</code> <p>(tuple[int, int], Sequence[Tuple[int, int]]): cluster index to filter shots from. If none are provided all clusters are used, defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>bitstrings</code> <code>list of ndarray</code> <p>list corresponding to each task in the report. Each element is an ndarray of shape (nshots, nsites) where nshots is the number of shots for the task and nsites is the number of sites in the task. For example: <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> Note <p>Note that nshots may vary between tasks if filter_perfect_filling is set to True.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/base.py</code> <pre><code>@beartype\ndef bitstrings(\n    self,\n    filter_perfect_filling: bool = True,\n    clusters: Union[tuple[int, int], List[tuple[int, int]]] = [],\n) -&gt; List[NDArray]:\n    \"\"\"Get the bitstrings from the data.\n\n    Args:\n        filter_perfect_filling (bool): whether return will\n            only contain perfect filling shots. Defaults to True.\n        clusters: (tuple[int, int], Sequence[Tuple[int, int]]):\n            cluster index to filter shots from. If none are provided\n            all clusters are used, defaults to [].\n\n    Returns:\n        bitstrings (list of ndarray): list corresponding to each\n            task in the report. Each element is an ndarray of shape\n            (nshots, nsites) where nshots is the number of shots for\n            the task and nsites is the number of sites in the task.\n            For example:\n            ```python3\n            [array([[1, 1],\n                    [1, 1],\n                    [1, 1],\n                    ...,\n                    [1, 1],\n                    [1, 1],\n                    [1, 0]], dtype=int8)]\n            ```\n\n    Note:\n        Note that nshots may vary between tasks if filter_perfect_filling\n        is set to True.\n\n    \"\"\"\n\n    task_numbers = self.dataframe.index.get_level_values(\"task_number\").unique()\n\n    bitstrings = []\n    for task_number in task_numbers:\n        mask = self._filter(\n            task_number=task_number,\n            filter_perfect_filling=filter_perfect_filling,\n            clusters=clusters,\n        )\n        if np.any(mask):\n            bitstrings.append(self.dataframe.loc[mask].to_numpy())\n        else:\n            bitstrings.append(\n                np.zeros((0, self.dataframe.shape[1]), dtype=np.uint8)\n            )\n\n    return bitstrings\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report.counts","title":"counts","text":"<pre><code>counts(\n    filter_perfect_filling: bool = True,\n    clusters: Union[\n        tuple[int, int], List[tuple[int, int]]\n    ] = [],\n) -&gt; List[OrderedDict[str, int]]\n</code></pre> <p>Get the counts of unique bit strings.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will only contain perfect filling shots. Defaults to True.</p> <code>True</code> <code>clusters</code> <code>Union[tuple[int, int], List[tuple[int, int]]]</code> <p>(tuple[int, int], Sequence[Tuple[int, int]]): cluster index to filter shots from. If none are provided all clusters are used, defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>counts</code> <code>list of OrderedDict[str, int]</code> <p>list corresponding to each task in the report. Each element is an ndarray of shape (nshots, nsites) where nshots is the number of shots for the task and nsites is the number of sites in the task. For example: <pre><code>    [OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> Note <p>Note that nshots may vary between tasks if filter_perfect_filling is set to True.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/base.py</code> <pre><code>def counts(\n    self,\n    filter_perfect_filling: bool = True,\n    clusters: Union[tuple[int, int], List[tuple[int, int]]] = [],\n) -&gt; List[OrderedDict[str, int]]:\n    \"\"\"Get the counts of unique bit strings.\n\n    Args:\n        filter_perfect_filling (bool): whether return will\n            only contain perfect filling shots. Defaults to True.\n        clusters: (tuple[int, int], Sequence[Tuple[int, int]]):\n            cluster index to filter shots from. If none are provided\n            all clusters are used, defaults to [].\n\n    Returns:\n        counts (list of OrderedDict[str, int]): list corresponding to each\n            task in the report. Each element is an ndarray of shape\n            (nshots, nsites) where nshots is the number of shots for\n            the task and nsites is the number of sites in the task.\n            For example:\n            ```python\n                [OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n            ```\n\n    Note:\n        Note that nshots may vary between tasks if filter_perfect_filling\n        is set to True.\n\n    \"\"\"\n\n    def _generate_counts(bitstring):\n        output = np.unique(bitstring, axis=0, return_counts=True)\n\n        count_list = [\n            (\"\".join(map(str, bitstring)), int(count))\n            for bitstring, count in zip(*output)\n        ]\n        count_list.sort(key=lambda x: x[1], reverse=True)\n        count = OrderedDict(count_list)\n\n        return count\n\n    return list(\n        map(_generate_counts, self.bitstrings(filter_perfect_filling, clusters))\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report.list_param","title":"list_param","text":"<pre><code>list_param(field_name: str) -&gt; List[Union[Number, None]]\n</code></pre> <p>List the parameters associate with the given variable field_name for each tasks.</p> <p>Parameters:</p> Name Type Description Default <code>field_name</code> <code>str</code> <p>variable name</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/base.py</code> <pre><code>def list_param(self, field_name: str) -&gt; List[Union[Number, None]]:\n    \"\"\"\n    List the parameters associate with the given variable field_name\n    for each tasks.\n\n    Args:\n        field_name (str): variable name\n\n    \"\"\"\n\n    def cast(x):\n        if x is None:\n            return None\n        elif isinstance(x, (list, tuple, np.ndarray)):\n            return list(map(cast, x))\n        else:\n            return float(x)\n\n    return list(map(cast, (meta.get(field_name) for meta in self.metas)))\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report.rydberg_densities","title":"rydberg_densities","text":"<pre><code>rydberg_densities(\n    filter_perfect_filling: bool = True,\n    clusters: Union[\n        tuple[int, int], List[tuple[int, int]]\n    ] = [],\n) -&gt; Union[pd.Series, pd.DataFrame]\n</code></pre> <p>Get rydberg density for each task.</p> <p>Parameters:</p> Name Type Description Default <code>filter_perfect_filling</code> <code>bool</code> <p>whether return will only contain perfect filling shots. Defaults to True.</p> <code>True</code> <code>clusters</code> <code>Union[tuple[int, int], List[tuple[int, int]]]</code> <p>(tuple[int, int], Sequence[Tuple[int, int]]): cluster index to filter shots from. If none are provided all clusters are used, defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>rydberg_densities</code> <code>Union[Series, DataFrame]</code> <p>per-site rydberg density for each task as a pandas DataFrame or Series. For example: <pre><code>0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/base.py</code> <pre><code>@beartype\ndef rydberg_densities(\n    self,\n    filter_perfect_filling: bool = True,\n    clusters: Union[tuple[int, int], List[tuple[int, int]]] = [],\n) -&gt; Union[pd.Series, pd.DataFrame]:\n    \"\"\"Get rydberg density for each task.\n\n    Args:\n        filter_perfect_filling (bool, optional): whether return will\n            only contain perfect filling shots. Defaults to True.\n        clusters: (tuple[int, int], Sequence[Tuple[int, int]]):\n            cluster index to filter shots from. If none are provided\n            all clusters are used, defaults to [].\n\n    Returns:\n        rydberg_densities (Union[pd.Series, pd.DataFrame]):\n            per-site rydberg density for each task as a pandas DataFrame or Series.\n            For example:\n            ```python\n            0      1\n            task_number\n            0            0.053  0.054\n            ```\n    \"\"\"\n    mask = self._filter(\n        filter_perfect_filling=filter_perfect_filling, clusters=clusters\n    )\n    df = self.dataframe[mask]\n    return 1 - (df.groupby(\"task_number\").mean())\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/base/#bloqade.analog.task.base.Report.show","title":"show","text":"<pre><code>show()\n</code></pre> <p>Interactive Visualization of the Report</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/base.py</code> <pre><code>def show(self):\n    \"\"\"\n    Interactive Visualization of the Report\n\n    \"\"\"\n    display_report(self)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/","title":"Batch","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.Filter","title":"Filter","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.Filter.filter_metadata","title":"filter_metadata","text":"<pre><code>filter_metadata(\n    __match_any__: bool = False,\n    **metadata: MetadataFilterType\n) -&gt; Union[LocalBatch, RemoteBatch]\n</code></pre> <p>Create a Batch object that has tasks filtered based on the values of metadata.</p> <p>Parameters:</p> Name Type Description Default <code>__match_any__</code> <code>bool</code> <p>if True, then a task will be included if it matches any of the metadata filters. If False, then a task will be included only if it matches all of the metadata filters. Defaults to False.</p> <code>False</code> <code>**metadata</code> <code>MetadataFilterType</code> <p>the metadata to filter on. The keys are the metadata names and the values (as a set) are the values to filter on. The elements in the set can be Real, Decimal, Tuple[Real], or Tuple[Decimal].</p> <code>{}</code> Return <p>type(self): a Batch object with the filtered tasks, either     LocalBatch or RemoteBatch depending on the type of self</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>@beartype\ndef filter_metadata(\n    self, __match_any__: bool = False, **metadata: MetadataFilterType\n) -&gt; Union[\"LocalBatch\", \"RemoteBatch\"]:\n    \"\"\"Create a Batch object that has tasks filtered based on the\n    values of metadata.\n\n    Args:\n        __match_any__: if True, then a task will be included if it\n            matches any of the metadata filters. If False, then a\n            task will be included only if it matches all of the\n            metadata filters. Defaults to False.\n\n        **metadata: the metadata to filter on. The keys are the metadata\n            names and the values (as a set) are the values to filter on.\n            The elements in the set can be Real, Decimal, Tuple[Real], or\n            Tuple[Decimal].\n\n    Return:\n        type(self): a Batch object with the filtered tasks, either\n            LocalBatch or RemoteBatch depending on the type of self\n\n    \"\"\"\n\n    def convert_to_decimal(element):\n        if isinstance(element, list):\n            return list(map(convert_to_decimal, element))\n        elif isinstance(element, (Real, Decimal)):\n            return Decimal(str(element))\n        else:\n            raise ValueError(\n                f\"Invalid value {element} for metadata filter. \"\n                \"Only Real, Decimal, List[Real], and List[Decimal] \"\n                \"are supported.\"\n            )\n\n    def metadata_match_all(task):\n        return all(\n            task.metadata.get(key) in value for key, value in metadata.items()\n        )\n\n    def metadata_match_any(task):\n        return any(\n            task.metadata.get(key) in value for key, value in metadata.items()\n        )\n\n    metadata = {k: list(map(convert_to_decimal, v)) for k, v in metadata.items()}\n\n    metadata_filter = metadata_match_any if __match_any__ else metadata_match_all\n\n    new_tasks = OrderedDict(\n        [(k, v) for k, v in self.tasks.items() if metadata_filter(v)]\n    )\n\n    kw = dict(self.__dict__)\n    kw[\"tasks\"] = new_tasks\n\n    return self.__class__(**kw)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.LocalBatch","title":"LocalBatch  <code>dataclass</code>","text":"<pre><code>LocalBatch(\n    source: Optional[Builder],\n    tasks: OrderedDict[\n        int, Union[BraketEmulatorTask, BloqadeTask]\n    ],\n    name: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Serializable</code>, <code>Filter</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.task.batch.LocalBatch[LocalBatch]\n              bloqade.analog.task.batch.Serializable[Serializable]\n              bloqade.analog.task.batch.Filter[Filter]\n\n                              bloqade.analog.task.batch.Serializable --&gt; bloqade.analog.task.batch.LocalBatch\n                \n                bloqade.analog.task.batch.Filter --&gt; bloqade.analog.task.batch.LocalBatch\n                \n\n\n              click bloqade.analog.task.batch.LocalBatch href \"\" \"bloqade.analog.task.batch.LocalBatch\"\n              click bloqade.analog.task.batch.Serializable href \"\" \"bloqade.analog.task.batch.Serializable\"\n              click bloqade.analog.task.batch.Filter href \"\" \"bloqade.analog.task.batch.Filter\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.LocalBatch.report","title":"report","text":"<pre><code>report() -&gt; Report\n</code></pre> <p>Generate analysis report base on currently completed tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def report(self) -&gt; Report:\n    \"\"\"\n    Generate analysis report base on currently\n    completed tasks in the LocalBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n\n    ## this potentially can be specialize/disatch\n    ## offline\n    index = []\n    data = []\n    metas = []\n    geos = []\n\n    for task_number, task in self.tasks.items():\n        geometry = task.geometry\n        perfect_sorting = \"\".join(map(str, geometry.filling))\n        parallel_decoder = geometry.parallel_decoder\n\n        if parallel_decoder:\n            cluster_indices = parallel_decoder.get_cluster_indices()\n        else:\n            cluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\n\n        shot_iter = filter(\n            lambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\n            task.result().shot_outputs,\n        )\n\n        for shot, (cluster_coordinate, cluster_index) in product(\n            shot_iter, cluster_indices.items()\n        ):\n            pre_sequence = \"\".join(\n                map(\n                    str,\n                    (shot.pre_sequence[index] for index in cluster_index),\n                )\n            )\n\n            post_sequence = np.asarray(\n                [shot.post_sequence[index] for index in cluster_index],\n                dtype=np.int8,\n            )\n\n            pfc_sorting = \"\".join(\n                [perfect_sorting[index] for index in cluster_index]\n            )\n\n            key = (\n                task_number,\n                cluster_coordinate,\n                pfc_sorting,\n                pre_sequence,\n            )\n\n            index.append(key)\n            data.append(post_sequence)\n\n        metas.append(task.metadata)\n        geos.append(task.geometry)\n\n    index = pd.MultiIndex.from_tuples(\n        index, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n    )\n\n    df = pd.DataFrame(data, index=index)\n    df.sort_index(axis=\"index\")\n\n    rept = None\n    if self.name is None:\n        rept = Report(df, metas, geos, \"Local\")\n    else:\n        rept = Report(df, metas, geos, self.name)\n\n    return rept\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.LocalBatch.rerun","title":"rerun","text":"<pre><code>rerun(\n    multiprocessing: bool = False,\n    num_workers: Optional[int] = None,\n    **kwargs\n)\n</code></pre> <p>Rerun all the tasks in the LocalBatch.</p> Return <p>Report</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>@beartype\ndef rerun(\n    self, multiprocessing: bool = False, num_workers: Optional[int] = None, **kwargs\n):\n    \"\"\"\n    Rerun all the tasks in the LocalBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n\n    return self._run(\n        multiprocessing=multiprocessing, num_workers=num_workers, **kwargs\n    )\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch","title":"RemoteBatch  <code>dataclass</code>","text":"<pre><code>RemoteBatch(\n    source: Builder,\n    tasks: Union[\n        OrderedDict[int, QuEraTask],\n        OrderedDict[int, BraketTask],\n        OrderedDict[int, CustomRemoteTaskABC],\n    ],\n    name: Optional[str] = None,\n)\n</code></pre> <p>               Bases: <code>Serializable</code>, <code>Filter</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.task.batch.RemoteBatch[RemoteBatch]\n              bloqade.analog.task.batch.Serializable[Serializable]\n              bloqade.analog.task.batch.Filter[Filter]\n\n                              bloqade.analog.task.batch.Serializable --&gt; bloqade.analog.task.batch.RemoteBatch\n                \n                bloqade.analog.task.batch.Filter --&gt; bloqade.analog.task.batch.RemoteBatch\n                \n\n\n              click bloqade.analog.task.batch.RemoteBatch href \"\" \"bloqade.analog.task.batch.RemoteBatch\"\n              click bloqade.analog.task.batch.Serializable href \"\" \"bloqade.analog.task.batch.Serializable\"\n              click bloqade.analog.task.batch.Filter href \"\" \"bloqade.analog.task.batch.Filter\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.total_nshots","title":"total_nshots  <code>property</code>","text":"<pre><code>total_nshots\n</code></pre> <p>Total number of shots of all tasks in the RemoteBatch</p> Return <p>number of shots</p>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.cancel","title":"cancel","text":"<pre><code>cancel() -&gt; RemoteBatch\n</code></pre> <p>Cancel all the tasks in the Batch.</p> Return <p>self</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def cancel(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Cancel all the tasks in the Batch.\n\n    Return:\n        self\n\n    \"\"\"\n    # cancel all jobs\n    for task in self.tasks.values():\n        task.cancel()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.fetch","title":"fetch","text":"<pre><code>fetch() -&gt; RemoteBatch\n</code></pre> <p>Fetch the tasks in the Batch.</p> Note <p>Fetching will update the status of tasks, and only pull the results for those tasks that have completed.</p> Return <p>self</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def fetch(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Fetch the tasks in the Batch.\n\n    Note:\n        Fetching will update the status of tasks,\n        and only pull the results for those tasks\n        that have completed.\n\n    Return:\n        self\n\n    \"\"\"\n    # online, non-blocking\n    # pull the results only when its ready\n    for task in self.tasks.values():\n        task.fetch()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.get_completed_tasks","title":"get_completed_tasks","text":"<pre><code>get_completed_tasks() -&gt; RemoteBatch\n</code></pre> <p>Create a RemoteBatch object that contain completed tasks from current Batch.</p> <p>Tasks consider completed with following status codes:</p> <ol> <li>Completed</li> <li>Partial</li> </ol> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def get_completed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain completed tasks from current Batch.\n\n    Tasks consider completed with following status codes:\n\n    1. Completed\n    2. Partial\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    statuses = [\n        \"Completed\",\n        \"Partial\",\n    ]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.get_failed_tasks","title":"get_failed_tasks","text":"<pre><code>get_failed_tasks() -&gt; RemoteBatch\n</code></pre> <p>Create a RemoteBatch object that contain failed tasks from current Batch.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def get_failed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain failed tasks from current Batch.\n\n    failed tasks with following status codes:\n\n    1. Failed\n    2. Unaccepted\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that are\n    # completed because of an error\n    statuses = [\"Failed\", \"Unaccepted\"]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.get_finished_tasks","title":"get_finished_tasks","text":"<pre><code>get_finished_tasks() -&gt; RemoteBatch\n</code></pre> <p>Create a RemoteBatch object that contain finished tasks from current Batch.</p> <p>Tasks consider finished with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> <li>Completed</li> <li>Partial</li> <li>Cancelled</li> </ol> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def get_finished_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain finished tasks from current Batch.\n\n    Tasks consider finished with following status codes:\n\n    1. Failed\n    2. Unaccepted\n    3. Completed\n    4. Partial\n    5. Cancelled\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that will\n    # not run going forward for any reason\n    statuses = [\"Completed\", \"Failed\", \"Unaccepted\", \"Partial\", \"Cancelled\"]\n    return self.get_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.get_tasks","title":"get_tasks","text":"<pre><code>get_tasks(*status_codes: str) -&gt; RemoteBatch\n</code></pre> <p>Get Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>@beartype\ndef get_tasks(self, *status_codes: str) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Get Tasks with specify status_codes.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # offline:\n    st_codes = [QuEraTaskStatusCode(x) for x in status_codes]\n\n    new_task_results = OrderedDict()\n    for task_number, task in self.tasks.items():\n        if task.task_result_ir.task_status in st_codes:\n            new_task_results[task_number] = task\n\n    return RemoteBatch(self.source, new_task_results, name=self.name)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.pull","title":"pull","text":"<pre><code>pull() -&gt; RemoteBatch\n</code></pre> <p>Pull results of the tasks in the Batch.</p> Note <p>Pulling will pull the results for the tasks. If a given task(s) has not been completed, wait until it finished.</p> Return <p>self</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def pull(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Pull results of the tasks in the Batch.\n\n    Note:\n        Pulling will pull the results for the tasks.\n        If a given task(s) has not been completed, wait\n        until it finished.\n\n    Return:\n        self\n    \"\"\"\n    # online, blocking\n    # pull the results. if its not ready, hanging\n    for task in self.tasks.values():\n        task.pull()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.remove_failed_tasks","title":"remove_failed_tasks","text":"<pre><code>remove_failed_tasks() -&gt; RemoteBatch\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with failed tasks removed.</p> <p>failed tasks with following status codes:</p> <ol> <li>Failed</li> <li>Unaccepted</li> </ol> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def remove_failed_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with failed tasks removed.\n\n    failed tasks with following status codes:\n\n    1. Failed\n    2. Unaccepted\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # statuses that are in a state that will\n    # not run going forward because of an error\n    statuses = [\"Failed\", \"Unaccepted\"]\n    return self.remove_tasks(*statuses)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.remove_invalid_tasks","title":"remove_invalid_tasks","text":"<pre><code>remove_invalid_tasks() -&gt; RemoteBatch\n</code></pre> <p>Create a RemoteBatch object that contain tasks from current Batch, with all Unaccepted tasks removed.</p> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def remove_invalid_tasks(self) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Create a RemoteBatch object that\n    contain tasks from current Batch,\n    with all Unaccepted tasks removed.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    return self.remove_tasks(\"Unaccepted\")\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.remove_tasks","title":"remove_tasks","text":"<pre><code>remove_tasks(\n    *status_codes: Literal[\n        \"Created\",\n        \"Running\",\n        \"Completed\",\n        \"Failed\",\n        \"Cancelled\",\n        \"Executing\",\n        \"Enqueued\",\n        \"Accepted\",\n        \"Unaccepted\",\n        \"Partial\",\n        \"Unsubmitted\",\n    ]\n) -&gt; RemoteBatch\n</code></pre> <p>Remove Tasks with specify status_codes.</p> Return <p>RemoteBatch</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>@beartype\ndef remove_tasks(\n    self,\n    *status_codes: Literal[\n        \"Created\",\n        \"Running\",\n        \"Completed\",\n        \"Failed\",\n        \"Cancelled\",\n        \"Executing\",\n        \"Enqueued\",\n        \"Accepted\",\n        \"Unaccepted\",\n        \"Partial\",\n        \"Unsubmitted\",\n    ],\n) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Remove Tasks with specify status_codes.\n\n    Return:\n        RemoteBatch\n\n    \"\"\"\n    # offline:\n\n    st_codes = [QuEraTaskStatusCode(x) for x in status_codes]\n\n    new_results = OrderedDict()\n    for task_number, task in self.tasks.items():\n        if task.task_result_ir.task_status in st_codes:\n            continue\n\n        new_results[task_number] = task\n\n    return RemoteBatch(self.source, new_results, self.name)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.report","title":"report","text":"<pre><code>report() -&gt; Report\n</code></pre> <p>Generate analysis report base on currently completed tasks in the RemoteBatch.</p> Return <p>Report</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def report(self) -&gt; \"Report\":\n    \"\"\"\n    Generate analysis report base on currently\n    completed tasks in the RemoteBatch.\n\n    Return:\n        Report\n\n    \"\"\"\n    ## this potentially can be specialize/disatch\n    ## offline\n    index = []\n    data = []\n    metas = []\n    geos = []\n\n    for task_number, task in self.tasks.items():\n        ## fliter not existing results tasks:\n        if (task.task_id is None) or (not task._result_exists()):\n            continue\n\n        ## filter has result but is not correctly completed.\n        if task.task_result_ir.task_status not in [\n            QuEraTaskStatusCode.Completed,\n            QuEraTaskStatusCode.Partial,\n        ]:\n            continue\n\n        geometry = task.geometry\n        perfect_sorting = \"\".join(map(str, geometry.filling))\n        parallel_decoder = geometry.parallel_decoder\n\n        if parallel_decoder:\n            cluster_indices = parallel_decoder.get_cluster_indices()\n        else:\n            cluster_indices = {(0, 0): list(range(len(perfect_sorting)))}\n\n        shot_iter = filter(\n            lambda shot: shot.shot_status == QuEraShotStatusCode.Completed,\n            task.result().shot_outputs,\n        )\n\n        for shot, (cluster_coordinate, cluster_index) in product(\n            shot_iter, cluster_indices.items()\n        ):\n            pre_sequence = \"\".join(\n                map(\n                    str,\n                    (shot.pre_sequence[index] for index in cluster_index),\n                )\n            )\n\n            post_sequence = np.asarray(\n                [shot.post_sequence[index] for index in cluster_index],\n                dtype=np.int8,\n            )\n\n            pfc_sorting = \"\".join(\n                [perfect_sorting[index] for index in cluster_index]\n            )\n\n            key = (\n                task_number,\n                cluster_coordinate,\n                pfc_sorting,\n                pre_sequence,\n            )\n\n            index.append(key)\n            data.append(post_sequence)\n\n        metas.append(task.metadata)\n        geos.append(task.geometry)\n\n    index = pd.MultiIndex.from_tuples(\n        index, names=[\"task_number\", \"cluster\", \"perfect_sorting\", \"pre_sequence\"]\n    )\n\n    df = pd.DataFrame(data, index=index)\n    df.sort_index(axis=\"index\")\n\n    rept = None\n    if self.name is None:\n        rept = Report(df, metas, geos, \"Remote\")\n    else:\n        rept = Report(df, metas, geos, self.name)\n\n    return rept\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.resubmit","title":"resubmit","text":"<pre><code>resubmit(shuffle_submit_order: bool = True) -&gt; RemoteBatch\n</code></pre> <p>Resubmit all the tasks in the RemoteBatch</p> Return <p>self</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>@beartype\ndef resubmit(self, shuffle_submit_order: bool = True) -&gt; \"RemoteBatch\":\n    \"\"\"\n    Resubmit all the tasks in the RemoteBatch\n\n    Return:\n        self\n\n    \"\"\"\n    # online, non-blocking\n    self._submit(shuffle_submit_order, force=True)\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.retrieve","title":"retrieve","text":"<pre><code>retrieve() -&gt; RemoteBatch\n</code></pre> <p>Retrieve missing task results.</p> Note <p>Retrieve will update the status of tasks, and only pull the results for those tasks that have completed.</p> Return <p>self</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def retrieve(self) -&gt; \"RemoteBatch\":\n    \"\"\"Retrieve missing task results.\n\n    Note:\n        Retrieve will update the status of tasks,\n        and only pull the results for those tasks\n        that have completed.\n\n    Return:\n        self\n\n    \"\"\"\n    # partially online, sometimes blocking\n    # pull the results for tasks that have\n    # not been pulled already.\n    for task in self.tasks.values():\n        if not task._result_exists():\n            task.pull()\n\n    return self\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.RemoteBatch.tasks_metric","title":"tasks_metric","text":"<pre><code>tasks_metric() -&gt; pd.DataFrame\n</code></pre> <p>Get current tasks status metric</p> Return <p>dataframe with [\"task id\", \"status\", \"shots\"]</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def tasks_metric(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Get current tasks status metric\n\n    Return:\n        dataframe with [\"task id\", \"status\", \"shots\"]\n\n    \"\"\"\n    # [TODO] more info on current status\n    # offline, non-blocking\n    tid = []\n    data = []\n    for task_num, task in self.tasks.items():\n        tid.append(task_num)\n\n        dat: list[int | str | None] = [None, None, None]\n        dat[0] = task.task_id\n        if task.task_result_ir is not None:\n            dat[1] = task.task_result_ir.task_status.name\n        dat[2] = task.task_ir.nshots\n        data.append(dat)\n\n    return pd.DataFrame(data, index=tid, columns=[\"task ID\", \"status\", \"shots\"])\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.Serializable","title":"Serializable","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/batch/#bloqade.analog.task.batch.Serializable.json","title":"json","text":"<pre><code>json(**options) -&gt; str\n</code></pre> <p>Serialize the object to JSON string.</p> Return <p>JSON string</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/batch.py</code> <pre><code>def json(self, **options) -&gt; str:\n    \"\"\"\n    Serialize the object to JSON string.\n\n    Return:\n        JSON string\n\n    \"\"\"\n    from bloqade.analog import dumps\n\n    return dumps(self, **options)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/bloqade/","title":"Bloqade","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/braket/","title":"Braket","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/braket_simulator/","title":"Braket simulator","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/","title":"Exclusive","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.ExclusiveRemoteTask","title":"ExclusiveRemoteTask  <code>dataclass</code>","text":"<pre><code>ExclusiveRemoteTask(\n    _task_ir: QuEraTaskSpecification | None,\n    _metadata: Dict[str, ParamType],\n    _parallel_decoder: ParallelDecoder | None,\n    _http_handler: HTTPHandlerABC = HTTPHandler(),\n    _task_id: str | None = None,\n    _task_result_ir: QuEraTaskResults | None = None,\n)\n</code></pre> <p>               Bases: <code>CustomRemoteTaskABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.task.exclusive.ExclusiveRemoteTask[ExclusiveRemoteTask]\n              bloqade.analog.task.base.CustomRemoteTaskABC[CustomRemoteTaskABC]\n\n                              bloqade.analog.task.base.CustomRemoteTaskABC --&gt; bloqade.analog.task.exclusive.ExclusiveRemoteTask\n                \n\n\n              click bloqade.analog.task.exclusive.ExclusiveRemoteTask href \"\" \"bloqade.analog.task.exclusive.ExclusiveRemoteTask\"\n              click bloqade.analog.task.base.CustomRemoteTaskABC href \"\" \"bloqade.analog.task.base.CustomRemoteTaskABC\"\n            </code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.ExclusiveRemoteTask.pull","title":"pull","text":"<pre><code>pull(poll_interval: float = 20)\n</code></pre> <p>Blocking pull to get the task result. poll_interval is the time interval to poll the task status. Please ensure that it is relatively large, otherwise the server could get overloaded with queries.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>def pull(self, poll_interval: float = 20):\n    \"\"\"\n    Blocking pull to get the task result.\n    poll_interval is the time interval to poll the task status.\n    Please ensure that it is relatively large, otherwise\n    the server could get overloaded with queries.\n    \"\"\"\n\n    while True:\n        if self._task_result_ir.task_status is QuEraTaskStatusCode.Unsubmitted:\n            raise ValueError(\"Task ID not found.\")\n\n        if self._task_result_ir.task_status in [\n            QuEraTaskStatusCode.Completed,\n            QuEraTaskStatusCode.Partial,\n            QuEraTaskStatusCode.Failed,\n            QuEraTaskStatusCode.Unaccepted,\n            QuEraTaskStatusCode.Cancelled,\n        ]:\n            return self\n\n        status = self.status()\n        if status in [QuEraTaskStatusCode.Completed, QuEraTaskStatusCode.Partial]:\n            self._task_result_ir = self._http_handler.fetch_results(self._task_id)\n            return self\n\n        time.sleep(poll_interval)\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandler","title":"HTTPHandler","text":"<pre><code>HTTPHandler(\n    zapier_webhook_url: str = None,\n    zapier_webhook_key: str = None,\n    vercel_api_url: str = None,\n)\n</code></pre> <p>               Bases: <code>HTTPHandlerABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.analog.task.exclusive.HTTPHandler[HTTPHandler]\n              bloqade.analog.task.exclusive.HTTPHandlerABC[HTTPHandlerABC]\n\n                              bloqade.analog.task.exclusive.HTTPHandlerABC --&gt; bloqade.analog.task.exclusive.HTTPHandler\n                \n\n\n              click bloqade.analog.task.exclusive.HTTPHandler href \"\" \"bloqade.analog.task.exclusive.HTTPHandler\"\n              click bloqade.analog.task.exclusive.HTTPHandlerABC href \"\" \"bloqade.analog.task.exclusive.HTTPHandlerABC\"\n            </code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>def __init__(\n    self,\n    zapier_webhook_url: str = None,\n    zapier_webhook_key: str = None,\n    vercel_api_url: str = None,\n):\n    self.zapier_webhook_url = zapier_webhook_url or os.environ[\"ZAPIER_WEBHOOK_URL\"]\n    self.zapier_webhook_key = zapier_webhook_key or os.environ[\"ZAPIER_WEBHOOK_KEY\"]\n    self.verrcel_api_url = vercel_api_url or os.environ[\"VERCEL_API_URL\"]\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandler.fetch_results","title":"fetch_results","text":"<pre><code>fetch_results(task_id: str)\n</code></pre> <p>Fetch the task results from the AirTable.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task id to be queried.</p> required <p>returns     response: The response from the AirTable. used for error handling</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>def fetch_results(self, task_id: str):\n    response = request(\n        \"GET\",\n        self.verrcel_api_url,\n        params={\n            \"searchPattern\": task_id,\n            \"magicToken\": self.zapier_webhook_key,\n            \"useRegex\": False,\n        },\n    )\n    if response.status_code != 200:\n        print(f\"HTTP request failed with status code: {response.status_code}\")\n        print(\"HTTP responce: \", response.text)\n        return None\n\n    response_data = response.json()\n    # Get \"matched\" from the response\n    matches = response_data.get(\"matches\", None)\n    # The return is a list of dictionaries\n    # Verify if the list contains only one element\n    if matches is None:\n        print(\"No task found with the given ID.\")\n        return None\n    elif len(matches) &gt; 1:\n        print(\"Multiple tasks found with the given ID.\")\n        return None\n    record = matches[0]\n    if record.get(\"status\") == \"Completed\":\n        googledoc = record.get(\"resultsFileUrl\")\n\n        # convert the preview URL to download URL\n        googledoc = convert_preview_to_download(googledoc)\n        res = get(googledoc)\n        res.raise_for_status()\n        data = res.json()\n\n        task_results = QuEraTaskResults(**data)\n    return task_results\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandler.query_task_status","title":"query_task_status","text":"<pre><code>query_task_status(task_id: str)\n</code></pre> <p>Query the task status from the AirTable.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task id to be queried.</p> required <p>returns     response: The response from the AirTable. used for error handling</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>def query_task_status(self, task_id: str):\n    response = request(\n        \"GET\",\n        self.verrcel_api_url,\n        params={\n            \"searchPattern\": task_id,\n            \"magicToken\": self.zapier_webhook_key,\n            \"useRegex\": False,\n        },\n    )\n    if response.status_code != 200:\n        return \"HTTP Request Failed.\"\n    response_data = response.json()\n    # Get \"matched\" from the response\n    matches = response_data.get(\"matches\", None)\n    # The return is a list of dictionaries\n    # Verify if the list contains only one element\n    if matches is None:\n        print(\"No task found with the given ID.\")\n        return \"Task searching Failed\"\n    elif len(matches) &gt; 1:\n        print(\"Multiple tasks found with the given ID.\")\n        return \"Task searching Failed\"\n\n    record = matches[0]\n\n    # Extract the status from the first dictionary\n    status = record.get(\"status\")\n\n    if status == \"Failed validation\":\n        googledoc = record.get(\"resultsFileUrl\")\n\n        # convert the preview URL to download URL\n        googledoc = convert_preview_to_download(googledoc)\n        res = get(googledoc)\n        res.raise_for_status()\n        data = res.json()\n        # get the \"statusCode\" and \"message\" from the data and print them out.\n        status_code = data.get(\"statusCode\", \"NA\")\n        message = data.get(\"message\", \"NA\")\n        print(\n            f\"Task validation failed with status code: {status_code}, message: {message}\"\n        )\n\n    return status\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandler.submit_task_via_zapier","title":"submit_task_via_zapier","text":"<pre><code>submit_task_via_zapier(\n    task_ir: QuEraTaskSpecification,\n    task_id: str,\n    task_note: str,\n)\n</code></pre> <p>Submit a task and add task_id to the task fields for querying later.</p> <p>Parameters:</p> Name Type Description Default <code>task_ir</code> <code>QuEraTaskSpecification</code> <p>The task to be submitted.</p> required <code>task_id</code> <code>str</code> <p>The task id to be added to the task fields.</p> required <p>returns     response: The response from the Zapier webhook. used for error handling</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>def submit_task_via_zapier(\n    self, task_ir: QuEraTaskSpecification, task_id: str, task_note: str\n):\n    # implement http request logic to submit task via Zapier\n    request_options = dict(params={\"key\": self.zapier_webhook_key, \"note\": task_id})\n\n    # for metadata, task_ir in self._compile_single(shots, use_experimental, args):\n    json_request_body = task_ir.json(exclude_none=True, exclude_unset=True)\n\n    request_options.update(data=json_request_body)\n    response = request(\"POST\", self.zapier_webhook_url, **request_options)\n\n    if response.status_code == 200:\n        response_data = response.json()\n        submit_status = response_data.get(\"status\", None)\n        return submit_status\n    else:\n        print(f\"HTTP request failed with status code: {response.status_code}\")\n        print(\"HTTP responce: \", response.text)\n        return \"HTTP Request Failed\"\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandlerABC","title":"HTTPHandlerABC","text":""},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandlerABC.fetch_results","title":"fetch_results  <code>abstractmethod</code>","text":"<pre><code>fetch_results(task_id: str)\n</code></pre> <p>Fetch the task results from the AirTable.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task id to be queried.</p> required <p>returns     response: The response from the AirTable. used for error handling</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>@abc.abstractmethod\ndef fetch_results(task_id: str):\n    \"\"\"Fetch the task results from the AirTable.\n\n    args:\n        task_id: The task id to be queried.\n\n    returns\n        response: The response from the AirTable. used for error handling\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandlerABC.query_task_status","title":"query_task_status  <code>abstractmethod</code>","text":"<pre><code>query_task_status(task_id: str)\n</code></pre> <p>Query the task status from the AirTable.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The task id to be queried.</p> required <p>returns     response: The response from the AirTable. used for error handling</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>@abc.abstractmethod\ndef query_task_status(task_id: str):\n    \"\"\"Query the task status from the AirTable.\n\n    args:\n        task_id: The task id to be queried.\n\n    returns\n        response: The response from the AirTable. used for error handling\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/exclusive/#bloqade.analog.task.exclusive.HTTPHandlerABC.submit_task_via_zapier","title":"submit_task_via_zapier  <code>abstractmethod</code>","text":"<pre><code>submit_task_via_zapier(\n    task_ir: QuEraTaskSpecification, task_id: str\n)\n</code></pre> <p>Submit a task and add task_id to the task fields for querying later.</p> <p>Parameters:</p> Name Type Description Default <code>task_ir</code> <code>QuEraTaskSpecification</code> <p>The task to be submitted.</p> required <code>task_id</code> <code>str</code> <p>The task id to be added to the task fields.</p> required <p>returns     response: The response from the Zapier webhook. used for error handling</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analog/task/exclusive.py</code> <pre><code>@abc.abstractmethod\ndef submit_task_via_zapier(task_ir: QuEraTaskSpecification, task_id: str):\n    \"\"\"Submit a task and add task_id to the task fields for querying later.\n\n    args:\n        task_ir: The task to be submitted.\n        task_id: The task id to be added to the task fields.\n\n    returns\n        response: The response from the Zapier webhook. used for error handling\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-analog/src/bloqade/analog/task/quera/","title":"Quera","text":""},{"location":"reference/bloqade-circuit/src/bloqade/device/","title":"Device","text":""},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractDevice","title":"AbstractDevice","text":"<p>               Bases: <code>ABC</code>, <code>Generic[TaskType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n              \n\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre> <p>Abstract base class for devices. Defines the minimum interface for devices.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractDevice.task","title":"task  <code>abstractmethod</code>","text":"<pre><code>task(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n) -&gt; TaskType\n</code></pre> <p>Creates a remote task for the device.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/device.py</code> <pre><code>@abc.abstractmethod\ndef task(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n) -&gt; TaskType:\n    \"\"\"Creates a remote task for the device.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractRemoteDevice","title":"AbstractRemoteDevice","text":"<p>               Bases: <code>AbstractDevice[RemoteTaskType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.device.AbstractRemoteDevice[AbstractRemoteDevice]\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n                              bloqade.device.AbstractDevice --&gt; bloqade.device.AbstractRemoteDevice\n                \n\n\n              click bloqade.device.AbstractRemoteDevice href \"\" \"bloqade.device.AbstractRemoteDevice\"\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre> <p>Abstract base class for remote devices.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractRemoteDevice.run","title":"run","text":"<pre><code>run(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n    *,\n    shots: int = 1,\n    timeout: float | None = None\n) -&gt; list[RetType]\n</code></pre> <p>Runs the kernel and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>Method</code> <p>The kernel method to run.</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments to pass to the kernel method.</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to pass to the kernel method.</p> <code>None</code> <code>shots</code> <code>int</code> <p>The number of times to run the kernel method.</p> <code>1</code> <code>timeout</code> <code>float | None</code> <p>Timeout in seconds for the asynchronous execution. If None, wait indefinitely.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[RetType]</code> <p>list[RetType]: The result of the kernel method, if any.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/device.py</code> <pre><code>def run(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n    *,\n    shots: int = 1,\n    timeout: float | None = None,\n) -&gt; list[RetType]:\n    \"\"\"Runs the kernel and returns the result.\n\n    Args:\n        kernel (ir.Method):\n            The kernel method to run.\n        args (tuple[Any, ...]):\n            Positional arguments to pass to the kernel method.\n        kwargs (dict[str, Any] | None):\n            Keyword arguments to pass to the kernel method.\n        shots (int):\n            The number of times to run the kernel method.\n        timeout (float | None):\n            Timeout in seconds for the asynchronous execution. If None, wait indefinitely.\n\n    Returns:\n        list[RetType]:\n            The result of the kernel method, if any.\n\n    \"\"\"\n    return self.task(kernel, args, kwargs).run(shots=shots, timeout=timeout)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractRemoteDevice.run_async","title":"run_async","text":"<pre><code>run_async(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n    *,\n    shots: int = 1\n) -&gt; BatchFuture[RetType]\n</code></pre> <p>Runs the kernel asynchronously and returns a Future object.</p> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>Method</code> <p>The kernel method to run.</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments to pass to the kernel method.</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to pass to the kernel method.</p> <code>None</code> <code>shots</code> <code>int</code> <p>The number of times to run the kernel method.</p> <code>1</code> <p>Returns:</p> Type Description <code>BatchFuture[RetType]</code> <p>Future[list[RetType]]: The Future for all executions of the kernel method.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/device.py</code> <pre><code>def run_async(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n    *,\n    shots: int = 1,\n) -&gt; BatchFuture[RetType]:\n    \"\"\"Runs the kernel asynchronously and returns a Future object.\n\n    Args:\n        kernel (ir.Method):\n            The kernel method to run.\n        args (tuple[Any, ...]):\n            Positional arguments to pass to the kernel method.\n        kwargs (dict[str, Any] | None):\n            Keyword arguments to pass to the kernel method.\n        shots (int):\n            The number of times to run the kernel method.\n\n    Returns:\n        Future[list[RetType]]:\n            The Future for all executions of the kernel method.\n\n\n    \"\"\"\n    return self.task(kernel, args, kwargs).run_async(shots=shots)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractSimulatorDevice","title":"AbstractSimulatorDevice","text":"<p>               Bases: <code>AbstractDevice[SimulatorTaskType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.device.AbstractSimulatorDevice[AbstractSimulatorDevice]\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n                              bloqade.device.AbstractDevice --&gt; bloqade.device.AbstractSimulatorDevice\n                \n\n\n              click bloqade.device.AbstractSimulatorDevice href \"\" \"bloqade.device.AbstractSimulatorDevice\"\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre> <p>Abstract base class for simulator devices.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.AbstractSimulatorDevice.run","title":"run","text":"<pre><code>run(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n) -&gt; RetType\n</code></pre> <p>Runs the kernel and returns the result.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/device.py</code> <pre><code>def run(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n) -&gt; RetType:\n    \"\"\"Runs the kernel and returns the result.\"\"\"\n    return self.task(kernel, args, kwargs).run()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.ExpectationDeviceMixin","title":"ExpectationDeviceMixin","text":"<p>               Bases: <code>AbstractDevice[ExpectTaskType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.device.ExpectationDeviceMixin[ExpectationDeviceMixin]\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n                              bloqade.device.AbstractDevice --&gt; bloqade.device.ExpectationDeviceMixin\n                \n\n\n              click bloqade.device.ExpectationDeviceMixin href \"\" \"bloqade.device.ExpectationDeviceMixin\"\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/device/#bloqade.device.ExpectationDeviceMixin.expect","title":"expect","text":"<pre><code>expect(\n    kernel: Method[Params, RetType],\n    observable: Method[[RetType], ObsType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n    *,\n    shots: int = 1\n) -&gt; ObsType\n</code></pre> <p>Returns the expectation value of the given observable after running the task.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/device.py</code> <pre><code>def expect(\n    self,\n    kernel: ir.Method[Params, RetType],\n    observable: ir.Method[[RetType], ObsType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n    *,\n    shots: int = 1,\n) -&gt; ObsType:\n    \"\"\"Returns the expectation value of the given observable after running the task.\"\"\"\n    return self.task(kernel, args, kwargs).expect(observable, shots)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/","title":"Task","text":""},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.AbstractRemoteTask","title":"AbstractRemoteTask  <code>dataclass</code>","text":"<pre><code>AbstractRemoteTask(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n)\n</code></pre> <p>               Bases: <code>AbstractTask[Params, RetType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.task.AbstractRemoteTask[AbstractRemoteTask]\n              bloqade.task.AbstractTask[AbstractTask]\n\n                              bloqade.task.AbstractTask --&gt; bloqade.task.AbstractRemoteTask\n                \n\n\n              click bloqade.task.AbstractRemoteTask href \"\" \"bloqade.task.AbstractRemoteTask\"\n              click bloqade.task.AbstractTask href \"\" \"bloqade.task.AbstractTask\"\n            </code></pre> <p>Base class for tasks generated by the devices.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.AbstractRemoteTask.run_async","title":"run_async  <code>abstractmethod</code>","text":"<pre><code>run_async(*, shots: int = 1) -&gt; BatchFuture[RetType]\n</code></pre> <p>Executes the kernel asynchronously and returns a Future object.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>@abc.abstractmethod\ndef run_async(self, *, shots: int = 1) -&gt; BatchFuture[RetType]:\n    \"\"\"Executes the kernel asynchronously and returns a Future object.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.AbstractSimulatorTask","title":"AbstractSimulatorTask  <code>dataclass</code>","text":"<pre><code>AbstractSimulatorTask(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n)\n</code></pre> <p>               Bases: <code>AbstractTask[Params, RetType]</code>, <code>Generic[Params, RetType, StateType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.task.AbstractSimulatorTask[AbstractSimulatorTask]\n              bloqade.task.AbstractTask[AbstractTask]\n\n                              bloqade.task.AbstractTask --&gt; bloqade.task.AbstractSimulatorTask\n                \n\n\n              click bloqade.task.AbstractSimulatorTask href \"\" \"bloqade.task.AbstractSimulatorTask\"\n              click bloqade.task.AbstractTask href \"\" \"bloqade.task.AbstractTask\"\n            </code></pre> <p>Base class for tasks generated by local simulators.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.AbstractSimulatorTask.state","title":"state  <code>abstractmethod</code> <code>property</code>","text":"<pre><code>state: StateType\n</code></pre> <p>Returns the state of the simulator after running the task.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.AbstractSimulatorTask.run","title":"run  <code>abstractmethod</code>","text":"<pre><code>run() -&gt; RetType\n</code></pre> <p>Executes the kernel and returns the result.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>@abc.abstractmethod\ndef run(self) -&gt; RetType:\n    \"\"\"Executes the kernel and returns the result.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.BatchFuture","title":"BatchFuture","text":"<p>               Bases: <code>ABC</code>, <code>Generic[RetType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.task.BatchFuture[BatchFuture]\n\n              \n\n              click bloqade.task.BatchFuture href \"\" \"bloqade.task.BatchFuture\"\n            </code></pre> <p>Protocol for future objects that can be awaited.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.BatchFuture.cancel","title":"cancel","text":"<pre><code>cancel()\n</code></pre> <p>Attempts to cancel the execution of the future.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>def cancel(self):\n    \"\"\"Attempts to cancel the execution of the future.\"\"\"\n    raise NotImplementedError(\n        f\"cancel method not implemented for {self.__class__.__name__}\"\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.BatchFuture.cancelled","title":"cancelled","text":"<pre><code>cancelled() -&gt; bool\n</code></pre> <p>Returns True if the future was cancelled, False otherwise.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>def cancelled(self) -&gt; bool:\n    \"\"\"Returns True if the future was cancelled, False otherwise.\"\"\"\n    raise NotImplementedError(\n        f\"cancelled method not implemented for {self.__class__.__name__}\"\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.BatchFuture.fetch","title":"fetch  <code>abstractmethod</code>","text":"<pre><code>fetch() -&gt; None\n</code></pre> <p>Fetches the result of the future that are currently available.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>@abc.abstractmethod\ndef fetch(self) -&gt; None:\n    \"\"\"Fetches the result of the future that are currently available.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.BatchFuture.partial_result","title":"partial_result  <code>abstractmethod</code>","text":"<pre><code>partial_result() -&gt; list[RetType | MISSING_RESULT]\n</code></pre> <p>Return all results that are available so far, or MISSING_RESULT for those that are not yet available.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>@abc.abstractmethod\ndef partial_result(self) -&gt; list[RetType | MISSING_RESULT]:\n    \"\"\"Return all results that are available so far, or MISSING_RESULT for those that are not yet available.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.BatchFuture.result","title":"result  <code>abstractmethod</code>","text":"<pre><code>result(timeout: float | None) -&gt; list[RetType]\n</code></pre> <p>Returns the result of the future, blocking until it is available or the timeout expires.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>@abc.abstractmethod\ndef result(self, timeout: float | None) -&gt; list[RetType]:\n    \"\"\"Returns the result of the future, blocking until it is available or the timeout expires.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.DeviceTaskExpectMixin","title":"DeviceTaskExpectMixin  <code>dataclass</code>","text":"<pre><code>DeviceTaskExpectMixin(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n)\n</code></pre> <p>               Bases: <code>AbstractTask</code></p> <pre><code>\n              flowchart TD\n              bloqade.task.DeviceTaskExpectMixin[DeviceTaskExpectMixin]\n              bloqade.task.AbstractTask[AbstractTask]\n\n                              bloqade.task.AbstractTask --&gt; bloqade.task.DeviceTaskExpectMixin\n                \n\n\n              click bloqade.task.DeviceTaskExpectMixin href \"\" \"bloqade.task.DeviceTaskExpectMixin\"\n              click bloqade.task.AbstractTask href \"\" \"bloqade.task.AbstractTask\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/task/#bloqade.task.DeviceTaskExpectMixin.expect","title":"expect  <code>abstractmethod</code>","text":"<pre><code>expect(\n    observable: Method[[RetType], ObsType], shots: int\n) -&gt; ObsType\n</code></pre> <p>Returns the expectation value of the given observable after running the task.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/task.py</code> <pre><code>@abc.abstractmethod\ndef expect(self, observable: ir.Method[[RetType], ObsType], shots: int) -&gt; ObsType:\n    \"\"\"Returns the expectation value of the given observable after running the task.\"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/types/","title":"Types","text":"<p>Bloqade types.</p> <p>This module defines the basic types used in Bloqade eDSLs.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/types/#bloqade.types.MeasurementResultType","title":"MeasurementResultType  <code>module-attribute</code>","text":"<pre><code>MeasurementResultType = PyClass(MeasurementResult)\n</code></pre> <p>Kirin type for a measurement result.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/types/#bloqade.types.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/types/#bloqade.types.MeasurementResult","title":"MeasurementResult","text":"<p>Runtime representation of the result of a measurement on a qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/types/#bloqade.types.Qubit","title":"Qubit","text":"<p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.types.Qubit[Qubit]\n\n              \n\n              click bloqade.types.Qubit href \"\" \"bloqade.types.Qubit\"\n            </code></pre> <p>Runtime representation of a qubit.</p> Note <p>This is the base class of more specific qubit types, such as a reference to a piece of quantum register in some quantum register dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/analysis/#bloqade.analysis.address.analysis.AddressAnalysis","title":"AddressAnalysis","text":"<p>               Bases: <code>Forward[Address]</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.analysis.AddressAnalysis[AddressAnalysis]\n\n              \n\n              click bloqade.analysis.address.analysis.AddressAnalysis href \"\" \"bloqade.analysis.address.analysis.AddressAnalysis\"\n            </code></pre> <p>This analysis pass can be used to track the global addresses of qubits and wires.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/analysis/#bloqade.analysis.address.analysis.AddressAnalysis.qubit_count","title":"qubit_count  <code>property</code>","text":"<pre><code>qubit_count: int\n</code></pre> <p>Total number of qubits found by the analysis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/analysis/#bloqade.analysis.address.analysis.AddressAnalysis.run_lattice","title":"run_lattice","text":"<pre><code>run_lattice(\n    callee: Address,\n    inputs: tuple[Address, ...],\n    keys: tuple[str, ...],\n    kwargs: tuple[Address, ...],\n) -&gt; Address\n</code></pre> <p>Run a callable lattice element with the given inputs and keyword arguments.</p> <p>Parameters:</p> Name Type Description Default <code>callee</code> <code>Address</code> <p>The lattice element representing the callable.</p> required <code>inputs</code> <code>tuple[Address, ...]</code> <p>The input lattice elements.</p> required <code>kwargs</code> <code>tuple[str, ...]</code> <p>The keyword argument names.</p> required <p>Returns:</p> Name Type Description <code>Address</code> <code>Address</code> <p>The resulting lattice element after invoking the callable.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analysis/address/analysis.py</code> <pre><code>def run_lattice(\n    self,\n    callee: Address,\n    inputs: tuple[Address, ...],\n    keys: tuple[str, ...],\n    kwargs: tuple[Address, ...],\n) -&gt; Address:\n    \"\"\"Run a callable lattice element with the given inputs and keyword arguments.\n\n    Args:\n        callee (Address): The lattice element representing the callable.\n        inputs (tuple[Address, ...]): The input lattice elements.\n        kwargs (tuple[str, ...]): The keyword argument names.\n\n    Returns:\n        Address: The resulting lattice element after invoking the callable.\n\n    \"\"\"\n\n    match callee:\n        case PartialLambda(code=code):\n            _, ret = self.call(\n                code, callee, *inputs, **{k: v for k, v in zip(keys, kwargs)}\n            )\n        case ConstResult(const.Value(ir.Method() as method)):\n            _, ret = self.call(\n                method.code,\n                self.method_self(method),\n                *inputs,\n                **{k: v for k, v in zip(keys, kwargs)},\n            )\n            return ret\n        case _:\n            return Address.top()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/analysis/#bloqade.analysis.address.analysis.AddressAnalysis.unpack_iterable","title":"unpack_iterable","text":"<pre><code>unpack_iterable(iterable: Address)\n</code></pre> <p>Extract the values of a container lattice element.</p> <p>Parameters:</p> Name Type Description Default <code>iterable</code> <code>Address</code> <p>The lattice element representing a container.</p> required <p>Returns:</p> Type Description <p>A tuple of the container type and the contained values.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/analysis/address/analysis.py</code> <pre><code>def unpack_iterable(self, iterable: Address):\n    \"\"\"Extract the values of a container lattice element.\n\n    Args:\n        iterable: The lattice element representing a container.\n\n    Returns:\n        A tuple of the container type and the contained values.\n\n    \"\"\"\n\n    def from_constant(constant: const.Result) -&gt; Address:\n        return ConstResult(constant)\n\n    def from_literal(literal: Any) -&gt; Address:\n        return ConstResult(const.Value(literal))\n\n    match iterable:\n        case PartialIList(data):\n            return PartialIList, data\n        case PartialTuple(data):\n            return PartialTuple, data\n        case AddressReg():\n            return PartialIList, iterable.qubits\n        case ConstResult(const.Value(IList() as data)):\n            return PartialIList, tuple(map(from_literal, data))\n        case ConstResult(const.Value(tuple() as data)):\n            return PartialTuple, tuple(map(from_literal, data))\n        case ConstResult(const.PartialTuple(data)):\n            return PartialTuple, tuple(map(from_constant, data))\n        case _:\n            return None, ()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/impls/","title":"Impls","text":"<p>qubit.address method table for a few builtin dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.AddressQubit","title":"AddressQubit  <code>dataclass</code>","text":"<pre><code>AddressQubit(data: int)\n</code></pre> <p>               Bases: <code>QubitLike</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.AddressQubit[AddressQubit]\n              bloqade.analysis.address.lattice.QubitLike[QubitLike]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.QubitLike --&gt; bloqade.analysis.address.lattice.AddressQubit\n                                bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.QubitLike\n                \n\n\n\n              click bloqade.analysis.address.lattice.AddressQubit href \"\" \"bloqade.analysis.address.lattice.AddressQubit\"\n              click bloqade.analysis.address.lattice.QubitLike href \"\" \"bloqade.analysis.address.lattice.QubitLike\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing a single qubit with a known address.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.AddressReg","title":"AddressReg  <code>dataclass</code>","text":"<pre><code>AddressReg(data: Sequence[int])\n</code></pre> <p>               Bases: <code>RegisterLike</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.AddressReg[AddressReg]\n              bloqade.analysis.address.lattice.RegisterLike[RegisterLike]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.RegisterLike --&gt; bloqade.analysis.address.lattice.AddressReg\n                                bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.RegisterLike\n                \n\n\n\n              click bloqade.analysis.address.lattice.AddressReg href \"\" \"bloqade.analysis.address.lattice.AddressReg\"\n              click bloqade.analysis.address.lattice.RegisterLike href \"\" \"bloqade.analysis.address.lattice.RegisterLike\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing a container of qubits with known indices.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.Bottom","title":"Bottom  <code>dataclass</code>","text":"<pre><code>Bottom()\n</code></pre> <p>               Bases: <code>Address</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.Bottom[Bottom]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.Bottom\n                \n\n\n              click bloqade.analysis.address.lattice.Bottom href \"\" \"bloqade.analysis.address.lattice.Bottom\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>Error during interpretation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.ConstResult","title":"ConstResult  <code>dataclass</code>","text":"<pre><code>ConstResult(result: Result)\n</code></pre> <p>               Bases: <code>Address</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.ConstResult[ConstResult]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.ConstResult\n                \n\n\n              click bloqade.analysis.address.lattice.ConstResult href \"\" \"bloqade.analysis.address.lattice.ConstResult\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>Stores a constant prop result in the lattice</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.PartialIList","title":"PartialIList  <code>dataclass</code>","text":"<pre><code>PartialIList(data: tuple[Address, ...])\n</code></pre> <p>               Bases: <code>StaticContainer</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.PartialIList[PartialIList]\n              bloqade.analysis.address.lattice.StaticContainer[StaticContainer]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.StaticContainer --&gt; bloqade.analysis.address.lattice.PartialIList\n                                bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.StaticContainer\n                \n\n\n\n              click bloqade.analysis.address.lattice.PartialIList href \"\" \"bloqade.analysis.address.lattice.PartialIList\"\n              click bloqade.analysis.address.lattice.StaticContainer href \"\" \"bloqade.analysis.address.lattice.StaticContainer\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing a partially known ilist.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.PartialIListMeta","title":"PartialIListMeta","text":"<p>               Bases: <code>LatticeAttributeMeta</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.PartialIListMeta[PartialIListMeta]\n\n              \n\n              click bloqade.analysis.address.lattice.PartialIListMeta href \"\" \"bloqade.analysis.address.lattice.PartialIListMeta\"\n            </code></pre> <p>This metaclass assures that PartialILists of ConstResults or AddressQubits are canonicalized to a single ConstResult or AddressReg respectively.</p> <p>because AddressReg is a specialization of PartialIList, being a container of pure qubit addresses. For Operations that act in generic containers (e.g., ilist.ForEach), AddressReg is treated as PartialIList but for other types of analysis it is often useful to distinguish between a generic IList and a pure qubit address list.</p> <p>Inside the method tables the <code>GetValuesMixin</code> implements a method that effectively undoes this canonicalization.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.PartialLambda","title":"PartialLambda  <code>dataclass</code>","text":"<pre><code>PartialLambda(\n    argnames: list[str],\n    code: Statement,\n    captured: tuple[Address, ...],\n)\n</code></pre> <p>               Bases: <code>Address</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.PartialLambda[PartialLambda]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.PartialLambda\n                \n\n\n              click bloqade.analysis.address.lattice.PartialLambda href \"\" \"bloqade.analysis.address.lattice.PartialLambda\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>Represents a partially known lambda function</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.PartialTuple","title":"PartialTuple  <code>dataclass</code>","text":"<pre><code>PartialTuple(data: tuple[Address, ...])\n</code></pre> <p>               Bases: <code>StaticContainer</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.PartialTuple[PartialTuple]\n              bloqade.analysis.address.lattice.StaticContainer[StaticContainer]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.StaticContainer --&gt; bloqade.analysis.address.lattice.PartialTuple\n                                bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.StaticContainer\n                \n\n\n\n              click bloqade.analysis.address.lattice.PartialTuple href \"\" \"bloqade.analysis.address.lattice.PartialTuple\"\n              click bloqade.analysis.address.lattice.StaticContainer href \"\" \"bloqade.analysis.address.lattice.StaticContainer\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing a partially known tuple.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.PartialTupleMeta","title":"PartialTupleMeta","text":"<p>               Bases: <code>LatticeAttributeMeta</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.PartialTupleMeta[PartialTupleMeta]\n\n              \n\n              click bloqade.analysis.address.lattice.PartialTupleMeta href \"\" \"bloqade.analysis.address.lattice.PartialTupleMeta\"\n            </code></pre> <p>This metaclass assures that PartialTuples of ConstResults are canonicalized to a single ConstResult.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.StaticContainer","title":"StaticContainer  <code>dataclass</code>","text":"<pre><code>StaticContainer(data: tuple[Address, ...])\n</code></pre> <p>               Bases: <code>Address</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.StaticContainer[StaticContainer]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.StaticContainer\n                \n\n\n              click bloqade.analysis.address.lattice.StaticContainer href \"\" \"bloqade.analysis.address.lattice.StaticContainer\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing the results of any static container, e. g. ilist or tuple.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.Unknown","title":"Unknown  <code>dataclass</code>","text":"<pre><code>Unknown()\n</code></pre> <p>               Bases: <code>Address</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.Unknown[Unknown]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.Unknown\n                \n\n\n              click bloqade.analysis.address.lattice.Unknown href \"\" \"bloqade.analysis.address.lattice.Unknown\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>Can't determine if it is an address or constant.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.UnknownQubit","title":"UnknownQubit  <code>dataclass</code>","text":"<pre><code>UnknownQubit()\n</code></pre> <p>               Bases: <code>QubitLike</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.UnknownQubit[UnknownQubit]\n              bloqade.analysis.address.lattice.QubitLike[QubitLike]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.QubitLike --&gt; bloqade.analysis.address.lattice.UnknownQubit\n                                bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.QubitLike\n                \n\n\n\n              click bloqade.analysis.address.lattice.UnknownQubit href \"\" \"bloqade.analysis.address.lattice.UnknownQubit\"\n              click bloqade.analysis.address.lattice.QubitLike href \"\" \"bloqade.analysis.address.lattice.QubitLike\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing a single qubit with an unknown address.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/address/lattice/#bloqade.analysis.address.lattice.UnknownReg","title":"UnknownReg  <code>dataclass</code>","text":"<pre><code>UnknownReg()\n</code></pre> <p>               Bases: <code>RegisterLike</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.address.lattice.UnknownReg[UnknownReg]\n              bloqade.analysis.address.lattice.RegisterLike[RegisterLike]\n              bloqade.analysis.address.lattice.Address[Address]\n\n                              bloqade.analysis.address.lattice.RegisterLike --&gt; bloqade.analysis.address.lattice.UnknownReg\n                                bloqade.analysis.address.lattice.Address --&gt; bloqade.analysis.address.lattice.RegisterLike\n                \n\n\n\n              click bloqade.analysis.address.lattice.UnknownReg href \"\" \"bloqade.analysis.address.lattice.UnknownReg\"\n              click bloqade.analysis.address.lattice.RegisterLike href \"\" \"bloqade.analysis.address.lattice.RegisterLike\"\n              click bloqade.analysis.address.lattice.Address href \"\" \"bloqade.analysis.address.lattice.Address\"\n            </code></pre> <p>A lattice element representing a container of qubits with unknown indices.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/fidelity/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/fidelity/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/fidelity/analysis/#bloqade.analysis.fidelity.analysis.FidelityAnalysis","title":"FidelityAnalysis","text":"<p>               Bases: <code>Forward</code></p> <pre><code>\n              flowchart TD\n              bloqade.analysis.fidelity.analysis.FidelityAnalysis[FidelityAnalysis]\n\n              \n\n              click bloqade.analysis.fidelity.analysis.FidelityAnalysis href \"\" \"bloqade.analysis.fidelity.analysis.FidelityAnalysis\"\n            </code></pre> <p>This analysis pass can be used to track the global addresses of qubits and wires.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/fidelity/analysis/#bloqade.analysis.fidelity.analysis.FidelityAnalysis--usage-examples","title":"Usage examples","text":"<pre><code>from bloqade import qasm2\nfrom bloqade.noise import native\nfrom bloqade.analysis.fidelity import FidelityAnalysis\nfrom bloqade.qasm2.passes.noise import NoisePass\n\nnoise_main = qasm2.extended.add(native.dialect)\n\n@noise_main\ndef main():\n    q = qasm2.qreg(2)\n    qasm2.x(q[0])\n    return q\n\nNoisePass(main.dialects)(main)\n\nfid_analysis = FidelityAnalysis(main.dialects)\nfid_analysis.run_analysis(main, no_raise=False)\n\ngate_fidelity = fid_analysis.gate_fidelity\natom_survival_probs = fid_analysis.atom_survival_probability\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/fidelity/analysis/#bloqade.analysis.fidelity.analysis.FidelityAnalysis.atom_survival_probability","title":"atom_survival_probability  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>atom_survival_probability: list[float] = field(init=False)\n</code></pre> <p>The probabilities that each of the atoms in the register survive the duration of the analysed program. The order of the list follows the order they are in the register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/fidelity/analysis/#bloqade.analysis.fidelity.analysis.FidelityAnalysis.gate_fidelity","title":"gate_fidelity  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>gate_fidelity: float = 1.0\n</code></pre> <p>The fidelity of the gate set described by the analysed program. It reduces whenever a noise channel is encountered.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/analysis/measure_id/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/measure_id/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/measure_id/impls/","title":"Impls","text":""},{"location":"reference/bloqade-circuit/src/bloqade/analysis/measure_id/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade-circuit/src/bloqade/annotate/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/annotate/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/annotate/types/","title":"Types","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lineprog/","title":"Lineprog","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lineprog/#bloqade.cirq_utils.lineprog.LPProblem","title":"LPProblem  <code>dataclass</code>","text":"<pre><code>LPProblem(\n    constraints_eqz: list[Expression] = list(),\n    constraints_gez: list[Expression] = list(),\n    linear_objective: Expression = (\n        lambda: Expression({})\n    )(),\n    quadratic_objective: list[Expression] = list(),\n)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lineprog/#bloqade.cirq_utils.lineprog.LPProblem.add_abs","title":"add_abs","text":"<pre><code>add_abs(expr: Expression)\n</code></pre> <p>Use a slack variable to add an absolute value constraint.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/lineprog.py</code> <pre><code>def add_abs(self, expr: Expression):\n    \"\"\"\n    Use a slack variable to add an absolute value constraint.\n    \"\"\"\n    slack = Variable()\n    self.add_gez(slack - expr)\n    self.add_gez(slack + expr)\n    self.add_gez(1.0 * slack)\n    self.add_linear(1.0 * slack)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lowering/#bloqade.cirq_utils.lowering.Squin","title":"Squin  <code>dataclass</code>","text":"<pre><code>Squin(circuit: Circuit)\n</code></pre> <p>               Bases: <code>LoweringABC[Circuit]</code></p> <pre><code>\n              flowchart TD\n              bloqade.cirq_utils.lowering.Squin[Squin]\n\n              \n\n              click bloqade.cirq_utils.lowering.Squin href \"\" \"bloqade.cirq_utils.lowering.Squin\"\n            </code></pre> <p>Lower a cirq.Circuit object to a squin kernel</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lowering/#bloqade.cirq_utils.lowering.load_circuit","title":"load_circuit","text":"<pre><code>load_circuit(\n    circuit: Circuit,\n    kernel_name: str = \"main\",\n    dialects: DialectGroup = kernel,\n    register_as_argument: bool = False,\n    return_register: bool = False,\n    register_argument_name: str = \"q\",\n    globals: dict[str, Any] | None = None,\n    file: str | None = None,\n    lineno_offset: int = 0,\n    col_offset: int = 0,\n    compactify: bool = True,\n)\n</code></pre> <p>Converts a cirq.Circuit object into a squin kernel.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The circuit to load.</p> required <p>Other Parameters:</p> Name Type Description <code>kernel_name</code> <code>str</code> <p>The name of the kernel to load. Defaults to \"main\".</p> <code>dialects</code> <code>DialectGroup | None</code> <p>The dialects to use. Defaults to <code>squin.kernel</code>.</p> <code>register_as_argument</code> <code>bool</code> <p>Determine whether the resulting kernel function should accept a single <code>ilist.IList[Qubit, Any]</code> argument that is a list of qubits used within the function. This allows you to compose kernel functions generated from circuits. Defaults to <code>False</code>.</p> <code>return_register</code> <code>bool</code> <p>Determine whether the resulting kernel functionr returns a single value of type <code>ilist.IList[Qubit, Any]</code> that is the list of qubits used in the kernel function. Useful when you want to compose multiple kernel functions generated from circuits. Defaults to <code>False</code>.</p> <code>register_argument_name</code> <code>str</code> <p>The name of the argument that represents the qubit register. Only used when <code>register_as_argument=True</code>. Defaults to \"q\".</p> <code>globals</code> <code>dict[str, Any] | None</code> <p>The global variables to use. Defaults to None.</p> <code>file</code> <code>str | None</code> <p>The file name for error reporting. Defaults to None.</p> <code>lineno_offset</code> <code>int</code> <p>The line number offset for error reporting. Defaults to 0.</p> <code>col_offset</code> <code>int</code> <p>The column number offset for error reporting. Defaults to 0.</p> <code>compactify</code> <code>bool</code> <p>Whether to compactify the output. Defaults to True.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/lowering/#bloqade.cirq_utils.lowering.load_circuit--usage-examples","title":"Usage Examples:","text":"<pre><code># from cirq's \"hello qubit\" example\nimport cirq\nfrom bloqade.cirq_utils import load_circuit\n\n# Pick a qubit.\nqubit = cirq.GridQubit(0, 0)\n\n# Create a circuit.\ncircuit = cirq.Circuit(\n    cirq.X(qubit)**0.5,  # Square root of NOT.\n    cirq.measure(qubit, key='m')  # Measurement.\n)\n\n# load the circuit as squin\nmain = load_circuit(circuit)\n\n# print the resulting IR\nmain.print()\n</code></pre> <p>You can also compose kernel functions generated from circuits by passing in and / or returning the respective quantum registers:</p> <pre><code>import cirq\nfrom bloqade.cirq_utils import load_circuit\nfrom bloqade import squin\n\nq = cirq.LineQubit.range(2)\ncircuit = cirq.Circuit(cirq.H(q[0]), cirq.CX(*q))\n\nget_entangled_qubits = load_circuit(\n    circuit, return_register=True, kernel_name=\"get_entangled_qubits\"\n)\nget_entangled_qubits.print()\n\nentangle_qubits = load_circuit(\n    circuit, register_as_argument=True, kernel_name=\"entangle_qubits\"\n)\n\n@squin.kernel\ndef main():\n    qreg = get_entangled_qubits()\n    qreg2 = squin.qalloc(1)\n    entangle_qubits([qreg[1], qreg2[0]])\n    return squin.qubit.measure(qreg2)\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/lowering.py</code> <pre><code>def load_circuit(\n    circuit: cirq.Circuit,\n    kernel_name: str = \"main\",\n    dialects: ir.DialectGroup = kernel,\n    register_as_argument: bool = False,\n    return_register: bool = False,\n    register_argument_name: str = \"q\",\n    globals: dict[str, Any] | None = None,\n    file: str | None = None,\n    lineno_offset: int = 0,\n    col_offset: int = 0,\n    compactify: bool = True,\n):\n    \"\"\"Converts a cirq.Circuit object into a squin kernel.\n\n    Args:\n        circuit (cirq.Circuit): The circuit to load.\n\n    Keyword Args:\n        kernel_name (str): The name of the kernel to load. Defaults to \"main\".\n        dialects (ir.DialectGroup | None): The dialects to use. Defaults to `squin.kernel`.\n        register_as_argument (bool): Determine whether the resulting kernel function should accept\n            a single `ilist.IList[Qubit, Any]` argument that is a list of qubits used within the\n            function. This allows you to compose kernel functions generated from circuits.\n            Defaults to `False`.\n        return_register (bool): Determine whether the resulting kernel functionr returns a\n            single value of type `ilist.IList[Qubit, Any]` that is the list of qubits used\n            in the kernel function. Useful when you want to compose multiple kernel functions\n            generated from circuits. Defaults to `False`.\n        register_argument_name (str): The name of the argument that represents the qubit register.\n            Only used when `register_as_argument=True`. Defaults to \"q\".\n        globals (dict[str, Any] | None): The global variables to use. Defaults to None.\n        file (str | None): The file name for error reporting. Defaults to None.\n        lineno_offset (int): The line number offset for error reporting. Defaults to 0.\n        col_offset (int): The column number offset for error reporting. Defaults to 0.\n        compactify (bool): Whether to compactify the output. Defaults to True.\n\n    ## Usage Examples:\n\n    ```python\n    # from cirq's \"hello qubit\" example\n    import cirq\n    from bloqade.cirq_utils import load_circuit\n\n    # Pick a qubit.\n    qubit = cirq.GridQubit(0, 0)\n\n    # Create a circuit.\n    circuit = cirq.Circuit(\n        cirq.X(qubit)**0.5,  # Square root of NOT.\n        cirq.measure(qubit, key='m')  # Measurement.\n    )\n\n    # load the circuit as squin\n    main = load_circuit(circuit)\n\n    # print the resulting IR\n    main.print()\n    ```\n\n    You can also compose kernel functions generated from circuits by passing in\n    and / or returning the respective quantum registers:\n\n    ```python\n    import cirq\n    from bloqade.cirq_utils import load_circuit\n    from bloqade import squin\n\n    q = cirq.LineQubit.range(2)\n    circuit = cirq.Circuit(cirq.H(q[0]), cirq.CX(*q))\n\n    get_entangled_qubits = load_circuit(\n        circuit, return_register=True, kernel_name=\"get_entangled_qubits\"\n    )\n    get_entangled_qubits.print()\n\n    entangle_qubits = load_circuit(\n        circuit, register_as_argument=True, kernel_name=\"entangle_qubits\"\n    )\n\n    @squin.kernel\n    def main():\n        qreg = get_entangled_qubits()\n        qreg2 = squin.qalloc(1)\n        entangle_qubits([qreg[1], qreg2[0]])\n        return squin.qubit.measure(qreg2)\n    ```\n    \"\"\"\n\n    target = Squin(dialects, circuit)\n    body = target.run(\n        circuit,\n        source=str(circuit),  # TODO: proper source string\n        file=file,\n        globals=globals,\n        lineno_offset=lineno_offset,\n        col_offset=col_offset,\n        compactify=compactify,\n        register_as_argument=register_as_argument,\n        register_argument_name=register_argument_name,\n    )\n\n    if return_register:\n        return_value = target.qreg\n    else:\n        return_value = func.ConstantNone()\n        body.blocks[0].stmts.append(return_value)\n\n    return_node = func.Return(value_or_stmt=return_value)\n    body.blocks[0].stmts.append(return_node)\n\n    self_arg_name = kernel_name + \"_self\"\n    arg_names = [self_arg_name]\n    if register_as_argument:\n        args = (target.qreg.type,)\n        arg_names.append(register_argument_name)\n    else:\n        args = ()\n\n    # NOTE: add _self as argument; need to know signature before so do it after lowering\n    signature = func.Signature(args, return_node.value.type)\n    body.blocks[0].args.insert_from(\n        0,\n        types.Generic(ir.Method, types.Tuple.where(signature.inputs), signature.output),\n        self_arg_name,\n    )\n\n    code = func.Function(\n        sym_name=kernel_name,\n        signature=signature,\n        body=body,\n    )\n\n    mt = ir.Method(\n        sym_name=kernel_name,\n        arg_names=arg_names,\n        dialects=dialects,\n        code=code,\n    )\n\n    assert (run_pass := kernel.run_pass) is not None\n    run_pass(mt, typeinfer=True)\n\n    return mt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/","title":"Parallelize","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.auto_similarity","title":"auto_similarity","text":"<pre><code>auto_similarity(\n    circuit: Circuit, weight_1q: float, weight_2q: float\n) -&gt; tuple[cirq.Circuit, dict[Hashable, float]]\n</code></pre> <p>Automatically tag the circuit with topological basis group labels, where each group is a pair of gates that can be executed in parallel.</p> <p>Inputs: circuit - a cirq.Circuit to be analyzed. This should be CZ + PhaseXZGate, otherwise no annotation will occur. weight_1q: float - the weight to assign to single-qubit gates. weight_2q: float - the weight to assign to two-qubit gates.</p> <p>Returns: [0] - the cirq.Circuit with each gate annotated with topological similarity tags. [1] - a dictionary mapping each tag to its weight, where the key is the tag and the value is the weight.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def auto_similarity(\n    circuit: cirq.Circuit, weight_1q: float, weight_2q: float\n) -&gt; tuple[cirq.Circuit, dict[Hashable, float]]:\n    \"\"\"\n    Automatically tag the circuit with topological basis group labels,\n    where each group is a pair of gates that can be executed in parallel.\n\n    Inputs:\n    circuit - a cirq.Circuit to be analyzed. This should be CZ + PhaseXZGate, otherwise no annotation will occur.\n    weight_1q: float - the weight to assign to single-qubit gates.\n    weight_2q: float - the weight to assign to two-qubit gates.\n\n    Returns:\n    [0] - the cirq.Circuit with each gate annotated with topological similarity tags.\n    [1] - a dictionary mapping each tag to its weight, where the key is the tag and the value is the weight.\n    \"\"\"\n    flattened_circuit: list[GateOperation] = list(cirq.flatten_op_tree(circuit))\n    weights = {}\n    for i in range(len(flattened_circuit)):\n        for j in range(i + 1, len(flattened_circuit)):\n            op1 = flattened_circuit[i]\n            op2 = flattened_circuit[j]\n            if can_be_parallel(op1, op2):\n                # Add tags to both operations\n                tag = f\"AUTO:{i}\"\n                flattened_circuit[i] = op1.with_tags(tag)\n                flattened_circuit[j] = op2.with_tags(tag)\n                if len(op1.qubits) == 1:\n                    weights[tag] = weight_1q\n                elif len(op1.qubits) == 2:\n                    weights[tag] = weight_2q\n                else:\n                    raise RuntimeError(\"Unsupported gate type\")\n    return cirq.Circuit(flattened_circuit), weights\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.block_similarity","title":"block_similarity","text":"<pre><code>block_similarity(\n    circuit: Circuit, weight: float, block_id: int\n) -&gt; tuple[cirq.Circuit, dict[Hashable, float]]\n</code></pre> <p>Associate every gate in a circuit with a similarity group.</p> <p>Inputs: circuit - a cirq.Circuit to be analyzed. weight: float - the weight to assign to each block of gates.</p> <p>Returns: [0] - the cirq.Circuit with each gate annotated with topological similarity tags. [1] - a dictionary mapping each tag to its weight, where the key is the tag and the value is the weight.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def block_similarity(\n    circuit: cirq.Circuit, weight: float, block_id: int\n) -&gt; tuple[cirq.Circuit, dict[Hashable, float]]:\n    \"\"\"\n    Associate every gate in a circuit with a similarity group.\n\n    Inputs:\n    circuit - a cirq.Circuit to be analyzed.\n    weight: float - the weight to assign to each block of gates.\n\n    Returns:\n    [0] - the cirq.Circuit with each gate annotated with topological similarity tags.\n    [1] - a dictionary mapping each tag to its weight, where the key is the tag and the value is the weight.\n    \"\"\"\n    new_moments = []\n    weights = {}\n    tag = f\"BLOCK:{block_id}\"\n    for moment in circuit.moments:\n        new_moments.append([gate.with_tags(tag) for gate in moment.operations])\n    weights[tag] = weight\n    return cirq.Circuit(new_moments), weights\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.can_be_parallel","title":"can_be_parallel","text":"<pre><code>can_be_parallel(\n    op1: GateOperation,\n    op2: GateOperation,\n    tol: float = 1e-14,\n) -&gt; bool\n</code></pre> <p>Heuristic similarity function to determine if two operations are similar enough to be grouped together in parallel execution.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def can_be_parallel(\n    op1: cirq.GateOperation, op2: cirq.GateOperation, tol: float = 1e-14\n) -&gt; bool:\n    \"\"\"\n    Heuristic similarity function to determine if two operations are similar enough\n    to be grouped together in parallel execution.\n    \"\"\"\n    are_disjoint = len(set(op1.qubits).intersection(op2.qubits)) == 0\n    if not are_disjoint:\n        return False\n\n    # Check if both operations are CZ gates\n    both_cz = op1.gate == cirq.CZ and op2.gate == cirq.CZ\n\n    both_phased_xz = isinstance(op1.gate, cirq.PhasedXZGate) and isinstance(\n        op2.gate, cirq.PhasedXZGate\n    )\n    equal_unitaries = cirq.equal_up_to_global_phase(\n        cirq.unitary(op1.gate), cirq.unitary(op2.gate), atol=tol\n    )\n\n    return (both_phased_xz and equal_unitaries) or both_cz\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.colorize","title":"colorize","text":"<pre><code>colorize(epochs: Iterable[list[Unique[GateOperation]]])\n</code></pre> <p>For each epoch, separate any 1q and 2q gates, and colorize the 2q gates so that they can be executed in parallel without conflicts. Args:     epochs: list[list[Unique[cirq.GateOperation]]] - a list of epochs, where each         epoch is a list of gates that can be executed in parallel.</p> <p>Yields:</p> Type Description <p>list[cirq.GateOperation] - a list of lists of gates, where each inner list contains gates that can be executed in parallel.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def colorize(\n    epochs: Iterable[list[Unique[cirq.GateOperation]]],\n):\n    \"\"\"\n    For each epoch, separate any 1q and 2q gates, and colorize the 2q gates\n    so that they can be executed in parallel without conflicts.\n    Args:\n        epochs: list[list[Unique[cirq.GateOperation]]] - a list of epochs, where each\n            epoch is a list of gates that can be executed in parallel.\n\n    Yields:\n        list[cirq.GateOperation] - a list of lists of gates, where each\n            inner list contains gates that can be executed in parallel.\n\n    \"\"\"\n    for epoch in epochs:\n        oneq_gates = []\n        twoq_gates = []\n        for gate in epoch:\n            if len(gate.val.qubits) == 1:\n                oneq_gates.append(gate.val)\n            elif len(gate.val.qubits) == 2:\n                twoq_gates.append(gate.val)\n            else:\n                raise RuntimeError(\"Unsupported gate type\")\n\n        if len(oneq_gates) &gt; 0:\n            yield oneq_gates\n\n        # twoq_gates2 = colorizer(twoq_gates)# Inlined.\n        \"\"\"\n        Implements an edge coloring algorithm on a set of simultaneous 2q gates,\n        so that they can be done in an ordered manner so that no to gates use\n        the same qubit in the same layer.\n        \"\"\"\n        graph = nx.Graph()\n        for gate in twoq_gates:\n            if len(gate.qubits) != 2 and gate.gate != cirq.CZ:\n                raise RuntimeError(\"Unsupported gate type\")\n            graph.add_edge(gate.qubits[0], gate.qubits[1])\n        linegraph = nx.line_graph(graph)\n\n        best_colors: dict[tuple[cirq.Qid, cirq.Qid], int] = (\n            nx.algorithms.coloring.greedy_color(linegraph, strategy=\"largest_first\")\n        )\n        best_num_colors = len(set(best_colors.values()))\n\n        for strategy in (\n            #'random_sequential',\n            \"smallest_last\",\n            \"independent_set\",\n            \"connected_sequential_bfs\",\n            \"connected_sequential_dfs\",\n            \"saturation_largest_first\",\n        ):\n            colors: dict[tuple[cirq.Qid, cirq.Qid], int] = (\n                nx.algorithms.coloring.greedy_color(linegraph, strategy=strategy)\n            )\n            if (num_colors := len(set(colors.values()))) &lt; best_num_colors:\n                best_num_colors = num_colors\n                best_colors = colors\n\n        twoq_gates2 = (\n            list(cirq.CZ(*k) for k, v in best_colors.items() if v == x)\n            for x in set(best_colors.values())\n        )\n        # -- end colorizer --\n        yield from twoq_gates2\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.generate_epochs","title":"generate_epochs","text":"<pre><code>generate_epochs(solution: dict[NodeType, float], tol=0.01)\n</code></pre> <p>Internal function to generate epochs from the solution of the linear program.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def generate_epochs(\n    solution: dict[NodeType, float],\n    tol=1e-2,\n):\n    \"\"\"\n    Internal function to generate epochs from the solution of the linear program.\n    \"\"\"\n    sorted_gates = sorted(solution.items(), key=lambda x: x[1])\n    if len(sorted_gates) == 0:\n        return iter([])\n\n    gate, latest_time = sorted_gates[0]\n    current_epoch = [gate]  # Start with the first gate\n    for gate, time in sorted_gates[1:]:\n        if time - latest_time &lt; tol:\n            current_epoch.append(gate)\n        else:\n            yield current_epoch\n            current_epoch = [gate]\n\n        latest_time = time\n\n    yield current_epoch  # Yield the last epoch\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.moment_similarity","title":"moment_similarity","text":"<pre><code>moment_similarity(\n    circuit: Circuit, weight: float\n) -&gt; tuple[cirq.Circuit, dict[Hashable, float]]\n</code></pre> <p>Associate every gate in each moment with a similarity group.</p> <p>Inputs: circuit - a cirq.Circuit to be analyzed. weight: float - the weight to assign to each block of gates.</p> <p>Returns: [0] - the cirq.Circuit with each gate annotated with topological similarity tags. [1] - a dictionary mapping each tag to its weight, where the key is the tag and the value is the weight.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def moment_similarity(\n    circuit: cirq.Circuit, weight: float\n) -&gt; tuple[cirq.Circuit, dict[Hashable, float]]:\n    \"\"\"\n    Associate every gate in each moment with a similarity group.\n\n    Inputs:\n    circuit - a cirq.Circuit to be analyzed.\n    weight: float - the weight to assign to each block of gates.\n\n    Returns:\n    [0] - the cirq.Circuit with each gate annotated with topological similarity tags.\n    [1] - a dictionary mapping each tag to its weight, where the key is the tag and the value is the weight.\n    \"\"\"\n    new_moments = []\n    weights = {}\n\n    for moment_index, moment in enumerate(circuit.moments):\n        tag = f\"MOMENT:{moment_index}\"\n        new_moments.append([gate.with_tags(tag) for gate in moment.operations])\n        weights[tag] = weight\n    return cirq.Circuit(new_moments), weights\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.parallelize","title":"parallelize","text":"<pre><code>parallelize(\n    circuit: Circuit,\n    hyperparameters: dict[str, float] | None = None,\n    auto_tag: bool = True,\n) -&gt; cirq.Circuit\n</code></pre> <p>Use linear programming to reorder a circuit so that it may be optimally be run in parallel. This is done using a DAG representation, as well as a heuristic similarity function to group parallelizable gates together.</p> <p>Extra topological information (similarity) can be used by tagging each gate with the topological basis groups that it belongs to, for example</p> <p>circuit.append(cirq.H(qubits[0]).with_tags(1,2,3,4)) represents that this gate is part of the topological basis groups 1,2,3, and 4.</p> Inputs <p>circuit: cirq.Circuit - the static circuit to be optimized hyperparameters: dict[str, float] - hyperparameters for the optimization     - \"linear\": float (0.01) - the linear cost of each gate     - \"1q\": float (1.0)  - the quadratic cost of 1q gates     - \"2q\": float (2.0)  - the quadratic cost of 2q gates     - \"tags\": float (0.5) - the default weight of the topological basis.</p> <p>Returns:     cirq.Circuit - the optimized circuit, where each moment is as parallel as possible.       it is also broken into native CZ gate set of {CZ, PhXZ}</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def parallelize(\n    circuit: cirq.Circuit,\n    hyperparameters: dict[str, float] | None = None,\n    auto_tag: bool = True,\n) -&gt; cirq.Circuit:\n    \"\"\"\n    Use linear programming to reorder a circuit so that it may be optimally be\n    run in parallel. This is done using a DAG representation, as well as a heuristic\n    similarity function to group parallelizable gates together.\n\n    Extra topological information (similarity) can be used by tagging each gate with\n    the topological basis groups that it belongs to, for example\n    &gt; circuit.append(cirq.H(qubits[0]).with_tags(1,2,3,4))\n    represents that this gate is part of the topological basis groups 1,2,3, and 4.\n\n    Inputs:\n        circuit: cirq.Circuit - the static circuit to be optimized\n        hyperparameters: dict[str, float] - hyperparameters for the optimization\n            - \"linear\": float (0.01) - the linear cost of each gate\n            - \"1q\": float (1.0)  - the quadratic cost of 1q gates\n            - \"2q\": float (2.0)  - the quadratic cost of 2q gates\n            - \"tags\": float (0.5) - the default weight of the topological basis.\n    Returns:\n        cirq.Circuit - the optimized circuit, where each moment is as parallel as possible.\n          it is also broken into native CZ gate set of {CZ, PhXZ}\n    \"\"\"\n    hyperparameters = _get_hyperparameters(hyperparameters)\n\n    # Transpile the circuit to a native CZ gate set.\n    transpiled_circuit = transpile(circuit)\n    if auto_tag:\n        # Annotate the circuit with topological information\n        # to improve parallelization\n        transpiled_circuit, group_weights = auto_similarity(\n            transpiled_circuit,\n            weight_1q=hyperparameters.get(\"1q\", 1.0),\n            weight_2q=hyperparameters.get(\"2q\", 1.0),\n        )\n    else:\n        group_weights = {}\n    epochs = colorize(\n        generate_epochs(\n            solve_epochs(\n                directed=to_dag_circuit(transpiled_circuit),\n                group_weights=group_weights,\n                hyperparameters=hyperparameters,\n            )\n        )\n    )\n    # Convert the epochs to a cirq circuit.\n    moments = map(cirq.Moment, epochs)\n    circuit = cirq.Circuit(moments)\n\n    return remove_tags(circuit)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.remove_tags","title":"remove_tags","text":"<pre><code>remove_tags(circuit: Circuit) -&gt; cirq.Circuit\n</code></pre> <p>Removes all tags from the circuit</p> <p>Inputs: circuit: cirq.Circuit - the circuit to remove tags from.</p> <p>Returns: [0] - cirq.Circuit - the circuit with all tags removed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def remove_tags(circuit: cirq.Circuit) -&gt; cirq.Circuit:\n    \"\"\"\n    Removes all tags from the circuit\n\n    Inputs:\n    circuit: cirq.Circuit - the circuit to remove tags from.\n\n    Returns:\n    [0] - cirq.Circuit - the circuit with all tags removed.\n    \"\"\"\n\n    def remove_tag(op: cirq.Operation, _):\n        return op.untagged\n\n    return cirq.map_operations(circuit, remove_tag)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.solve_epochs","title":"solve_epochs","text":"<pre><code>solve_epochs(\n    directed: DiGraph,\n    group_weights: dict[Hashable, float],\n    hyperparameters: dict[str, float] | None = None,\n) -&gt; dict[Unique[cirq.GateOperation], float]\n</code></pre> <p>Internal function to solve the epochs using linear programming.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def solve_epochs(\n    directed: nx.DiGraph,\n    group_weights: dict[Hashable, float],\n    hyperparameters: dict[str, float] | None = None,\n) -&gt; dict[Unique[cirq.GateOperation], float]:\n    \"\"\"\n    Internal function to solve the epochs using linear programming.\n    \"\"\"\n\n    hyperparameters = _get_hyperparameters(hyperparameters)\n\n    basis = {node: Variable() for node in directed.nodes}\n\n    if len(basis) == 0:\n        return {}\n\n    # ---\n    # Turn into a linear program to solve\n    # ---\n    lp = LPProblem()\n\n    # All timesteps must be positive\n    for node in directed.nodes:\n        lp.add_gez(1.0 * basis[node])\n\n    # Add ordering constraints\n    for edge in directed.edges:\n        lp.add_gez(basis[edge[1]] - basis[edge[0]] - 1.0)\n\n    all_variables = list(basis.values())\n    # Add linear objective: minimize the total time\n    objective = hyperparameters[\"linear\"] * sum(all_variables[1:], all_variables[0])\n\n    default_weight = hyperparameters[\"tags\"]\n    lp.add_linear(objective)\n    # Add ABS objective: similarity wants to go together.\n    for node1, node2 in combinations(directed.nodes, 2):\n        # Topological (user) similarity:\n        inter = set(node1.val.tags).intersection(set(node2.val.tags))\n        if len(inter) &gt; 0:\n            weight = sum([group_weights.get(key, default_weight) for key in inter])\n            if weight &gt; 0:\n                lp.add_abs((basis[node1] - basis[node2]) * weight)\n            elif weight &lt; 0:\n                raise RuntimeError(\"Weights must be positive\")\n\n    solution = lp.solve()\n    return {node: solution[basis[node]] for node in directed.nodes}\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.to_dag_circuit","title":"to_dag_circuit","text":"<pre><code>to_dag_circuit(\n    circuit: Circuit, can_reorder=None\n) -&gt; nx.DiGraph\n</code></pre> <p>Convert a cirq.Circuit to a directed acyclic graph (DAG) representation. This is useful for analyzing the circuit structure and dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>cirq.Circuit - the circuit to convert.</p> required <code>can_reorder</code> <p>function - a function that checks if two operations can be reordered.</p> <code>None</code> <p>Returns: [0] - nx.DiGraph - the directed acyclic graph representation of the circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def to_dag_circuit(circuit: cirq.Circuit, can_reorder=None) -&gt; nx.DiGraph:\n    \"\"\"\n    Convert a cirq.Circuit to a directed acyclic graph (DAG) representation.\n    This is useful for analyzing the circuit structure and dependencies.\n\n    Args:\n        circuit: cirq.Circuit - the circuit to convert.\n        can_reorder: function - a function that checks if two operations can be reordered.\n\n    Returns:\n    [0] - nx.DiGraph - the directed acyclic graph representation of the circuit.\n    \"\"\"\n\n    def reorder_check(\n        op1, op2\n    ):  # can reorder iff both are CZ, or intersection is empty\n        if op1.gate == cirq.CZ and op2.gate == cirq.CZ:\n            return True\n        else:\n            return len(set(op1.qubits).intersection(op2.qubits)) == 0\n\n    # Turn into DAG\n    directed = CircuitDag.from_circuit(\n        circuit, can_reorder=reorder_check if can_reorder is None else can_reorder\n    )\n    return nx.transitive_reduction(directed)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/parallelize/#bloqade.cirq_utils.parallelize.transpile","title":"transpile","text":"<pre><code>transpile(circuit: Circuit) -&gt; cirq.Circuit\n</code></pre> <p>Transpile a circuit to a native CZ gate set of {CZ, PhXZ}.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/parallelize.py</code> <pre><code>def transpile(circuit: cirq.Circuit) -&gt; cirq.Circuit:\n    \"\"\"\n    Transpile a circuit to a native CZ gate set of {CZ, PhXZ}.\n    \"\"\"\n    # Convert to CZ target gate set.\n    circuit2 = cirq.optimize_for_target_gateset(circuit, gateset=cirq.CZTargetGateset())\n    circuit2 = cirq.drop_empty_moments(circuit2)\n\n    missing_qubits = circuit.all_qubits() - circuit2.all_qubits()\n\n    for qubit in missing_qubits:\n        circuit2.append(\n            cirq.PhasedXZGate(x_exponent=0, z_exponent=0, axis_phase_exponent=0).on(\n                qubit\n            )\n        )\n\n    return circuit2\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/base/","title":"Base","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/base/#bloqade.cirq_utils.emit.base.emit_circuit","title":"emit_circuit","text":"<pre><code>emit_circuit(\n    mt: Method,\n    qubits: Sequence[Qid] | None = None,\n    circuit_qubits: Sequence[Qid] | None = None,\n    args: tuple = (),\n    ignore_returns: bool = False,\n) -&gt; cirq.Circuit\n</code></pre> <p>Converts a squin.kernel method to a cirq.Circuit object.</p> <p>Parameters:</p> Name Type Description Default <code>mt</code> <code>Method</code> <p>The kernel method from which to construct the circuit.</p> required <p>Other Parameters:</p> Name Type Description <code>circuit_qubits</code> <code>Sequence[Qid] | None</code> <p>A list of qubits to use as the qubits in the circuit. Defaults to None. If this is None, then <code>cirq.LineQubit</code>s are inserted for every <code>squin.qalloc</code> statement in the order they appear inside the kernel. Note: If a list of qubits is provided, make sure that there is a sufficient number of qubits for the resulting circuit.</p> <code>args</code> <code>tuple</code> <p>The arguments of the kernel function from which to emit a circuit.</p> <code>ignore_returns</code> <code>bool</code> <p>If <code>False</code>, emitting a circuit from a kernel that returns a value will error. Set it to <code>True</code> in order to ignore the return value(s). Defaults to <code>False</code>.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/base/#bloqade.cirq_utils.emit.base.emit_circuit--examples","title":"Examples:","text":"<p>Here's a very basic example:</p> <pre><code>from bloqade import squin\nfrom bloqade.cirq_utils import emit_circuit\n\n@squin.kernel\ndef main():\n    q = squin.qalloc(2)\n    squin.h(q[0])\n    squin.cx(q[0], q[1])\n\ncircuit = emit_circuit(main)\n\nprint(circuit)\n</code></pre> <p>You can also compose multiple kernels. Those are emitted as subcircuits within the \"main\" circuit. Subkernels can accept arguments and return a value.</p> <pre><code>from bloqade import squin\nfrom bloqade.cirq_utils import emit_circuit\nfrom kirin.dialects import ilist\nfrom typing import Literal\nimport cirq\n\n@squin.kernel\ndef entangle(q: ilist.IList[squin.qubit.Qubit, Literal[2]]):\n    squin.h(q[0])\n    squin.cx(q[0], q[1])\n\n@squin.kernel\ndef main():\n    q = squin.qalloc(2)\n    q2 = squin.qalloc(3)\n    squin.cx(q[1], q2[2])\n\n\n# custom list of qubits on grid\nqubits = [cirq.GridQubit(i, i+1) for i in range(5)]\n\ncircuit = emit_circuit(main, circuit_qubits=qubits)\nprint(circuit)\n</code></pre> <p>We also passed in a custom list of qubits above. This allows you to provide a custom geometry and manipulate the qubits in other circuits directly written in cirq as well.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/emit/base.py</code> <pre><code>def emit_circuit(\n    mt: ir.Method,\n    qubits: Sequence[cirq.Qid] | None = None,\n    circuit_qubits: Sequence[cirq.Qid] | None = None,\n    args: tuple = (),\n    ignore_returns: bool = False,\n) -&gt; cirq.Circuit:\n    \"\"\"Converts a squin.kernel method to a cirq.Circuit object.\n\n    Args:\n        mt (ir.Method): The kernel method from which to construct the circuit.\n\n    Keyword Args:\n        circuit_qubits (Sequence[cirq.Qid] | None):\n            A list of qubits to use as the qubits in the circuit. Defaults to None.\n            If this is None, then `cirq.LineQubit`s are inserted for every `squin.qalloc`\n            statement in the order they appear inside the kernel.\n            **Note**: If a list of qubits is provided, make sure that there is a sufficient\n            number of qubits for the resulting circuit.\n        args (tuple):\n            The arguments of the kernel function from which to emit a circuit.\n        ignore_returns (bool):\n            If `False`, emitting a circuit from a kernel that returns a value will error.\n            Set it to `True` in order to ignore the return value(s). Defaults to `False`.\n\n    ## Examples:\n\n    Here's a very basic example:\n\n    ```python\n    from bloqade import squin\n    from bloqade.cirq_utils import emit_circuit\n\n    @squin.kernel\n    def main():\n        q = squin.qalloc(2)\n        squin.h(q[0])\n        squin.cx(q[0], q[1])\n\n    circuit = emit_circuit(main)\n\n    print(circuit)\n    ```\n\n    You can also compose multiple kernels. Those are emitted as subcircuits within the \"main\" circuit.\n    Subkernels can accept arguments and return a value.\n\n    ```python\n    from bloqade import squin\n    from bloqade.cirq_utils import emit_circuit\n    from kirin.dialects import ilist\n    from typing import Literal\n    import cirq\n\n    @squin.kernel\n    def entangle(q: ilist.IList[squin.qubit.Qubit, Literal[2]]):\n        squin.h(q[0])\n        squin.cx(q[0], q[1])\n\n    @squin.kernel\n    def main():\n        q = squin.qalloc(2)\n        q2 = squin.qalloc(3)\n        squin.cx(q[1], q2[2])\n\n\n    # custom list of qubits on grid\n    qubits = [cirq.GridQubit(i, i+1) for i in range(5)]\n\n    circuit = emit_circuit(main, circuit_qubits=qubits)\n    print(circuit)\n\n    ```\n\n    We also passed in a custom list of qubits above. This allows you to provide a custom geometry\n    and manipulate the qubits in other circuits directly written in cirq as well.\n    \"\"\"\n\n    if circuit_qubits is None and qubits is not None:\n        circuit_qubits = qubits\n        warn(\n            \"The keyword argument `qubits` is deprecated. Use `circuit_qubits` instead.\"\n        )\n\n    if (\n        not ignore_returns\n        and isinstance(mt.code, func.Function)\n        and not mt.code.signature.output.is_subseteq(types.NoneType)\n    ):\n        raise interp.exceptions.InterpreterError(\n            \"The method you are trying to convert to a circuit has a return value, but returning from a circuit is not supported.\"\n            \" Set `ignore_returns = True` in order to simply ignore the return values and emit a circuit.\"\n        )\n\n    if len(args) != len(mt.args):\n        raise ValueError(\n            f\"The method from which you're trying to emit a circuit takes {len(mt.args)} as input, but you passed in {len(args)} via the `args` keyword!\"\n        )\n\n    emitter = EmitCirq(qubits=circuit_qubits)\n\n    symbol_op_trait = mt.code.get_trait(ir.SymbolOpInterface)\n    if (symbol_op_trait := mt.code.get_trait(ir.SymbolOpInterface)) is None:\n        raise interp.exceptions.InterpreterError(\n            \"The method is not a symbol, cannot emit circuit!\"\n        )\n\n    sym_name = symbol_op_trait.get_sym_name(mt.code).unwrap()\n\n    if (signature_trait := mt.code.get_trait(ir.HasSignature)) is None:\n        raise interp.exceptions.InterpreterError(\n            f\"The method {sym_name} does not have a signature, cannot emit circuit!\"\n        )\n\n    signature = signature_trait.get_signature(mt.code)\n    new_signature = func.Signature(inputs=(), output=signature.output)\n\n    callable_region = mt.callable_region.clone()\n    entry_block = callable_region.blocks[0]\n    args_ssa = list(entry_block.args)\n    first_stmt = entry_block.first_stmt\n\n    assert first_stmt is not None, \"Method has no statements!\"\n    if len(args_ssa) - 1 != len(args):\n        raise interp.exceptions.InterpreterError(\n            f\"The method {sym_name} takes {len(args_ssa) - 1} arguments, but you passed in {len(args)} via the `args` keyword!\"\n        )\n\n    for arg, arg_ssa in zip(args, args_ssa[1:], strict=True):\n        (value := py.Constant(arg)).insert_before(first_stmt)\n        arg_ssa.replace_by(value.result)\n        entry_block.args.delete(arg_ssa)\n\n    new_func = func.Function(\n        sym_name=sym_name, body=callable_region, signature=new_signature\n    )\n    mt_ = ir.Method(\n        dialects=mt.dialects,\n        code=new_func,\n        sym_name=sym_name,\n    )\n\n    AggressiveUnroll(mt_.dialects).fixpoint(mt_)\n    emitter.initialize()\n    emitter.run(mt_)\n    return emitter.circuit\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/gate/","title":"Gate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/noise/","title":"Noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/emit/qubit/","title":"Qubit","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/conflict_graph/","title":"Conflict graph","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/conflict_graph/#bloqade.cirq_utils.noise.conflict_graph.OneZoneConflictGraph","title":"OneZoneConflictGraph","text":"<pre><code>OneZoneConflictGraph(moment: Moment)\n</code></pre> <p>Representation of the AOD conflict graph for qubits to more to their entangling partners in a single zone setup.</p> <p>Assumes the qubits are specified as cirq.GridQubits with a chosen geometry.</p> <p>:param moment: A cirq.Moment object containing operations (gates) to be analyzed.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/noise/conflict_graph.py</code> <pre><code>def __init__(self, moment: cirq.Moment):\n    \"\"\"\n    Initializes the conflict graph for a given moment of a cirq circuit.\n\n    :param moment: A cirq.Moment object containing operations (gates) to be analyzed.\n    \"\"\"\n\n    self.moment = moment\n    self.gates_in_moment = [op for op in moment.operations if len(op.qubits) == 2]\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/conflict_graph/#bloqade.cirq_utils.noise.conflict_graph.OneZoneConflictGraph.get_move_schedule","title":"get_move_schedule","text":"<pre><code>get_move_schedule(mover_limit: int = 10000)\n</code></pre> <p>Generates a move schedule by coloring the conflict graph greedily, first coloring nodes of highest degree.</p> <p>Qubits that are the arguments of a single CZ gate are 'partners'. Only one partner need be moved to arrange the atoms for the 2Q gate. Thus, in coloring the conflict graph, as soon as one partner is colored, the other can be disregarded for the purpose of coloring the rest of the graph.</p> <p>This sets the self.move_schedule attribute, which is a dictionary where the keys are the indices of the move moments.</p> <p>:param mover_limit: The maximum number of qubits that can be moved in a single moment. Added as a constraint     when coloring the conflict graph. :returns a dictionary of idx:[cirq.Qid] where idx indexes the move moment where the list of qubits move.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/noise/conflict_graph.py</code> <pre><code>def get_move_schedule(self, mover_limit: int = 10000):\n    \"\"\"Generates a move schedule by coloring the conflict graph greedily, first coloring nodes of highest degree.\n\n    Qubits that are the arguments of a single CZ gate are 'partners'. Only one partner need be moved to arrange the\n    atoms for the 2Q gate. Thus, in coloring the conflict graph, as soon as one partner is colored, the other can be\n    disregarded for the purpose of coloring the rest of the graph.\n\n    This sets the self.move_schedule attribute, which is a dictionary where the keys are the indices of the move moments.\n\n    :param mover_limit: The maximum number of qubits that can be moved in a single moment. Added as a constraint\n        when coloring the conflict graph.\n    :returns a dictionary of idx:[cirq.Qid] where idx indexes the move moment where the list of qubits move.\n    \"\"\"\n\n    self._get_nodes()\n    self._get_edges()\n    self._get_node_degrees()\n\n    self.ordered_nodes = sorted(self.degrees, key=self.degrees.get, reverse=True)\n\n    move_schedule = {}\n    colored_nodes = set()\n    partner_node = None\n    for node in self.ordered_nodes:\n        colored = False\n        for gate in self.gates_in_moment:\n            if node in gate.qubits:\n                partners = set(gate.qubits)\n                partners.remove(node)\n                partner_node = list(partners)[0]\n        if node in colored_nodes:\n            # NOTE: if a node is colored, both it and its partner are added to colored_nodes\n            continue\n        else:\n            connected_nodes = set()\n            for edge in self.edges:\n                if node in edge:\n                    connected_nodes.add(edge[0])\n                    connected_nodes.add(edge[1])\n            connected_nodes.remove(node)\n            for color in move_schedule.keys():\n                has_colored_neighbor = False\n                for connected_node in connected_nodes:\n                    # NOTE: loop through to make sure none of the connected nodes are already assigned to color.\n                    if connected_node in move_schedule[color]:\n                        has_colored_neighbor = True\n                        break\n                    else:\n                        continue\n                mover_limit_reached = len(move_schedule[color]) &gt;= mover_limit\n                if not (has_colored_neighbor or mover_limit_reached):\n                    # NOTE: node needs color\n                    move_schedule[color].add(node)\n                    colored = True\n\n                    # NOTE: add this node and it's partner to the solved nodes.\n                    colored_nodes.add(node)\n\n                    if partner_node is not None:\n                        colored_nodes.add(partner_node)\n                    break\n            if not colored:\n                move_schedule[len(move_schedule)] = {node}\n                colored = True\n                colored_nodes.add(node)\n\n                if partner_node is not None:\n                    colored_nodes.add(partner_node)\n\n    assert set(colored_nodes) == set(self.ordered_nodes)\n\n    self.move_schedule = move_schedule\n\n    return self.move_schedule\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/","title":"Model","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiNoiseModelABC","title":"GeminiNoiseModelABC  <code>dataclass</code>","text":"<pre><code>GeminiNoiseModelABC(\n    check_input_circuit: bool = True,\n    cz_paired_correlated_rates: ndarray | None = None,\n    cz_paired_error_probabilities: dict | None = None,\n    *,\n    local_px: float = 0.0004102,\n    local_py: float = 0.0004102,\n    local_pz: float = 0.0004112,\n    local_loss_prob: float = 0.0,\n    local_unaddressed_px: float = 2e-07,\n    local_unaddressed_py: float = 2e-07,\n    local_unaddressed_pz: float = 1.2e-06,\n    local_unaddressed_loss_prob: float = 0.0,\n    global_px: float = 6.5e-05,\n    global_py: float = 6.5e-05,\n    global_pz: float = 6.5e-05,\n    global_loss_prob: float = 0.0,\n    cz_paired_gate_px: float = 0.0006549,\n    cz_paired_gate_py: float = 0.0006549,\n    cz_paired_gate_pz: float = 0.003184,\n    cz_gate_loss_prob: float = 0.0,\n    cz_unpaired_gate_px: float = 0.0005149,\n    cz_unpaired_gate_py: float = 0.0005149,\n    cz_unpaired_gate_pz: float = 0.002185,\n    cz_unpaired_loss_prob: float = 0.0,\n    mover_px: float = 0.000806,\n    mover_py: float = 0.000806,\n    mover_pz: float = 0.002458,\n    move_loss_prob: float = 0.0,\n    sitter_px: float = 0.0003066,\n    sitter_py: float = 0.0003066,\n    sitter_pz: float = 0.0004639,\n    sit_loss_prob: float = 0.0\n)\n</code></pre> <p>               Bases: <code>NoiseModel</code>, <code>MoveNoiseModelABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.cirq_utils.noise.model.GeminiNoiseModelABC[GeminiNoiseModelABC]\n              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC[MoveNoiseModelABC]\n\n                              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\n                \n\n\n              click bloqade.cirq_utils.noise.model.GeminiNoiseModelABC href \"\" \"bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\"\n              click bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC href \"\" \"bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC\"\n            </code></pre> <p>Abstract base class for all Gemini noise models.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiNoiseModelABC.check_input_circuit","title":"check_input_circuit  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>check_input_circuit: bool = True\n</code></pre> <p>Determine whether or not to verify that the circuit only contains native gates.</p> <p>Caution: Disabling this for circuits containing non-native gates may lead to incorrect results!</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiNoiseModelABC.cz_paired_correlated_rates","title":"cz_paired_correlated_rates  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_correlated_rates: ndarray | None = None\n</code></pre> <p>The correlated CZ error rates as a 4x4 array.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiNoiseModelABC.cz_paired_error_probabilities","title":"cz_paired_error_probabilities  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_error_probabilities: dict | None = None\n</code></pre> <p>The correlated CZ error rates as a dictionary</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiNoiseModelABC.parallel_cz_errors","title":"parallel_cz_errors","text":"<pre><code>parallel_cz_errors(\n    ctrls: list[int], qargs: list[int], rest: list[int]\n) -&gt; dict[tuple[float, float, float, float], list[int]]\n</code></pre> <p>Takes a set of ctrls and qargs and returns a noise model for all qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/noise/model.py</code> <pre><code>def parallel_cz_errors(\n    self, ctrls: list[int], qargs: list[int], rest: list[int]\n) -&gt; dict[tuple[float, float, float, float], list[int]]:\n    raise NotImplementedError(\n        \"This noise model doesn't support rewrites on bloqade kernels, but should be used with cirq.\"\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel","title":"GeminiOneZoneNoiseModel  <code>dataclass</code>","text":"<pre><code>GeminiOneZoneNoiseModel(\n    check_input_circuit: bool = True,\n    cz_paired_correlated_rates: ndarray | None = None,\n    cz_paired_error_probabilities: dict | None = None,\n    parallelize_circuit: bool = False,\n    *,\n    local_px: float = 0.0004102,\n    local_py: float = 0.0004102,\n    local_pz: float = 0.0004112,\n    local_loss_prob: float = 0.0,\n    local_unaddressed_px: float = 2e-07,\n    local_unaddressed_py: float = 2e-07,\n    local_unaddressed_pz: float = 1.2e-06,\n    local_unaddressed_loss_prob: float = 0.0,\n    global_px: float = 6.5e-05,\n    global_py: float = 6.5e-05,\n    global_pz: float = 6.5e-05,\n    global_loss_prob: float = 0.0,\n    cz_paired_gate_px: float = 0.0006549,\n    cz_paired_gate_py: float = 0.0006549,\n    cz_paired_gate_pz: float = 0.003184,\n    cz_gate_loss_prob: float = 0.0,\n    cz_unpaired_gate_px: float = 0.0005149,\n    cz_unpaired_gate_py: float = 0.0005149,\n    cz_unpaired_gate_pz: float = 0.002185,\n    cz_unpaired_loss_prob: float = 0.0,\n    mover_px: float = 0.000806,\n    mover_py: float = 0.000806,\n    mover_pz: float = 0.002458,\n    move_loss_prob: float = 0.0,\n    sitter_px: float = 0.0003066,\n    sitter_py: float = 0.0003066,\n    sitter_pz: float = 0.0004639,\n    sit_loss_prob: float = 0.0\n)\n</code></pre> <p>               Bases: <code>GeminiNoiseModelABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel[GeminiOneZoneNoiseModel]\n              bloqade.cirq_utils.noise.model.GeminiNoiseModelABC[GeminiNoiseModelABC]\n              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC[MoveNoiseModelABC]\n\n                              bloqade.cirq_utils.noise.model.GeminiNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel\n                                bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\n                \n\n\n\n              click bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel href \"\" \"bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel\"\n              click bloqade.cirq_utils.noise.model.GeminiNoiseModelABC href \"\" \"bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\"\n              click bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC href \"\" \"bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC\"\n            </code></pre> <p>A Cirq-compatible noise model for a one-zone implementation of the Gemini architecture.</p> <p>This model introduces custom asymmetric depolarizing noise for both single- and two-qubit gates depending on whether operations are global, local, or part of a CZ interaction. Since the model assumes all atoms are in the entangling zone, errors are applied that stem from application of Rydberg error, even for qubits not actively involved in a gate operation.</p> <p>Note, that the noise applied to entangling pairs is correlated.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel.noisy_moments","title":"noisy_moments","text":"<pre><code>noisy_moments(\n    moments: Iterable[Moment], system_qubits: Sequence[Qid]\n) -&gt; Sequence[cirq.OP_TREE]\n</code></pre> <p>Adds possibly stateful noise to a series of moments.</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>Iterable[Moment]</code> <p>The moments to add noise to.</p> required <code>system_qubits</code> <code>Sequence[Qid]</code> <p>A list of all qubits in the system.</p> required <p>Returns:</p> Type Description <code>Sequence[OP_TREE]</code> <p>A sequence of OP_TREEEs, with the k'th tree corresponding to the</p> <code>Sequence[OP_TREE]</code> <p>noisy operations for the k'th moment.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/noise/model.py</code> <pre><code>def noisy_moments(\n    self, moments: Iterable[cirq.Moment], system_qubits: Sequence[cirq.Qid]\n) -&gt; Sequence[cirq.OP_TREE]:\n    \"\"\"Adds possibly stateful noise to a series of moments.\n\n    Args:\n        moments: The moments to add noise to.\n        system_qubits: A list of all qubits in the system.\n\n    Returns:\n        A sequence of OP_TREEEs, with the k'th tree corresponding to the\n        noisy operations for the k'th moment.\n    \"\"\"\n\n    if self.check_input_circuit:\n        self.validate_moments(moments)\n\n    # Split into moments with only 1Q and 2Q gates\n    moments_1q = [\n        cirq.Moment([op for op in moment.operations if len(op.qubits) == 1])\n        for moment in moments\n    ]\n    moments_2q = [\n        cirq.Moment([op for op in moment.operations if len(op.qubits) == 2])\n        for moment in moments\n    ]\n\n    assert len(moments_1q) == len(moments_2q)\n\n    interleaved_moments = []\n    for idx, moment in enumerate(moments_1q):\n        interleaved_moments.append(moment)\n        interleaved_moments.append(moments_2q[idx])\n\n    interleaved_circuit = cirq.Circuit.from_moments(*interleaved_moments)\n\n    # Combine subsequent 1Q gates\n    compressed_circuit = cirq.merge_single_qubit_moments_to_phxz(\n        interleaved_circuit\n    )\n    if self.parallelize_circuit:\n        compressed_circuit = parallelize(compressed_circuit)\n\n    return self._noisy_moments_impl_moment(\n        compressed_circuit.moments, system_qubits\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModelConflictGraphMoves","title":"GeminiOneZoneNoiseModelConflictGraphMoves  <code>dataclass</code>","text":"<pre><code>GeminiOneZoneNoiseModelConflictGraphMoves(\n    check_input_circuit: bool = True,\n    cz_paired_correlated_rates: ndarray | None = None,\n    cz_paired_error_probabilities: dict | None = None,\n    parallelize_circuit: bool = False,\n    max_parallel_movers: int = 10000,\n    *,\n    local_px: float = 0.0004102,\n    local_py: float = 0.0004102,\n    local_pz: float = 0.0004112,\n    local_loss_prob: float = 0.0,\n    local_unaddressed_px: float = 2e-07,\n    local_unaddressed_py: float = 2e-07,\n    local_unaddressed_pz: float = 1.2e-06,\n    local_unaddressed_loss_prob: float = 0.0,\n    global_px: float = 6.5e-05,\n    global_py: float = 6.5e-05,\n    global_pz: float = 6.5e-05,\n    global_loss_prob: float = 0.0,\n    cz_paired_gate_px: float = 0.0006549,\n    cz_paired_gate_py: float = 0.0006549,\n    cz_paired_gate_pz: float = 0.003184,\n    cz_gate_loss_prob: float = 0.0,\n    cz_unpaired_gate_px: float = 0.0005149,\n    cz_unpaired_gate_py: float = 0.0005149,\n    cz_unpaired_gate_pz: float = 0.002185,\n    cz_unpaired_loss_prob: float = 0.0,\n    mover_px: float = 0.000806,\n    mover_py: float = 0.000806,\n    mover_pz: float = 0.002458,\n    move_loss_prob: float = 0.0,\n    sitter_px: float = 0.0003066,\n    sitter_py: float = 0.0003066,\n    sitter_pz: float = 0.0004639,\n    sit_loss_prob: float = 0.0\n)\n</code></pre> <p>               Bases: <code>GeminiOneZoneNoiseModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModelConflictGraphMoves[GeminiOneZoneNoiseModelConflictGraphMoves]\n              bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel[GeminiOneZoneNoiseModel]\n              bloqade.cirq_utils.noise.model.GeminiNoiseModelABC[GeminiNoiseModelABC]\n              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC[MoveNoiseModelABC]\n\n                              bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel --&gt; bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModelConflictGraphMoves\n                                bloqade.cirq_utils.noise.model.GeminiNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel\n                                bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\n                \n\n\n\n\n              click bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModelConflictGraphMoves href \"\" \"bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModelConflictGraphMoves\"\n              click bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel href \"\" \"bloqade.cirq_utils.noise.model.GeminiOneZoneNoiseModel\"\n              click bloqade.cirq_utils.noise.model.GeminiNoiseModelABC href \"\" \"bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\"\n              click bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC href \"\" \"bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC\"\n            </code></pre> <p>A Cirq noise model that uses a conflict graph to schedule moves in a one-zone Gemini architecture.</p> <p>Assumes that the qubits are cirq.GridQubits, such that the assignment of row, column coordinates define the initial geometry. An SLM site at the two qubit interaction distance is also assumed next to each cirq.GridQubit to allow for multiple moves before a single Rydberg pulse is applied for a parallel CZ.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiTwoZoneNoiseModel","title":"GeminiTwoZoneNoiseModel  <code>dataclass</code>","text":"<pre><code>GeminiTwoZoneNoiseModel(\n    check_input_circuit: bool = True,\n    cz_paired_correlated_rates: ndarray | None = None,\n    cz_paired_error_probabilities: dict | None = None,\n    *,\n    local_px: float = 0.0004102,\n    local_py: float = 0.0004102,\n    local_pz: float = 0.0004112,\n    local_loss_prob: float = 0.0,\n    local_unaddressed_px: float = 2e-07,\n    local_unaddressed_py: float = 2e-07,\n    local_unaddressed_pz: float = 1.2e-06,\n    local_unaddressed_loss_prob: float = 0.0,\n    global_px: float = 6.5e-05,\n    global_py: float = 6.5e-05,\n    global_pz: float = 6.5e-05,\n    global_loss_prob: float = 0.0,\n    cz_paired_gate_px: float = 0.0006549,\n    cz_paired_gate_py: float = 0.0006549,\n    cz_paired_gate_pz: float = 0.003184,\n    cz_gate_loss_prob: float = 0.0,\n    cz_unpaired_gate_px: float = 0.0005149,\n    cz_unpaired_gate_py: float = 0.0005149,\n    cz_unpaired_gate_pz: float = 0.002185,\n    cz_unpaired_loss_prob: float = 0.0,\n    mover_px: float = 0.000806,\n    mover_py: float = 0.000806,\n    mover_pz: float = 0.002458,\n    move_loss_prob: float = 0.0,\n    sitter_px: float = 0.0003066,\n    sitter_py: float = 0.0003066,\n    sitter_pz: float = 0.0004639,\n    sit_loss_prob: float = 0.0\n)\n</code></pre> <p>               Bases: <code>GeminiNoiseModelABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.cirq_utils.noise.model.GeminiTwoZoneNoiseModel[GeminiTwoZoneNoiseModel]\n              bloqade.cirq_utils.noise.model.GeminiNoiseModelABC[GeminiNoiseModelABC]\n              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC[MoveNoiseModelABC]\n\n                              bloqade.cirq_utils.noise.model.GeminiNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiTwoZoneNoiseModel\n                                bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC --&gt; bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\n                \n\n\n\n              click bloqade.cirq_utils.noise.model.GeminiTwoZoneNoiseModel href \"\" \"bloqade.cirq_utils.noise.model.GeminiTwoZoneNoiseModel\"\n              click bloqade.cirq_utils.noise.model.GeminiNoiseModelABC href \"\" \"bloqade.cirq_utils.noise.model.GeminiNoiseModelABC\"\n              click bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC href \"\" \"bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/model/#bloqade.cirq_utils.noise.model.GeminiTwoZoneNoiseModel.noisy_moments","title":"noisy_moments","text":"<pre><code>noisy_moments(\n    moments: Iterable[Moment], system_qubits: Sequence[Qid]\n) -&gt; Sequence[cirq.OP_TREE]\n</code></pre> <p>Adds possibly stateful noise to a series of moments.</p> <p>Parameters:</p> Name Type Description Default <code>moments</code> <code>Iterable[Moment]</code> <p>The moments to add noise to.</p> required <code>system_qubits</code> <code>Sequence[Qid]</code> <p>A list of all qubits in the system.</p> required <p>Returns:</p> Type Description <code>Sequence[OP_TREE]</code> <p>A sequence of OP_TREEEs, with the k'th tree corresponding to the</p> <code>Sequence[OP_TREE]</code> <p>noisy operations for the k'th moment.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/noise/model.py</code> <pre><code>def noisy_moments(\n    self, moments: Iterable[cirq.Moment], system_qubits: Sequence[cirq.Qid]\n) -&gt; Sequence[cirq.OP_TREE]:\n    \"\"\"Adds possibly stateful noise to a series of moments.\n\n    Args:\n        moments: The moments to add noise to.\n        system_qubits: A list of all qubits in the system.\n\n    Returns:\n        A sequence of OP_TREEEs, with the k'th tree corresponding to the\n        noisy operations for the k'th moment.\n    \"\"\"\n\n    if self.check_input_circuit:\n        self.validate_moments(moments)\n\n    moments = list(moments)\n\n    if len(moments) == 0:\n        return []\n\n    nqubs = len(system_qubits)\n    noisy_moment_list = []\n\n    prev_moment: cirq.Moment | None = None\n\n    # TODO: clean up error getters so they return a list moments rather than circuits\n    for i in range(len(moments)):\n        noisy_moment_list.extend(\n            [\n                moment\n                for moment in _two_zone_utils.get_move_error_channel_two_zoned(\n                    moments[i],\n                    prev_moment,\n                    np.array(self.mover_pauli_rates),\n                    np.array(self.sitter_pauli_rates),\n                    nqubs,\n                ).moments\n                if len(moment) &gt; 0\n            ]\n        )\n\n        noisy_moment_list.append(moments[i])\n\n        noisy_moment_list.extend(\n            [\n                moment\n                for moment in _two_zone_utils.get_gate_error_channel(\n                    moments[i],\n                    np.array(self.local_pauli_rates),\n                    np.array(self.global_pauli_rates),\n                    self.two_qubit_pauli,\n                    np.array(self.cz_unpaired_pauli_rates),\n                    nqubs,\n                ).moments\n                if len(moment) &gt; 0\n            ]\n        )\n\n        prev_moment = moments[i]\n\n    return noisy_moment_list\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/transform/","title":"Transform","text":""},{"location":"reference/bloqade-circuit/src/bloqade/cirq_utils/noise/transform/#bloqade.cirq_utils.noise.transform.transform_circuit","title":"transform_circuit","text":"<pre><code>transform_circuit(\n    circuit: Circuit,\n    to_native_gateset: bool = True,\n    model: NoiseModel | None = None,\n    parallelize_circuit: bool = False,\n) -&gt; cirq.Circuit\n</code></pre> <p>Transform an input circuit into one with the native gateset with noise operations added.</p> <p>Noise operations will be added to all qubits in circuit.all_qubits(), regardless of whether the output of the circuit optimizers contain all the qubits.</p> <p>Parameters:</p> Name Type Description Default <code>circuit</code> <code>Circuit</code> <p>The input circuit.</p> required <p>Other Parameters:</p> Name Type Description <code>to_native_gateset</code> <code>bool</code> <p>Whether or not to convert the input circuit to one using the native set of gates (<code>cirq.CZTargetGateset</code>) only. Defaults to <code>True</code>. Note, that if you use an input circuit that has gates different from this gateset and don't convert it, may lead to incorrect results and errors.</p> <code>model</code> <code>NoiseModel</code> <p>The cirq noise model to apply to the circuit. Usually, you want to use one of the ones supplied in this submodule, such as <code>GeminiOneZoneNoiseModel</code>.</p> <code>parallelize_circuit</code> <code>bool</code> <p>Whether or not to parallelize the circuit as much as possible after it's been converted to the native gateset. Defaults to <code>False</code>.</p> <p>Returns:</p> Type Description <code>Circuit</code> <p>cirq.Circuit: The resulting noisy circuit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/cirq_utils/noise/transform.py</code> <pre><code>def transform_circuit(\n    circuit: cirq.Circuit,\n    to_native_gateset: bool = True,\n    model: cirq.NoiseModel | None = None,\n    parallelize_circuit: bool = False,\n) -&gt; cirq.Circuit:\n    \"\"\"Transform an input circuit into one with the native gateset with noise operations added.\n\n    Noise operations will be added to all qubits in circuit.all_qubits(), regardless of whether the output of the\n    circuit optimizers contain all the qubits.\n\n    Args:\n        circuit (cirq.Circuit): The input circuit.\n\n    Keyword Arguments:\n        to_native_gateset (bool): Whether or not to convert the input circuit to one using the native set of gates (`cirq.CZTargetGateset`)\n            only. Defaults to `True`. Note, that if you use an input circuit that has gates different from this gateset and don't convert it,\n            may lead to incorrect results and errors.\n        model (cirq.NoiseModel): The cirq noise model to apply to the circuit. Usually, you want to use one of the ones supplied in this submodule,\n            such as `GeminiOneZoneNoiseModel`.\n        parallelize_circuit (bool): Whether or not to parallelize the circuit as much as possible after it's been converted to the native gateset.\n            Defaults to `False`.\n\n    Returns:\n        cirq.Circuit:\n            The resulting noisy circuit.\n    \"\"\"\n    if model is None:\n        model = GeminiOneZoneNoiseModel(parallelize_circuit=parallelize_circuit)\n\n    # only parallelize here if we aren't parallelizing inside a one-zone model\n    parallelize_circuit_here = parallelize_circuit and not isinstance(\n        model, GeminiOneZoneNoiseModel\n    )\n\n    system_qubits = sorted(circuit.all_qubits())\n    # Transform to CZ + PhasedXZ gateset.\n    if to_native_gateset and not parallelize_circuit_here:\n        native_circuit = transpile(circuit)\n    elif parallelize_circuit_here:\n        native_circuit = parallelize(circuit)\n    else:\n        native_circuit = circuit\n\n    # Add noise\n    noisy_circuit = cirq.Circuit()\n    for op_tree in model.noisy_moments(native_circuit, system_qubits):\n        # Keep moments aligned\n        noisy_circuit += cirq.Circuit(op_tree)\n\n    return noisy_circuit\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/gemini/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/gemini/groups/","title":"Groups","text":""},{"location":"reference/bloqade-circuit/src/bloqade/gemini/groups/#bloqade.gemini.groups.logical","title":"logical","text":"<pre><code>logical(self)\n</code></pre> <p>Compile a function to a Gemini logical kernel.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/gemini/groups.py</code> <pre><code>@ir.dialect_group(structural_no_opt.union([gate, py.constant, qubit, func, ilist]))\ndef logical(self):\n    \"\"\"Compile a function to a Gemini logical kernel.\"\"\"\n\n    def run_pass(\n        mt,\n        *,\n        verify: Annotated[\n            bool, Doc(\"run `verify` before running passes, default is `True`\")\n        ] = True,\n        typeinfer: Annotated[\n            bool,\n            Doc(\"run type inference and apply the inferred type to IR, default `True`\"),\n        ] = True,\n        fold: Annotated[bool, Doc(\"run folding passes\")] = True,\n        aggressive: Annotated[\n            bool, Doc(\"run aggressive folding passes if `fold=True`\")\n        ] = False,\n        inline: Annotated[bool, Doc(\"inline function calls, default `True`\")] = True,\n        aggressive_unroll: Annotated[\n            bool,\n            Doc(\n                \"Run aggressive inlining and unrolling pass on the IR, default `False`\"\n            ),\n        ] = False,\n        no_raise: Annotated[bool, Doc(\"do not raise exception during analysis\")] = True,\n    ) -&gt; None:\n\n        if inline and not aggressive_unroll:\n            InlinePass(mt.dialects, no_raise=no_raise).fixpoint(mt)\n\n        if aggressive_unroll:\n            AggressiveUnroll(mt.dialects, no_raise=no_raise).fixpoint(mt)\n        else:\n            default_pass = Default(\n                self,\n                verify=verify,\n                fold=fold,\n                aggressive=aggressive,\n                typeinfer=typeinfer,\n                no_raise=no_raise,\n            )\n\n            default_pass.fixpoint(mt)\n\n        if verify:\n            validator = KernelValidation(GeminiLogicalValidationAnalysis)\n            validator.run(mt, no_raise=no_raise)\n            mt.verify()\n\n    return run_pass\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/gemini/analysis/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/gemini/analysis/logical_validation/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/gemini/analysis/logical_validation/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade-circuit/src/bloqade/gemini/analysis/logical_validation/impls/","title":"Impls","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/dialects/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/dialects/gate/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/dialects/gate/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/","title":"Broadcast","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.cx","title":"cx","text":"<pre><code>cx(controls: IList[Qubit, N], targets: IList[Qubit, N])\n</code></pre> <p>Apply a controlled-X gate on a pairs of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>IList[Qubit, N]</code> <p>Control qubits.</p> required <code>targets</code> <code>IList[Qubit, N]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef cx(controls: ilist.IList[qubit.Qubit, N], targets: ilist.IList[qubit.Qubit, N]):\n    \"\"\"Apply a controlled-X gate on a pairs of qubits.\n\n    Args:\n        controls (ilist.IList[qubit.Qubit, N]): Control qubits.\n        targets (ilist.IList[qubit.Qubit, N]): Target qubits.\n    \"\"\"\n    sqrt_y_adj(targets)\n    cz(controls, targets)\n    sqrt_y(targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.cy","title":"cy","text":"<pre><code>cy(controls: IList[Qubit, N], targets: IList[Qubit, N])\n</code></pre> <p>Apply a controlled-Y gate on a pairs of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>IList[Qubit, N]</code> <p>Control qubits.</p> required <code>targets</code> <code>IList[Qubit, N]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef cy(controls: ilist.IList[qubit.Qubit, N], targets: ilist.IList[qubit.Qubit, N]):\n    \"\"\"Apply a controlled-Y gate on a pairs of qubits.\n\n    Args:\n        controls (ilist.IList[qubit.Qubit, N]): Control qubits.\n        targets (ilist.IList[qubit.Qubit, N]): Target qubits.\n    \"\"\"\n    sqrt_x(targets)\n    cz(controls, targets)\n    sqrt_x_adj(targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.cz","title":"cz","text":"<pre><code>cz(controls: IList[Qubit, N], qubits: IList[Qubit, N])\n</code></pre> <p>Apply a controlled-Z gate on a pairs of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>IList[Qubit, N]</code> <p>Control qubits.</p> required <code>qubits</code> <code>IList[Qubit, N]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef cz(controls: ilist.IList[qubit.Qubit, N], qubits: ilist.IList[qubit.Qubit, N]):\n    \"\"\"Apply a controlled-Z gate on a pairs of qubits.\n\n    Args:\n        controls (ilist.IList[qubit.Qubit, N]): Control qubits.\n        qubits (ilist.IList[qubit.Qubit, N]): Target qubits.\n    \"\"\"\n    native.cz(controls, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.h","title":"h","text":"<pre><code>h(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a Hadamard gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef h(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a Hadamard gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    s(qubits)\n    sqrt_x(qubits)\n    s(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.rx","title":"rx","text":"<pre><code>rx(angle: float, qubits: IList[Qubit, Any])\n</code></pre> <p>Apply an RX rotation gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef rx(angle: float, qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply an RX rotation gate on a group of qubits.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    native.r(0.0, _radian_to_turn(angle), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.ry","title":"ry","text":"<pre><code>ry(angle: float, qubits: IList[Qubit, Any])\n</code></pre> <p>Apply an RY rotation gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef ry(angle: float, qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply an RY rotation gate on a group of qubits.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    native.r(0.25, _radian_to_turn(angle), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.rz","title":"rz","text":"<pre><code>rz(angle: float, qubits: IList[Qubit, Any])\n</code></pre> <p>Apply an RZ rotation gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef rz(angle: float, qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply an RZ rotation gate on a group of qubits.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    native.rz(_radian_to_turn(angle), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.s","title":"s","text":"<pre><code>s(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply an S gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef s(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply an S gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(math.pi / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.s_adj","title":"s_adj","text":"<pre><code>s_adj(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply the adjoint of the S gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef s_adj(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply the adjoint of the S gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(-math.pi / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.shift","title":"shift","text":"<pre><code>shift(angle: float, qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a phase shift to the |1&gt; state on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Phase shift angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef shift(angle: float, qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a phase shift to the |1&gt; state on a group of qubits.\n\n    Args:\n        angle (float): Phase shift angle in radians.\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(angle / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.sqrt_x","title":"sqrt_x","text":"<pre><code>sqrt_x(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a sqrt(X) gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef sqrt_x(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a sqrt(X) gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rx(math.pi / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.sqrt_x_adj","title":"sqrt_x_adj","text":"<pre><code>sqrt_x_adj(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply the adjoint of sqrt(X) on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef sqrt_x_adj(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply the adjoint of sqrt(X) on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rx(-math.pi / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.sqrt_y","title":"sqrt_y","text":"<pre><code>sqrt_y(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a sqrt(Y) gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef sqrt_y(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a sqrt(Y) gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    ry(-math.pi / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.sqrt_y_adj","title":"sqrt_y_adj","text":"<pre><code>sqrt_y_adj(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply the adjoint of sqrt(Y) on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef sqrt_y_adj(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply the adjoint of sqrt(Y) on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    ry(math.pi / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.t","title":"t","text":"<pre><code>t(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a T gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef t(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a T gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(math.pi / 4.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.t_adj","title":"t_adj","text":"<pre><code>t_adj(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply the adjoint of aT gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef t_adj(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply the adjoint of aT gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(-math.pi / 4.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.u3","title":"u3","text":"<pre><code>u3(\n    theta: float,\n    phi: float,\n    lam: float,\n    qubits: IList[Qubit, Any],\n)\n</code></pre> <p>Apply the U3 gate on a group of qubits.</p> <p>The applied gate is represented by the unitary matrix given by:</p> \\[ U3(\\theta, \\phi, \\lambda) = R_z(\\phi)R_y(\\theta)R_z(\\lambda) \\] <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation around Y axis (radians).</p> required <code>phi</code> <code>float</code> <p>Global phase shift component (radians).</p> required <code>lam</code> <code>float</code> <p>Z rotations in decomposition (radians).</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef u3(theta: float, phi: float, lam: float, qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply the U3 gate on a group of qubits.\n\n    The applied gate is represented by the unitary matrix given by:\n\n    $$ U3(\\\\theta, \\\\phi, \\\\lambda) = R_z(\\\\phi)R_y(\\\\theta)R_z(\\\\lambda) $$\n\n    Args:\n        theta (float): Rotation around Y axis (radians).\n        phi (float): Global phase shift component (radians).\n        lam (float): Z rotations in decomposition (radians).\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(lam, qubits)\n    ry(theta, qubits)\n    rz(phi, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.x","title":"x","text":"<pre><code>x(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a Pauli-X gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef x(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a Pauli-X gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rx(math.pi, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.y","title":"y","text":"<pre><code>y(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a Pauli-Y gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef y(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a Pauli-Y gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    ry(math.pi, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/broadcast/#bloqade.native.stdlib.broadcast.z","title":"z","text":"<pre><code>z(qubits: IList[Qubit, Any])\n</code></pre> <p>Apply a Pauli-Z gate on a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/broadcast.py</code> <pre><code>@kernel\ndef z(qubits: ilist.IList[qubit.Qubit, Any]):\n    \"\"\"Apply a Pauli-Z gate on a group of qubits.\n\n    Args:\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(math.pi, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/","title":"Simple","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.cx","title":"cx","text":"<pre><code>cx(control: Qubit, target: Qubit)\n</code></pre> <p>Apply a controlled-X gate on two qubits.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Qubit</code> <p>The control qubit.</p> required <code>target</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef cx(control: qubit.Qubit, target: qubit.Qubit):\n    \"\"\"Apply a controlled-X gate on two qubits.\n\n    Args:\n        control (qubit.Qubit): The control qubit.\n        target (qubit.Qubit): The target qubit.\n    \"\"\"\n    broadcast.cx(ilist.IList([control]), ilist.IList([target]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.cy","title":"cy","text":"<pre><code>cy(control: Qubit, targets: Qubit)\n</code></pre> <p>Apply a controlled-Y gate on two qubits.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Qubit</code> <p>The control qubit.</p> required <code>targets</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef cy(control: qubit.Qubit, targets: qubit.Qubit):\n    \"\"\"Apply a controlled-Y gate on two qubits.\n\n    Args:\n        control (qubit.Qubit): The control qubit.\n        targets (qubit.Qubit): The target qubit.\n    \"\"\"\n    broadcast.cy(ilist.IList([control]), ilist.IList([targets]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.cz","title":"cz","text":"<pre><code>cz(control: Qubit, target: Qubit)\n</code></pre> <p>Apply a controlled-Z gate on two qubits.</p> <p>Parameters:</p> Name Type Description Default <code>control</code> <code>Qubit</code> <p>The control qubit.</p> required <code>target</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef cz(control: qubit.Qubit, target: qubit.Qubit):\n    \"\"\"Apply a controlled-Z gate on two qubits.\n\n    Args:\n        control (qubit.Qubit): The control qubit.\n        target (qubit.Qubit): The target qubit.\n    \"\"\"\n    broadcast.cz(ilist.IList([control]), ilist.IList([target]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.h","title":"h","text":"<pre><code>h(qubit: Qubit)\n</code></pre> <p>Apply a Hadamard gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the Hadamard gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef h(qubit: qubit.Qubit):\n    \"\"\"Apply a Hadamard gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the Hadamard gate to.\n    \"\"\"\n    broadcast.h(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.rx","title":"rx","text":"<pre><code>rx(angle: float, qubit: Qubit)\n</code></pre> <p>Apply an RX rotation gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the rotation to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef rx(angle: float, qubit: qubit.Qubit):\n    \"\"\"Apply an RX rotation gate on a single qubit.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubit (qubit.Qubit): The qubit to apply the rotation to.\n    \"\"\"\n    broadcast.rx(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.ry","title":"ry","text":"<pre><code>ry(angle: float, qubit: Qubit)\n</code></pre> <p>Apply an RY rotation gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the rotation to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef ry(angle: float, qubit: qubit.Qubit):\n    \"\"\"Apply an RY rotation gate on a single qubit.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubit (qubit.Qubit): The qubit to apply the rotation to.\n    \"\"\"\n    broadcast.ry(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.rz","title":"rz","text":"<pre><code>rz(angle: float, qubit: Qubit)\n</code></pre> <p>Apply an RZ rotation gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the rotation to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef rz(angle: float, qubit: qubit.Qubit):\n    \"\"\"Apply an RZ rotation gate on a single qubit.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubit (qubit.Qubit): The qubit to apply the rotation to.\n    \"\"\"\n    broadcast.rz(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.s","title":"s","text":"<pre><code>s(qubit: Qubit)\n</code></pre> <p>Apply an S gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the S gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef s(qubit: qubit.Qubit):\n    \"\"\"Apply an S gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the S gate to.\n    \"\"\"\n    broadcast.s(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.s_dag","title":"s_dag","text":"<pre><code>s_dag(qubit: Qubit)\n</code></pre> <p>Apply the adjoint of the S gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the adjoint S gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef s_dag(qubit: qubit.Qubit):\n    \"\"\"Apply the adjoint of the S gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the adjoint S gate to.\n    \"\"\"\n    broadcast.s_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.shift","title":"shift","text":"<pre><code>shift(angle: float, qubit: Qubit)\n</code></pre> <p>Apply a phase shift on the |1&gt; state of a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Shift angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the shift to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef shift(angle: float, qubit: qubit.Qubit):\n    \"\"\"Apply a phase shift on the |1&gt; state of a single qubit.\n\n    Args:\n        angle (float): Shift angle in radians.\n        qubit (qubit.Qubit): The qubit to apply the shift to.\n    \"\"\"\n    broadcast.shift(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.sqrt_x","title":"sqrt_x","text":"<pre><code>sqrt_x(qubit: Qubit)\n</code></pre> <p>Apply a sqrt(X) gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the sqrt(X) gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef sqrt_x(qubit: qubit.Qubit):\n    \"\"\"Apply a sqrt(X) gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the sqrt(X) gate to.\n    \"\"\"\n    broadcast.sqrt_x(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.sqrt_x_adj","title":"sqrt_x_adj","text":"<pre><code>sqrt_x_adj(qubit: Qubit)\n</code></pre> <p>Apply the adjoint of sqrt(X) on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the adjoint sqrt(X) gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef sqrt_x_adj(qubit: qubit.Qubit):\n    \"\"\"Apply the adjoint of sqrt(X) on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the adjoint sqrt(X) gate to.\n    \"\"\"\n    broadcast.sqrt_x_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.sqrt_y","title":"sqrt_y","text":"<pre><code>sqrt_y(qubit: Qubit)\n</code></pre> <p>Apply a sqrt(Y) gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the sqrt(Y) gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef sqrt_y(qubit: qubit.Qubit):\n    \"\"\"Apply a sqrt(Y) gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the sqrt(Y) gate to.\n    \"\"\"\n    broadcast.sqrt_y(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.sqrt_y_adj","title":"sqrt_y_adj","text":"<pre><code>sqrt_y_adj(qubit: Qubit)\n</code></pre> <p>Apply the adjoint of sqrt(Y) on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the adjoint sqrt(Y) gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef sqrt_y_adj(qubit: qubit.Qubit):\n    \"\"\"Apply the adjoint of sqrt(Y) on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the adjoint sqrt(Y) gate to.\n    \"\"\"\n    broadcast.sqrt_y_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.t","title":"t","text":"<pre><code>t(qubit: Qubit)\n</code></pre> <p>Apply a T gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the T gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef t(qubit: qubit.Qubit):\n    \"\"\"Apply a T gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the T gate to.\n    \"\"\"\n    broadcast.t(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.t_adj","title":"t_adj","text":"<pre><code>t_adj(qubit: Qubit)\n</code></pre> <p>Apply the adjoint of the T gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the adjoint T gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef t_adj(qubit: qubit.Qubit):\n    \"\"\"Apply the adjoint of the T gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the adjoint T gate to.\n    \"\"\"\n    broadcast.t_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.u3","title":"u3","text":"<pre><code>u3(theta: float, phi: float, lam: float, qubit: Qubit)\n</code></pre> <p>Apply the U3 gate on a single qubit.</p> <p>The applied gate is represented by the unitary matrix given by:</p> \\[ U3(\\theta, \\phi, \\lambda) = R_z(\\phi)R_y(\\theta)R_z(\\lambda) \\] <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation angle around the Y axis in radians.</p> required <code>phi</code> <code>float</code> <p>Rotation angle around the Z axis in radians.</p> required <code>lam</code> <code>float</code> <p>Rotation angle around the Z axis in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the U3 gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef u3(theta: float, phi: float, lam: float, qubit: qubit.Qubit):\n    \"\"\"Apply the U3 gate on a single qubit.\n\n    The applied gate is represented by the unitary matrix given by:\n\n    $$ U3(\\\\theta, \\\\phi, \\\\lambda) = R_z(\\\\phi)R_y(\\\\theta)R_z(\\\\lambda) $$\n\n    Args:\n        theta (float): Rotation angle around the Y axis in radians.\n        phi (float): Rotation angle around the Z axis in radians.\n        lam (float): Rotation angle around the Z axis in radians.\n        qubit (qubit.Qubit): The qubit to apply the U3 gate to.\n    \"\"\"\n    broadcast.u3(theta, phi, lam, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.x","title":"x","text":"<pre><code>x(qubit: Qubit)\n</code></pre> <p>Apply a Pauli-X gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the X gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef x(qubit: qubit.Qubit):\n    \"\"\"Apply a Pauli-X gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the X gate to.\n    \"\"\"\n    broadcast.x(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.y","title":"y","text":"<pre><code>y(qubit: Qubit)\n</code></pre> <p>Apply a Pauli-Y gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the Y gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef y(qubit: qubit.Qubit):\n    \"\"\"Apply a Pauli-Y gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the Y gate to.\n    \"\"\"\n    broadcast.y(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/stdlib/simple/#bloqade.native.stdlib.simple.z","title":"z","text":"<pre><code>z(qubit: Qubit)\n</code></pre> <p>Apply a Pauli-Z gate on a single qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to apply the Z gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/stdlib/simple.py</code> <pre><code>@kernel\ndef z(qubit: qubit.Qubit):\n    \"\"\"Apply a Pauli-Z gate on a single qubit.\n\n    Args:\n        qubit (qubit.Qubit): The qubit to apply the Z gate to.\n    \"\"\"\n    broadcast.z(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/native/upstream/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/upstream/squin2native/","title":"Squin2native","text":""},{"location":"reference/bloqade-circuit/src/bloqade/native/upstream/squin2native/#bloqade.native.upstream.squin2native.SquinToNative","title":"SquinToNative","text":"<p>A Target that converts Squin gates to native gates.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/native/upstream/squin2native/#bloqade.native.upstream.squin2native.SquinToNative.emit","title":"emit","text":"<pre><code>emit(mt: Method, *, no_raise=True) -&gt; ir.Method\n</code></pre> <p>Convert Squin gates to native gates.</p> <p>Parameters:</p> Name Type Description Default <code>mt</code> <code>Method</code> <p>The method to convert.</p> required <code>no_raise</code> <code>bool</code> <p>Whether to suppress errors. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Method</code> <p>ir.Method: The converted method.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/native/upstream/squin2native.py</code> <pre><code>def emit(self, mt: ir.Method, *, no_raise=True) -&gt; ir.Method:\n    \"\"\"Convert Squin gates to native gates.\n\n    Args:\n        mt (ir.Method): The method to convert.\n        no_raise (bool, optional): Whether to suppress errors. Defaults to True.\n\n    Returns:\n        ir.Method: The converted method.\n    \"\"\"\n    old_callgraph = CallGraph(mt)\n    all_dialects = chain.from_iterable(\n        ker.dialects.data for kers in old_callgraph.defs.values() for ker in kers\n    )\n    combined_dialects = mt.dialects.union(all_dialects).union(kernel)\n\n    out = mt.similar(combined_dialects)\n    UpdateDialectsOnCallGraph(combined_dialects, no_raise=no_raise)(out)\n    CallGraphPass(combined_dialects, rewrite.Walk(GateRule()), no_raise=no_raise)(\n        out\n    )\n    # verify all kernels in the callgraph and discard gate dialect\n    out.dialects.discard(gate_dialect)\n    new_callgraph = CallGraph(out)\n    for ker in new_callgraph.edges.keys():\n        ker.dialects.discard(gate_dialect)\n        ker.verify()\n\n    return out\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/","title":"Base","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.DynamicMemory","title":"DynamicMemory  <code>dataclass</code>","text":"<pre><code>DynamicMemory(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>               Bases: <code>MemoryABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.base.DynamicMemory[DynamicMemory]\n              bloqade.pyqrack.base.MemoryABC[MemoryABC]\n\n                              bloqade.pyqrack.base.MemoryABC --&gt; bloqade.pyqrack.base.DynamicMemory\n                \n\n\n              click bloqade.pyqrack.base.DynamicMemory href \"\" \"bloqade.pyqrack.base.DynamicMemory\"\n              click bloqade.pyqrack.base.MemoryABC href \"\" \"bloqade.pyqrack.base.MemoryABC\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.DynamicMemory.allocate","title":"allocate","text":"<pre><code>allocate(n_qubits: int)\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>def allocate(self, n_qubits: int):\n    start = self.sim_reg.num_qubits()\n    for i in range(start, start + n_qubits):\n        self.sim_reg.allocate_qubit(i)\n\n    return tuple(range(start, start + n_qubits))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.MemoryABC","title":"MemoryABC  <code>dataclass</code>","text":"<pre><code>MemoryABC(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.base.MemoryABC[MemoryABC]\n\n              \n\n              click bloqade.pyqrack.base.MemoryABC href \"\" \"bloqade.pyqrack.base.MemoryABC\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.MemoryABC.allocate","title":"allocate  <code>abstractmethod</code>","text":"<pre><code>allocate(n_qubits: int) -&gt; tuple[int, ...]\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>@abc.abstractmethod\ndef allocate(self, n_qubits: int) -&gt; tuple[int, ...]:\n    \"\"\"Allocate `n_qubits` qubits and return their ids.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.MemoryABC.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the memory, releasing all qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>def reset(self):\n    \"\"\"Reset the memory, releasing all qubits.\"\"\"\n    from pyqrack import QrackSimulator\n\n    # do not reset the simulator it might be used by\n    # results of the simulation\n    self.sim_reg = QrackSimulator(**self.pyqrack_options)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.MockMemory","title":"MockMemory  <code>dataclass</code>","text":"<pre><code>MockMemory(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>               Bases: <code>MemoryABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.base.MockMemory[MockMemory]\n              bloqade.pyqrack.base.MemoryABC[MemoryABC]\n\n                              bloqade.pyqrack.base.MemoryABC --&gt; bloqade.pyqrack.base.MockMemory\n                \n\n\n              click bloqade.pyqrack.base.MockMemory href \"\" \"bloqade.pyqrack.base.MockMemory\"\n              click bloqade.pyqrack.base.MemoryABC href \"\" \"bloqade.pyqrack.base.MemoryABC\"\n            </code></pre> <p>Mock memory for testing purposes.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.MockMemory.allocate","title":"allocate","text":"<pre><code>allocate(n_qubits: int)\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>def allocate(self, n_qubits: int):\n    allocated = self.allocated + n_qubits\n    result = tuple(range(self.allocated, allocated))\n    self.allocated = allocated\n    return result\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.MockMemory.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the memory, releasing all qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>def reset(self):\n    self.allocated = 0\n    self.sim_reg = Mock()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.PyQrackInterpreter","title":"PyQrackInterpreter  <code>dataclass</code>","text":"<pre><code>PyQrackInterpreter(\n    *,\n    memory: MemoryType,\n    rng_state: Generator = np.random.default_rng(),\n    loss_m_result: Measurement = Measurement.One\n)\n</code></pre> <p>               Bases: <code>Interpreter</code>, <code>Generic[MemoryType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.base.PyQrackInterpreter[PyQrackInterpreter]\n\n              \n\n              click bloqade.pyqrack.base.PyQrackInterpreter href \"\" \"bloqade.pyqrack.base.PyQrackInterpreter\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.PyQrackInterpreter.loss_m_result","title":"loss_m_result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>loss_m_result: Measurement = field(\n    default=One, kw_only=True\n)\n</code></pre> <p>The value of a measurement result when a qubit is lost.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.StackMemory","title":"StackMemory  <code>dataclass</code>","text":"<pre><code>StackMemory(\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n    *,\n    total: int\n)\n</code></pre> <p>               Bases: <code>MemoryABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.base.StackMemory[StackMemory]\n              bloqade.pyqrack.base.MemoryABC[MemoryABC]\n\n                              bloqade.pyqrack.base.MemoryABC --&gt; bloqade.pyqrack.base.StackMemory\n                \n\n\n              click bloqade.pyqrack.base.StackMemory href \"\" \"bloqade.pyqrack.base.StackMemory\"\n              click bloqade.pyqrack.base.MemoryABC href \"\" \"bloqade.pyqrack.base.MemoryABC\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.StackMemory.allocate","title":"allocate","text":"<pre><code>allocate(n_qubits: int)\n</code></pre> <p>Allocate <code>n_qubits</code> qubits and return their ids.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>def allocate(self, n_qubits: int):\n    curr_allocated = self.allocated\n    self.allocated += n_qubits\n\n    if self.allocated &gt; self.total:\n        raise InterpreterError(\n            f\"qubit allocation exceeds memory, \"\n            f\"{self.total} qubits, \"\n            f\"{self.allocated} allocated\"\n        )\n\n    return tuple(range(curr_allocated, self.allocated))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/base/#bloqade.pyqrack.base.StackMemory.reset","title":"reset","text":"<pre><code>reset()\n</code></pre> <p>Reset the memory, releasing all qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/base.py</code> <pre><code>def reset(self):\n    super().reset()\n    self.allocated = 0\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/","title":"Device","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.DynamicMemorySimulator","title":"DynamicMemorySimulator  <code>dataclass</code>","text":"<pre><code>DynamicMemorySimulator(\n    options: PyQrackOptions = _default_pyqrack_args(),\n    *,\n    loss_m_result: Measurement = Measurement.One,\n    rng_state: Generator = np.random.default_rng()\n)\n</code></pre> <p>               Bases: <code>PyQrackSimulatorBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.device.DynamicMemorySimulator[DynamicMemorySimulator]\n              bloqade.pyqrack.device.PyQrackSimulatorBase[PyQrackSimulatorBase]\n              bloqade.device.AbstractSimulatorDevice[AbstractSimulatorDevice]\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n                              bloqade.pyqrack.device.PyQrackSimulatorBase --&gt; bloqade.pyqrack.device.DynamicMemorySimulator\n                                bloqade.device.AbstractSimulatorDevice --&gt; bloqade.pyqrack.device.PyQrackSimulatorBase\n                                bloqade.device.AbstractDevice --&gt; bloqade.device.AbstractSimulatorDevice\n                \n\n\n\n\n              click bloqade.pyqrack.device.DynamicMemorySimulator href \"\" \"bloqade.pyqrack.device.DynamicMemorySimulator\"\n              click bloqade.pyqrack.device.PyQrackSimulatorBase href \"\" \"bloqade.pyqrack.device.PyQrackSimulatorBase\"\n              click bloqade.device.AbstractSimulatorDevice href \"\" \"bloqade.device.AbstractSimulatorDevice\"\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre> <p>PyQrack simulator device with dynamic qubit allocation.</p> <p>This can be used to simulate kernels where the number of qubits is not known ahead of time.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.DynamicMemorySimulator--usage-examples","title":"Usage examples","text":"<pre><code># Define a kernel\n@qasm2.main\ndef main():\n    q = qasm2.qreg(2)\n    c = qasm2.creg(2)\n\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n\n    qasm2.measure(q, c)\n    return q\n\n# Create the simulator object\nsim = DynamicMemorySimulator()\n\n# Execute the kernel\nqubits = sim.run(main)\n</code></pre> <p>You can also obtain other information from it, such as the state vector:</p> <p>``` ket = sim.state_vector(main)</p> <p>from pyqrack.pauli import Pauli expectation_vals = sim.pauli_expectation([Pauli.PauliX, Pauli.PauliI], qubits)</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.DynamicMemorySimulator.task","title":"task","text":"<pre><code>task(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>Method</code> <p>The kernel method to run.</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments to pass to the kernel method.</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to pass to the kernel method.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PyQrackSimulatorTask</code> <p>The task object used to track execution.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/device.py</code> <pre><code>def task(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Args:\n        kernel (ir.Method):\n            The kernel method to run.\n        args (tuple[Any, ...]):\n            Positional arguments to pass to the kernel method.\n        kwargs (dict[str, Any] | None):\n            Keyword arguments to pass to the kernel method.\n\n    Returns:\n        PyQrackSimulatorTask:\n            The task object used to track execution.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    memory = DynamicMemory(self.options.copy())\n    return self.new_task(kernel, args, kwargs, memory)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.PyQrackSimulatorBase","title":"PyQrackSimulatorBase  <code>dataclass</code>","text":"<pre><code>PyQrackSimulatorBase(\n    options: PyQrackOptions = _default_pyqrack_args(),\n    *,\n    loss_m_result: Measurement = Measurement.One,\n    rng_state: Generator = np.random.default_rng()\n)\n</code></pre> <p>               Bases: <code>AbstractSimulatorDevice[PyQrackSimulatorTask]</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.device.PyQrackSimulatorBase[PyQrackSimulatorBase]\n              bloqade.device.AbstractSimulatorDevice[AbstractSimulatorDevice]\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n                              bloqade.device.AbstractSimulatorDevice --&gt; bloqade.pyqrack.device.PyQrackSimulatorBase\n                                bloqade.device.AbstractDevice --&gt; bloqade.device.AbstractSimulatorDevice\n                \n\n\n\n              click bloqade.pyqrack.device.PyQrackSimulatorBase href \"\" \"bloqade.pyqrack.device.PyQrackSimulatorBase\"\n              click bloqade.device.AbstractSimulatorDevice href \"\" \"bloqade.device.AbstractSimulatorDevice\"\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre> <p>PyQrack simulation device base class.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.PyQrackSimulatorBase.options","title":"options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>options: PyQrackOptions = field(\n    default_factory=_default_pyqrack_args\n)\n</code></pre> <p>options (PyQrackOptions): options passed into the pyqrack simulator.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.PyQrackSimulatorBase.pauli_expectation","title":"pauli_expectation  <code>staticmethod</code>","text":"<pre><code>pauli_expectation(\n    pauli: list[Pauli], qubits: list[PyQrackQubit]\n) -&gt; float\n</code></pre> <p>Returns the expectation value of the given Pauli operator given a list of Pauli operators and qubits.</p> <p>Parameters:</p> Name Type Description Default <code>pauli</code> <code>list[Pauli]</code> <p>List of Pauli operators to compute the expectation value for.</p> required <code>qubits</code> <code>list[PyQrackQubit]</code> <p>List of qubits corresponding to the Pauli operators.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The expectation value of the Pauli operator.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/device.py</code> <pre><code>@staticmethod\ndef pauli_expectation(pauli: list[Pauli], qubits: list[PyQrackQubit]) -&gt; float:\n    \"\"\"Returns the expectation value of the given Pauli operator given a list of Pauli operators and qubits.\n\n    Args:\n        pauli (list[Pauli]):\n            List of Pauli operators to compute the expectation value for.\n        qubits (list[PyQrackQubit]):\n            List of qubits corresponding to the Pauli operators.\n\n    returns:\n        float:\n            The expectation value of the Pauli operator.\n\n    \"\"\"\n\n    if len(pauli) == 0:\n        return 0.0\n\n    if len(pauli) != len(qubits):\n        raise ValueError(\"Length of Pauli and qubits must match.\")\n\n    sim_reg = qubits[0].sim_reg\n\n    if any(qubit.sim_reg is not sim_reg for qubit in qubits):\n        raise ValueError(\"All qubits must belong to the same simulator register.\")\n\n    qubit_ids = [qubit.addr for qubit in qubits]\n\n    if len(qubit_ids) != len(set(qubit_ids)):\n        raise ValueError(\"Qubits must be unique.\")\n\n    return sim_reg.pauli_expectation(qubit_ids, pauli)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.PyQrackSimulatorBase.quantum_state","title":"quantum_state  <code>staticmethod</code>","text":"<pre><code>quantum_state(\n    qubits: list[PyQrackQubit] | IList[PyQrackQubit, Any],\n    tol: float = 1e-12,\n) -&gt; QuantumState\n</code></pre> <p>Extract the reduced density matrix representing the state of a list of qubits from a PyQRack simulator register.</p> Inputs <p>qubits: A list of PyQRack qubits to extract the reduced density matrix for tol: The tolerance for density matrix eigenvalues to be considered non-zero.</p> <p>Outputs:     An eigh result containing the eigenvalues and eigenvectors of the reduced density matrix.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/device.py</code> <pre><code>@staticmethod\ndef quantum_state(\n    qubits: list[PyQrackQubit] | IList[PyQrackQubit, Any], tol: float = 1e-12\n) -&gt; \"QuantumState\":\n    \"\"\"\n    Extract the reduced density matrix representing the state of a list\n    of qubits from a PyQRack simulator register.\n\n    Inputs:\n        qubits: A list of PyQRack qubits to extract the reduced density matrix for\n        tol: The tolerance for density matrix eigenvalues to be considered non-zero.\n    Outputs:\n        An eigh result containing the eigenvalues and eigenvectors of the reduced density matrix.\n    \"\"\"\n    if len(qubits) == 0:\n        return QuantumState(\n            eigenvalues=np.array([]), eigenvectors=np.array([]).reshape(0, 0)\n        )\n    sim_reg = qubits[0].sim_reg\n\n    if not all([x.sim_reg is sim_reg for x in qubits]):\n        raise ValueError(\"All qubits must be from the same simulator register.\")\n    inds: tuple[int, ...] = tuple(qubit.addr for qubit in qubits)\n\n    return _pyqrack_reduced_density_matrix(inds, sim_reg, tol)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.PyQrackSimulatorBase.reduced_density_matrix","title":"reduced_density_matrix  <code>classmethod</code>","text":"<pre><code>reduced_density_matrix(\n    qubits: list[PyQrackQubit] | IList[PyQrackQubit, Any],\n    tol: float = 1e-12,\n) -&gt; np.ndarray\n</code></pre> <p>Extract the reduced density matrix representing the state of a list of qubits from a PyQRack simulator register.</p> Inputs <p>qubits: A list of PyQRack qubits to extract the reduced density matrix for tol: The tolerance for density matrix eigenvalues to be considered non-zero.</p> <p>Outputs:     A dense 2^n x 2^n numpy array representing the reduced density matrix.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/device.py</code> <pre><code>@classmethod\ndef reduced_density_matrix(\n    cls, qubits: list[PyQrackQubit] | IList[PyQrackQubit, Any], tol: float = 1e-12\n) -&gt; np.ndarray:\n    \"\"\"\n    Extract the reduced density matrix representing the state of a list\n    of qubits from a PyQRack simulator register.\n\n    Inputs:\n        qubits: A list of PyQRack qubits to extract the reduced density matrix for\n        tol: The tolerance for density matrix eigenvalues to be considered non-zero.\n    Outputs:\n        A dense 2^n x 2^n numpy array representing the reduced density matrix.\n    \"\"\"\n    rdm = cls.quantum_state(qubits, tol)\n    return np.einsum(\n        \"ax,x,bx\", rdm.eigenvectors, rdm.eigenvalues, rdm.eigenvectors.conj()\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.PyQrackSimulatorBase.state_vector","title":"state_vector","text":"<pre><code>state_vector(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n) -&gt; list[complex]\n</code></pre> <p>Runs task and returns the state vector.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/device.py</code> <pre><code>def state_vector(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n) -&gt; list[complex]:\n    \"\"\"Runs task and returns the state vector.\"\"\"\n    return self.task(kernel, args, kwargs).state_vector()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.QuantumState","title":"QuantumState","text":"<p>               Bases: <code>NamedTuple</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.device.QuantumState[QuantumState]\n\n              \n\n              click bloqade.pyqrack.device.QuantumState href \"\" \"bloqade.pyqrack.device.QuantumState\"\n            </code></pre> <p>A representation of a quantum state as a density matrix, where the density matrix is rho = sum_i eigenvalues[i] |eigenvectors[:,i]&gt;&lt;eigenvectors[:,i]|.</p> <p>This representation is efficient for low-rank density matrices by only storing the non-zero eigenvalues and corresponding eigenvectors of the density matrix. For example, a pure state has only one non-zero eigenvalue equal to 1.0.</p> <p>Endianness and qubit ordering of the state vector is consistent with Cirq, where eigenvectors[0,0] corresponds to the amplitude of the |00..000&gt; element of the zeroth eigenvector; eigenvectors[1,0] corresponds to the amplitude of the |00..001&gt; element of the zeroth eigenvector; eigenvectors[3,0] corresponds to the amplitude of the |00..011&gt; element of the zeroth eigenvector; eigenvectors[-1,0] corresponds to the amplitude of the |11..111&gt; element of the zeroth eigenvector. A flip of the LAST bit |00..000&gt;&lt;00..001| corresponds to applying a PauliX gate to the FIRST qubit. A flip of the FIRST bit |00..000&gt;&lt;10..000| corresponds to applying a PauliX gate to the LAST qubit.</p> <p>Attributes:</p> Name Type Description <code>eigenvalues</code> <code>1d np.ndarray</code> <p>The non-zero eigenvalues of the density matrix.</p> <code>eigenvectors</code> <code>2d np.ndarray</code> <p>The corresponding eigenvectors of the density matrix, where eigenvectors[:,i] is the i-th eigenvector.</p> <p>Methods:     Not Implemented, pending https://github.com/QuEraComputing/bloqade-circuit/issues/447</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.StackMemorySimulator","title":"StackMemorySimulator  <code>dataclass</code>","text":"<pre><code>StackMemorySimulator(\n    options: PyQrackOptions = _default_pyqrack_args(),\n    *,\n    loss_m_result: Measurement = Measurement.One,\n    rng_state: Generator = np.random.default_rng(),\n    min_qubits: int = 0\n)\n</code></pre> <p>               Bases: <code>PyQrackSimulatorBase</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.device.StackMemorySimulator[StackMemorySimulator]\n              bloqade.pyqrack.device.PyQrackSimulatorBase[PyQrackSimulatorBase]\n              bloqade.device.AbstractSimulatorDevice[AbstractSimulatorDevice]\n              bloqade.device.AbstractDevice[AbstractDevice]\n\n                              bloqade.pyqrack.device.PyQrackSimulatorBase --&gt; bloqade.pyqrack.device.StackMemorySimulator\n                                bloqade.device.AbstractSimulatorDevice --&gt; bloqade.pyqrack.device.PyQrackSimulatorBase\n                                bloqade.device.AbstractDevice --&gt; bloqade.device.AbstractSimulatorDevice\n                \n\n\n\n\n              click bloqade.pyqrack.device.StackMemorySimulator href \"\" \"bloqade.pyqrack.device.StackMemorySimulator\"\n              click bloqade.pyqrack.device.PyQrackSimulatorBase href \"\" \"bloqade.pyqrack.device.PyQrackSimulatorBase\"\n              click bloqade.device.AbstractSimulatorDevice href \"\" \"bloqade.device.AbstractSimulatorDevice\"\n              click bloqade.device.AbstractDevice href \"\" \"bloqade.device.AbstractDevice\"\n            </code></pre> <p>PyQrack simulator device with preallocated stack of qubits.</p> <p>This can be used to simulate kernels where the number of qubits is known ahead of time.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.StackMemorySimulator--usage-examples","title":"Usage examples","text":"<pre><code># Define a kernel\n@qasm2.main\ndef main():\n    q = qasm2.qreg(2)\n    c = qasm2.creg(2)\n\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n\n    qasm2.measure(q, c)\n    return q\n\n# Create the simulator object\nsim = StackMemorySimulator(min_qubits=2)\n\n# Execute the kernel\nqubits = sim.run(main)\n</code></pre> <p>You can also obtain other information from it, such as the state vector:</p> <pre><code>ket = sim.state_vector(main)\n\nfrom pyqrack.pauli import Pauli\nexpectation_vals = sim.pauli_expectation([Pauli.PauliX, Pauli.PauliI], qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/device/#bloqade.pyqrack.device.StackMemorySimulator.task","title":"task","text":"<pre><code>task(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n)\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>kernel</code> <code>Method</code> <p>The kernel method to run.</p> required <code>args</code> <code>tuple[Any, ...]</code> <p>Positional arguments to pass to the kernel method.</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any] | None</code> <p>Keyword arguments to pass to the kernel method.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>PyQrackSimulatorTask</code> <p>The task object used to track execution.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/device.py</code> <pre><code>def task(\n    self,\n    kernel: ir.Method[Params, RetType],\n    args: tuple[Any, ...] = (),\n    kwargs: dict[str, Any] | None = None,\n):\n    \"\"\"\n    Args:\n        kernel (ir.Method):\n            The kernel method to run.\n        args (tuple[Any, ...]):\n            Positional arguments to pass to the kernel method.\n        kwargs (dict[str, Any] | None):\n            Keyword arguments to pass to the kernel method.\n\n    Returns:\n        PyQrackSimulatorTask:\n            The task object used to track execution.\n\n    \"\"\"\n    if kwargs is None:\n        kwargs = {}\n\n    address_analysis = AddressAnalysis(dialects=kernel.dialects)\n    frame, _ = address_analysis.run(kernel)\n    if self.min_qubits == 0 and any(\n        isinstance(a, (UnknownQubit, UnknownReg)) for a in frame.entries.values()\n    ):\n        raise ValueError(\n            \"All addresses must be resolved. Or set min_qubits to a positive integer.\"\n        )\n\n    num_qubits = max(address_analysis.qubit_count, self.min_qubits)\n    options = self.options.copy()\n    options[\"qubitCount\"] = num_qubits\n    memory = StackMemory(\n        options,\n        total=num_qubits,\n    )\n\n    return self.new_task(kernel, args, kwargs, memory)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/native/","title":"Native","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/","title":"Reg","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CBitRef","title":"CBitRef  <code>dataclass</code>","text":"<pre><code>CBitRef(ref: CRegister, pos: int)\n</code></pre> <p>Object representing a reference to a classical bit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CBitRef.pos","title":"pos  <code>instance-attribute</code>","text":"<pre><code>pos: int\n</code></pre> <p>The position of this bit in the classical register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CBitRef.ref","title":"ref  <code>instance-attribute</code>","text":"<pre><code>ref: CRegister\n</code></pre> <p>The classical register that is holding this bit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.CRegister","title":"CRegister","text":"<pre><code>CRegister(size: int)\n</code></pre> <p>               Bases: <code>list[Measurement]</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.reg.CRegister[CRegister]\n\n              \n\n              click bloqade.pyqrack.reg.CRegister href \"\" \"bloqade.pyqrack.reg.CRegister\"\n            </code></pre> <p>Runtime representation of a classical register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/reg.py</code> <pre><code>def __init__(self, size: int):\n    super().__init__(Measurement.Zero for _ in range(size))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.Measurement","title":"Measurement","text":"<pre><code>Measurement(measurement_id: int = 0)\n</code></pre> <p>               Bases: <code>MeasurementResult</code>, <code>IntEnum</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.reg.Measurement[Measurement]\n              bloqade.types.MeasurementResult[MeasurementResult]\n\n                              bloqade.types.MeasurementResult --&gt; bloqade.pyqrack.reg.Measurement\n                \n\n\n              click bloqade.pyqrack.reg.Measurement href \"\" \"bloqade.pyqrack.reg.Measurement\"\n              click bloqade.types.MeasurementResult href \"\" \"bloqade.types.MeasurementResult\"\n            </code></pre> <p>Enumeration of measurement results.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/reg.py</code> <pre><code>def __init__(self, measurement_id: int = 0) -&gt; None:\n    super().__init__()\n    self.measurement_id = measurement_id\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit","title":"PyQrackQubit  <code>dataclass</code>","text":"<pre><code>PyQrackQubit(\n    addr: int, sim_reg: QrackSimulator, state: QubitState\n)\n</code></pre> <p>               Bases: <code>Qubit</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.reg.PyQrackQubit[PyQrackQubit]\n              bloqade.types.Qubit[Qubit]\n\n                              bloqade.types.Qubit --&gt; bloqade.pyqrack.reg.PyQrackQubit\n                \n\n\n              click bloqade.pyqrack.reg.PyQrackQubit href \"\" \"bloqade.pyqrack.reg.PyQrackQubit\"\n              click bloqade.types.Qubit href \"\" \"bloqade.types.Qubit\"\n            </code></pre> <p>The runtime representation of a qubit reference.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.addr","title":"addr  <code>instance-attribute</code>","text":"<pre><code>addr: int\n</code></pre> <p>The address of this qubit in the quantum register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.sim_reg","title":"sim_reg  <code>instance-attribute</code>","text":"<pre><code>sim_reg: QrackSimulator\n</code></pre> <p>The register of the simulator.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.state","title":"state  <code>instance-attribute</code>","text":"<pre><code>state: QubitState\n</code></pre> <p>The state of the qubit (active/lost)</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.drop","title":"drop","text":"<pre><code>drop()\n</code></pre> <p>Drop the qubit in-place.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/reg.py</code> <pre><code>def drop(self):\n    \"\"\"Drop the qubit in-place.\"\"\"\n    self.state = QubitState.Lost\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/reg/#bloqade.pyqrack.reg.PyQrackQubit.is_active","title":"is_active","text":"<pre><code>is_active() -&gt; bool\n</code></pre> <p>Check if the qubit is active.</p> <p>Returns     True if the qubit is active, False otherwise.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/reg.py</code> <pre><code>def is_active(self) -&gt; bool:\n    \"\"\"Check if the qubit is active.\n\n    Returns\n        True if the qubit is active, False otherwise.\n\n    \"\"\"\n    return self.state is QubitState.Active\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/","title":"Target","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack","title":"PyQrack  <code>dataclass</code>","text":"<pre><code>PyQrack(\n    min_qubits: int = 0,\n    dynamic_qubits: bool = False,\n    pyqrack_options: PyQrackOptions = _default_pyqrack_args(),\n)\n</code></pre> <p>PyQrack target runtime for Bloqade.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.dynamic_qubits","title":"dynamic_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>dynamic_qubits: bool = False\n</code></pre> <p>Whether to use dynamic qubit allocation. Cannot use with tensor network simulations.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.min_qubits","title":"min_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>min_qubits: int = 0\n</code></pre> <p>Minimum number of qubits required for the PyQrack simulator. Useful when address analysis fails to determine the number of qubits.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.pyqrack_options","title":"pyqrack_options  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>pyqrack_options: PyQrackOptions = field(\n    default_factory=_default_pyqrack_args\n)\n</code></pre> <p>Options to pass to the QrackSimulator object, node <code>qubitCount</code> will be overwritten.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.multi_run","title":"multi_run","text":"<pre><code>multi_run(\n    mt: Method[Params, RetType],\n    _shots: int,\n    *args: args,\n    **kwargs: kwargs\n) -&gt; List[RetType]\n</code></pre> <p>Run the given kernel method on the PyQrack <code>_shots</code> times, caching analysis results.</p> <p>Args     mt (Method):         The kernel method to run.     _shots (int):         The number of times to run the kernel method.</p> <p>Returns     List of results of the kernel method, one for each shot.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/target.py</code> <pre><code>def multi_run(\n    self,\n    mt: ir.Method[Params, RetType],\n    _shots: int,\n    *args: Params.args,\n    **kwargs: Params.kwargs,\n) -&gt; List[RetType]:\n    \"\"\"Run the given kernel method on the PyQrack `_shots` times, caching analysis results.\n\n    Args\n        mt (Method):\n            The kernel method to run.\n        _shots (int):\n            The number of times to run the kernel method.\n\n    Returns\n        List of results of the kernel method, one for each shot.\n\n    \"\"\"\n    fold = Fold(mt.dialects)\n    fold(mt)\n\n    interpreter = self._get_interp(mt)\n    batched_results = []\n    for _ in range(_shots):\n        batched_results.append(interpreter.run(mt, args, kwargs))\n\n    return batched_results\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/target/#bloqade.pyqrack.target.PyQrack.run","title":"run","text":"<pre><code>run(\n    mt: Method[Params, RetType],\n    *args: args,\n    **kwargs: kwargs\n) -&gt; RetType\n</code></pre> <p>Run the given kernel method on the PyQrack simulator.</p> <p>Args     mt (Method):         The kernel method to run.</p> <p>Returns     The result of the kernel method, if any.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/target.py</code> <pre><code>def run(\n    self,\n    mt: ir.Method[Params, RetType],\n    *args: Params.args,\n    **kwargs: Params.kwargs,\n) -&gt; RetType:\n    \"\"\"Run the given kernel method on the PyQrack simulator.\n\n    Args\n        mt (Method):\n            The kernel method to run.\n\n    Returns\n        The result of the kernel method, if any.\n\n    \"\"\"\n    fold = Fold(mt.dialects)\n    fold(mt)\n    _, ret = self._get_interp(mt).run(mt, *args, **kwargs)\n    return ret\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/","title":"Task","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask","title":"PyQrackSimulatorTask  <code>dataclass</code>","text":"<pre><code>PyQrackSimulatorTask(\n    kernel: Method[Params, RetType],\n    args: tuple[Any, ...],\n    kwargs: dict[str, Any],\n    pyqrack_interp: PyQrackInterpreter[MemoryType],\n)\n</code></pre> <p>               Bases: <code>AbstractSimulatorTask[Param, RetType, MemoryType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.pyqrack.task.PyQrackSimulatorTask[PyQrackSimulatorTask]\n              bloqade.task.AbstractSimulatorTask[AbstractSimulatorTask]\n              bloqade.task.AbstractTask[AbstractTask]\n\n                              bloqade.task.AbstractSimulatorTask --&gt; bloqade.pyqrack.task.PyQrackSimulatorTask\n                                bloqade.task.AbstractTask --&gt; bloqade.task.AbstractSimulatorTask\n                \n\n\n\n              click bloqade.pyqrack.task.PyQrackSimulatorTask href \"\" \"bloqade.pyqrack.task.PyQrackSimulatorTask\"\n              click bloqade.task.AbstractSimulatorTask href \"\" \"bloqade.task.AbstractSimulatorTask\"\n              click bloqade.task.AbstractTask href \"\" \"bloqade.task.AbstractTask\"\n            </code></pre> <p>PyQrack simulator task for Bloqade.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask.state","title":"state  <code>property</code>","text":"<pre><code>state: MemoryType\n</code></pre> <p>Returns the state of the simulator after running the task.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask.batch_run","title":"batch_run","text":"<pre><code>batch_run(shots: int = 1) -&gt; dict[RetType, float]\n</code></pre> <p>Repeatedly run the task to collect statistics on the shot outcomes. The average is done over [shots] repetitions and thus is frequentist and converges to exact only in the shots -&gt; infinity limit.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>the number of repetitions of the task</p> <code>1</code> <p>Returns:     dict[RetType, float]:         a dictionary mapping outcomes to their probabilities,         as estimated from counting the shot outcomes. RetType must be hashable.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/task.py</code> <pre><code>def batch_run(self, shots: int = 1) -&gt; dict[RetType, float]:\n    \"\"\"\n    Repeatedly run the task to collect statistics on the shot outcomes.\n    The average is done over [shots] repetitions and thus is frequentist\n    and converges to exact only in the shots -&gt; infinity limit.\n\n    Args:\n        shots (int):\n            the number of repetitions of the task\n    Returns:\n        dict[RetType, float]:\n            a dictionary mapping outcomes to their probabilities,\n            as estimated from counting the shot outcomes. RetType must be hashable.\n    \"\"\"\n\n    results: list[RetType] = [self.run() for _ in range(shots)]\n\n    # Convert IList to tuple so that it is hashable by Counter\n    def convert(data):\n        if isinstance(data, (list, IList)):\n            return tuple(convert(item) for item in data)\n        return data\n\n    results = convert(results)\n\n    data = {\n        key: value / len(results) for key, value in Counter(results).items()\n    }  # Normalize to probabilities\n    return data\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask.batch_state","title":"batch_state","text":"<pre><code>batch_state(\n    shots: int = 1, qubit_map: None = None\n) -&gt; QuantumState\n</code></pre> <p>Repeatedly run the task to extract the averaged quantum state. The average is done over [shots] repetitions and thus is frequentist and converges to exact only in the shots -&gt; infinity limit.</p> <p>Parameters:</p> Name Type Description Default <code>shots</code> <code>int</code> <p>the number of repetitions of the task</p> <code>1</code> <code>qubit_map</code> <code>callable | None</code> <p>an optional callable that takes the output of self.run() and extract the [returned] qubits to be used for the quantum state. If None, all qubits in the simulator are used, in the order set by the simulator. If callable, qubit_map must have the signature</p> <p>qubit_map(output:RetType) -&gt; list[PyQrackQubit] and the averaged state is quantum_state(qubit_map(self.run())). If qubit_map is not None, self.run() must return qubit(s). Two common patterns here are: qubit_map = lambda qubits: qubits for the case where self.run() returns a list of qubits, or qubit_map = lambda qubit: [qubits] for the case where self.run() returns a single qubit.</p> <code>None</code> <p>Returns:     QuantumState:         the averaged quantum state as a density matrix,         represented in its eigenbasis.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/task.py</code> <pre><code>def batch_state(\n    self, shots: int = 1, qubit_map: None = None\n) -&gt; \"QuantumState\":  # noqa: F821\n    \"\"\"\n    Repeatedly run the task to extract the averaged quantum state.\n    The average is done over [shots] repetitions and thus is frequentist\n    and converges to exact only in the shots -&gt; infinity limit.\n\n    Args:\n        shots (int):\n            the number of repetitions of the task\n        qubit_map (callable | None):\n            an optional callable that takes the output of self.run() and extract\n            the [returned] qubits to be used for the quantum state.\n            If None, all qubits in the simulator are used, in the order set by the simulator.\n            If callable, qubit_map must have the signature\n            &gt; qubit_map(output:RetType) -&gt; list[PyQrackQubit]\n            and the averaged state is\n            &gt; quantum_state(qubit_map(self.run())).\n            If qubit_map is not None, self.run() must return qubit(s).\n            Two common patterns here are:\n             &gt; qubit_map = lambda qubits: qubits\n            for the case where self.run() returns a list of qubits, or\n             &gt; qubit_map = lambda qubit: [qubits]\n            for the case where self.run() returns a single qubit.\n    Returns:\n        QuantumState:\n            the averaged quantum state as a density matrix,\n            represented in its eigenbasis.\n    \"\"\"\n    # Import here to avoid circular dependencies.\n    from bloqade.pyqrack.device import QuantumState, PyQrackSimulatorBase\n\n    states: list[QuantumState] = []\n    for _ in range(shots):\n        res = self.run()\n        if callable(qubit_map):\n            qbs = qubit_map(res)\n        else:\n            qbs = self.qubits()\n        states.append(PyQrackSimulatorBase.quantum_state(qbs))\n\n    state = QuantumState(\n        eigenvectors=np.concatenate(\n            [state.eigenvectors for state in states], axis=1\n        ),\n        eigenvalues=np.concatenate([state.eigenvalues for state in states], axis=0)\n        / len(states),\n    )\n\n    # Canonicalize the state by orthoganalizing the basis vectors.\n    tol = 1e-7\n    s, v, d = np.linalg.svd(\n        state.eigenvectors * np.sqrt(state.eigenvalues), full_matrices=False\n    )\n    mask = v &gt; tol\n    v = v[mask] ** 2\n    s = s[:, mask]\n    return QuantumState(eigenvalues=v, eigenvectors=s)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask.qubits","title":"qubits","text":"<pre><code>qubits() -&gt; list[PyQrackQubit]\n</code></pre> <p>Returns the qubits in the simulator.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/task.py</code> <pre><code>def qubits(self) -&gt; list[PyQrackQubit]:\n    \"\"\"Returns the qubits in the simulator.\"\"\"\n    try:\n        N = self.state.sim_reg.num_qubits()\n        return [\n            PyQrackQubit(\n                addr=i, sim_reg=self.state.sim_reg, state=QubitState.Active\n            )\n            for i in range(N)\n        ]\n    except AttributeError:\n        Warning(\"Task has not been run, there are no qubits!\")\n        return []\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask.run","title":"run","text":"<pre><code>run() -&gt; RetType\n</code></pre> <p>Executes the kernel and returns the result.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/task.py</code> <pre><code>def run(self) -&gt; RetType:\n    _, ret = self.pyqrack_interp.run(\n        self.kernel,\n        *self.args,\n        **self.kwargs,\n    )\n    return cast(RetType, ret)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/task/#bloqade.pyqrack.task.PyQrackSimulatorTask.state_vector","title":"state_vector","text":"<pre><code>state_vector() -&gt; list[complex]\n</code></pre> <p>Returns the state vector of the simulator.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/pyqrack/task.py</code> <pre><code>def state_vector(self) -&gt; list[complex]:\n    \"\"\"Returns the state vector of the simulator.\"\"\"\n    self.run()\n    return self.state.sim_reg.out_ket()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/noise/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/noise/native/","title":"Native","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/qasm2/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/qasm2/core/","title":"Core","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/qasm2/glob/","title":"Glob","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/qasm2/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/qasm2/uop/","title":"Uop","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/squin/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/squin/qubit/","title":"Qubit","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/squin/gate/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/squin/gate/gate/","title":"Gate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/squin/noise/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/pyqrack/squin/noise/native/","title":"Native","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.barrier","title":"barrier","text":"<pre><code>barrier(qargs: tuple[Qubit, ...]) -&gt; None\n</code></pre> <p>Barrier instruction.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>tuple[Qubit, ...]</code> <p>The qubits to apply the barrier to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Barrier)\ndef barrier(qargs: tuple[Qubit, ...]) -&gt; None:\n    \"\"\"\n    Barrier instruction.\n\n    Args:\n        qargs: The qubits to apply the barrier to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.ccx","title":"ccx","text":"<pre><code>ccx(ctrl1: Qubit, ctrl2: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Toffoli gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl1</code> <code>Qubit</code> <p>The first control qubit.</p> required <code>ctrl2</code> <code>Qubit</code> <p>The second control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CCX)\ndef ccx(ctrl1: Qubit, ctrl2: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Toffoli gate.\n\n    Args:\n        ctrl1: The first control qubit.\n        ctrl2: The second control qubit.\n        qarg: The target qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.ch","title":"ch","text":"<pre><code>ch(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Hadamard gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CH)\ndef ch(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Hadamard gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cos","title":"cos","text":"<pre><code>cos(value: float) -&gt; float\n</code></pre> <p>Cosine math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the cosine of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The cosine of <code>value</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Cos)\ndef cos(value: float) -&gt; float:\n    \"\"\"\n    Cosine math function.\n\n    Args:\n        value: The value to take the cosine of.\n\n    Returns:\n        The cosine of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cp","title":"cp","text":"<pre><code>cp(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled phase rotation gate. Same as cu1</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU1)\ndef cp(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled phase rotation gate. Same as cu1\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.creg","title":"creg","text":"<pre><code>creg(n_bits: int) -&gt; CReg\n</code></pre> <p>Create a new classical register with <code>n_bits</code> bits.</p> <p>Parameters:</p> Name Type Description Default <code>n_bits</code> <code>int</code> <p>The number of bits in the register.</p> required <p>Returns:</p> Type Description <code>CReg</code> <p>The newly created classical register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.CRegNew)\ndef creg(n_bits: int) -&gt; CReg:\n    \"\"\"\n    Create a new classical register with `n_bits` bits.\n\n    Args:\n        n_bits: The number of bits in the register.\n\n    Returns:\n        The newly created classical register.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.crx","title":"crx","text":"<pre><code>crx(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled Rx rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CRX)\ndef crx(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled Rx rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cry","title":"cry","text":"<pre><code>cry(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled Ry rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CRY)\ndef cry(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled Ry rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.crz","title":"crz","text":"<pre><code>crz(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled Rz rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CRZ)\ndef crz(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled Rz rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cswap","title":"cswap","text":"<pre><code>cswap(ctrl: Qubit, qarg1: Qubit, qarg2: Qubit) -&gt; None\n</code></pre> <p>Controlled Swap gate (Fredkin gate).</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg1</code> <code>Qubit</code> <p>The first target qubit.</p> required <code>qarg2</code> <code>Qubit</code> <p>The second target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CSwap)\ndef cswap(ctrl: Qubit, qarg1: Qubit, qarg2: Qubit) -&gt; None:\n    \"\"\"\n    Controlled Swap gate (Fredkin gate).\n\n    Args:\n        ctrl: The control qubit.\n        qarg1: The first target qubit.\n        qarg2: The second target qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.csx","title":"csx","text":"<pre><code>csx(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Sqrt(X) gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CSX)\ndef csx(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Sqrt(X) gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cu","title":"cu","text":"<pre><code>cu(\n    ctrl: Qubit,\n    qarg: Qubit,\n    theta: float,\n    phi: float,\n    lam: float,\n    gamma: float,\n) -&gt; None\n</code></pre> <p>Controlled 4-parameter unitary gate.</p> <p>This is equal to:</p> <p>gate cu(theta,phi,lambda,gamma) c, t{     p(gamma) c;     p((lambda+phi)/2) c;     p((lambda-phi)/2) t;     cx c,t;     u(-theta/2,0,-(phi+lambda)/2) t;     cx c,t;     u(theta/2,phi,0) t; }</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required <code>phi</code> <code>float</code> <p>The angle of rotation.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required <code>gamma</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU)\ndef cu(\n    ctrl: Qubit, qarg: Qubit, theta: float, phi: float, lam: float, gamma: float\n) -&gt; None:\n    \"\"\"\n    Controlled 4-parameter unitary gate.\n\n    This is equal to:\n\n    gate cu(theta,phi,lambda,gamma) c, t{\n        p(gamma) c;\n        p((lambda+phi)/2) c;\n        p((lambda-phi)/2) t;\n        cx c,t;\n        u(-theta/2,0,-(phi+lambda)/2) t;\n        cx c,t;\n        u(theta/2,phi,0) t;\n    }\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        theta: The angle of rotation.\n        phi: The angle of rotation.\n        lam: The angle of rotation.\n        gamma: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cu1","title":"cu1","text":"<pre><code>cu1(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Controlled phase rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU1)\ndef cu1(ctrl: Qubit, qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Controlled phase rotation gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        lam: The angle of rotation.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cu3","title":"cu3","text":"<pre><code>cu3(\n    ctrl: Qubit,\n    qarg: Qubit,\n    theta: float,\n    phi: float,\n    lam: float,\n) -&gt; None\n</code></pre> <p>Controlled 3-parameter unitary gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required <code>phi</code> <code>float</code> <p>The angle of rotation.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CU3)\ndef cu3(ctrl: Qubit, qarg: Qubit, theta: float, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    Controlled 3-parameter unitary gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n        theta: The angle of rotation.\n        phi: The angle of rotation.\n        lam: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cx","title":"cx","text":"<pre><code>cx(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-X (CNOT) gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CX)\ndef cx(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-X (CNOT) gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cy","title":"cy","text":"<pre><code>cy(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Y gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CY)\ndef cy(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Y gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.cz","title":"cz","text":"<pre><code>cz(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Controlled-Z gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The control qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The target qubit</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.CZ)\ndef cz(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Controlled-Z gate.\n\n    Args:\n        ctrl: The control qubit.\n        qarg: The target qubit\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.exp","title":"exp","text":"<pre><code>exp(value: float) -&gt; float\n</code></pre> <p>Exponential math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to exponentiate.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The exponential of <code>value</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Exp)\ndef exp(value: float) -&gt; float:\n    \"\"\"\n    Exponential math function.\n\n    Args:\n        value: The value to exponentiate.\n\n    Returns:\n        The exponential of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.h","title":"h","text":"<pre><code>h(qarg: Qubit) -&gt; None\n</code></pre> <p>Hadamard gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.H)\ndef h(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hadamard gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.id","title":"id","text":"<pre><code>id(qarg: Qubit) -&gt; None\n</code></pre> <p>Identity gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Id)\ndef id(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Identity gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.inline","title":"inline","text":"<pre><code>inline(text: str) -&gt; None\n</code></pre> <p>Inline QASM code into the current program.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>The QASM code to inline.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(inline_.InlineQASM)\ndef inline(text: str) -&gt; None:\n    \"\"\"\n    Inline QASM code into the current program.\n\n    Args:\n        text: The QASM code to inline.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.ln","title":"ln","text":"<pre><code>ln(value: float) -&gt; float\n</code></pre> <p>logarithm math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the natural logarithm of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The natural logarithm of <code>value</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Log)\ndef ln(value: float) -&gt; float:\n    \"\"\"\n    logarithm math function.\n\n    Args:\n        value: The value to take the natural logarithm of.\n\n    Returns:\n        The natural logarithm of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.measure","title":"measure","text":"<pre><code>measure(qreg: QReg, creg: CReg) -&gt; None\n</code></pre><pre><code>measure(qarg: Qubit, cbit: Bit) -&gt; None\n</code></pre> <pre><code>measure(qarg, cbit) -&gt; None\n</code></pre> <p>Measure the qubit <code>qarg</code> and store the result in the classical bit <code>cbit</code>.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <p>The qubit to measure.</p> required <code>cbit</code> <p>The classical bit to store the result in.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.Measure)\ndef measure(qarg, cbit) -&gt; None:\n    \"\"\"\n    Measure the qubit `qarg` and store the result in the classical bit `cbit`.\n\n    Args:\n        qarg: The qubit to measure.\n        cbit: The classical bit to store the result in.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.p","title":"p","text":"<pre><code>p(qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>Phase gate.</p> <p>This is equivalent to u(0,0,lam), and u1(lam)</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>lam</code> <code>float</code> <p>The angle of phase.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.U1)\ndef p(qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    Phase gate.\n\n    This is equivalent to u(0,0,lam), and u1(lam)\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        lam: The angle of phase.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.qreg","title":"qreg","text":"<pre><code>qreg(n_qubits: int) -&gt; QReg\n</code></pre> <p>Create a new quantum register with <code>n_qubits</code> qubits.</p> <p>Parameters:</p> Name Type Description Default <code>n_qubits</code> <code>int</code> <p>The number of qubits in the register.</p> required <p>Returns:</p> Type Description <code>QReg</code> <p>The newly created quantum register.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.QRegNew)\ndef qreg(n_qubits: int) -&gt; QReg:\n    \"\"\"\n    Create a new quantum register with `n_qubits` qubits.\n\n    Args:\n        n_qubits: The number of qubits in the register.\n\n    Returns:\n        The newly created quantum register.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.reset","title":"reset","text":"<pre><code>reset(qarg: Qubit) -&gt; None\n</code></pre> <p>Reset the qubit <code>qarg</code> to the |0\u27e9 state.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to reset.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(core.Reset)\ndef reset(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Reset the qubit `qarg` to the |0\u27e9 state.\n\n    Args:\n        qarg: The qubit to reset.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.rx","title":"rx","text":"<pre><code>rx(qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>Single qubit rotation about the X axis on block sphere</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RX)\ndef rx(qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    Single qubit rotation about the X axis on block sphere\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.rxx","title":"rxx","text":"<pre><code>rxx(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>XX rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The first qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The second qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RXX)\ndef rxx(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    XX rotation gate.\n\n    Args:\n        ctrl: The first qubit.\n        qarg: The second qubit.\n        theta: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.ry","title":"ry","text":"<pre><code>ry(qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>Single qubit rotation about the Y axis on block sphere</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RY)\ndef ry(qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    Single qubit rotation about the Y axis on block sphere\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.rz","title":"rz","text":"<pre><code>rz(qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>Single qubit rotation about the Z axis on block sphere</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RZ)\ndef rz(qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    Single qubit rotation about the Z axis on block sphere\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.rzz","title":"rzz","text":"<pre><code>rzz(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None\n</code></pre> <p>ZZ rotation gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The first qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The second qubit.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.RZZ)\ndef rzz(ctrl: Qubit, qarg: Qubit, theta: float) -&gt; None:\n    \"\"\"\n    ZZ rotation gate.\n\n    Args:\n        ctrl: The first qubit.\n        qarg: The second qubit.\n        theta: The angle of rotation.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.s","title":"s","text":"<pre><code>s(qarg: Qubit) -&gt; None\n</code></pre> <p>S gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.S)\ndef s(qarg: Qubit) -&gt; None:\n    \"\"\"\n    S gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.sdg","title":"sdg","text":"<pre><code>sdg(qarg: Qubit) -&gt; None\n</code></pre> <p>Hermitian conjugate of the S gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Sdag)\ndef sdg(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hermitian conjugate of the S gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.sin","title":"sin","text":"<pre><code>sin(value: float) -&gt; float\n</code></pre> <p>Sine math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the sine of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The sine of <code>value</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Sin)\ndef sin(value: float) -&gt; float:\n    \"\"\"\n    Sine math function.\n\n    Args:\n        value: The value to take the sine of.\n\n    Returns:\n        The sine of `value`.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.sqrt","title":"sqrt","text":"<pre><code>sqrt(value: float) -&gt; float\n</code></pre> <p>Square root math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the square root of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The square root of <code>value</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Sqrt)\ndef sqrt(value: float) -&gt; float:\n    \"\"\"\n    Square root math function.\n\n    Args:\n        value: The value to take the square root of.\n\n    Returns:\n        The square root of `value`.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.swap","title":"swap","text":"<pre><code>swap(ctrl: Qubit, qarg: Qubit) -&gt; None\n</code></pre> <p>Swap gate.</p> <p>Parameters:</p> Name Type Description Default <code>ctrl</code> <code>Qubit</code> <p>The first qubit.</p> required <code>qarg</code> <code>Qubit</code> <p>The second qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Swap)\ndef swap(ctrl: Qubit, qarg: Qubit) -&gt; None:\n    \"\"\"\n    Swap gate.\n\n    Args:\n        ctrl: The first qubit.\n        qarg: The second qubit.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.sx","title":"sx","text":"<pre><code>sx(qarg: Qubit) -&gt; None\n</code></pre> <p>Sqrt(X) gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.SX)\ndef sx(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Sqrt(X) gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.sxdg","title":"sxdg","text":"<pre><code>sxdg(qarg: Qubit) -&gt; None\n</code></pre> <p>Hermitian conjugate of Sqrt(X) gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.SXdag)\ndef sxdg(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hermitian conjugate of Sqrt(X) gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.t","title":"t","text":"<pre><code>t(qarg: Qubit) -&gt; None\n</code></pre> <p>T gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.T)\ndef t(qarg: Qubit) -&gt; None:\n    \"\"\"\n    T gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.tan","title":"tan","text":"<pre><code>tan(value: float) -&gt; float\n</code></pre> <p>Tangent math function.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>float</code> <p>The value to take the tangent of.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The tangent of <code>value</code>.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(expr.Tan)\ndef tan(value: float) -&gt; float:\n    \"\"\"\n    Tangent math function.\n\n    Args:\n        value: The value to take the tangent of.\n\n    Returns:\n        The tangent of `value`.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.tdg","title":"tdg","text":"<pre><code>tdg(qarg: Qubit) -&gt; None\n</code></pre> <p>Hermitian conjugate of the T gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Tdag)\ndef tdg(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Hermitian conjugate of the T gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.u","title":"u","text":"<pre><code>u(\n    qarg: Qubit, theta: float, phi: float, lam: float\n) -&gt; None\n</code></pre> <p>U gate.</p> Note <p>See https://arxiv.org/pdf/1707.03429 for definition of angles.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation</p> required <code>phi</code> <code>float</code> <p>The angle of rotation</p> required <code>lam</code> <code>float</code> <p>The angle of rotation</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.UGate)\ndef u(qarg: Qubit, theta: float, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    U gate.\n\n    Note:\n        See https://arxiv.org/pdf/1707.03429 for definition of angles.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation\n        phi: The angle of rotation\n        lam: The angle of rotation\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.u1","title":"u1","text":"<pre><code>u1(qarg: Qubit, lam: float) -&gt; None\n</code></pre> <p>1 Parameter single qubit unitary gate.</p> <p>This is equivalent to u(0,0,lambda).</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.U1)\ndef u1(qarg: Qubit, lam: float) -&gt; None:\n    \"\"\"\n    1 Parameter single qubit unitary gate.\n\n    This is equivalent to u(0,0,lambda).\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        lam: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.u2","title":"u2","text":"<pre><code>u2(qarg: Qubit, phi: float, lam: float) -&gt; None\n</code></pre> <p>2 Parameter single qubit unitary gate.</p> <p>This is equivalent to u(pi/2,phi,lambda)</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>phi</code> <code>float</code> <p>The angle of rotation.</p> required <code>lam</code> <code>float</code> <p>The angle of rotation.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.U2)\ndef u2(qarg: Qubit, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    2 Parameter single qubit unitary gate.\n\n    This is equivalent to u(pi/2,phi,lambda)\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        phi: The angle of rotation.\n        lam: The angle of rotation.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.u3","title":"u3","text":"<pre><code>u3(\n    qarg: Qubit, theta: float, phi: float, lam: float\n) -&gt; None\n</code></pre> <p>U3 gate, same as u</p> Note <p>See https://arxiv.org/pdf/1707.03429 for definition of angles.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required <code>theta</code> <code>float</code> <p>The angle of rotation</p> required <code>phi</code> <code>float</code> <p>The angle of rotation</p> required <code>lam</code> <code>float</code> <p>The angle of rotation</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.UGate)\ndef u3(qarg: Qubit, theta: float, phi: float, lam: float) -&gt; None:\n    \"\"\"\n    U3 gate, same as u\n\n    Note:\n        See https://arxiv.org/pdf/1707.03429 for definition of angles.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n        theta: The angle of rotation\n        phi: The angle of rotation\n        lam: The angle of rotation\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.x","title":"x","text":"<pre><code>x(qarg: Qubit) -&gt; None\n</code></pre> <p>Pauli-X gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.X)\ndef x(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Pauli-X gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n    \"\"\"\n\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.y","title":"y","text":"<pre><code>y(qarg: Qubit) -&gt; None\n</code></pre> <p>Pauli-Y gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Y)\ndef y(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Pauli-Y gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/#bloqade.qasm2.z","title":"z","text":"<pre><code>z(qarg: Qubit) -&gt; None\n</code></pre> <p>Pauli-Z gate.</p> <p>Parameters:</p> Name Type Description Default <code>qarg</code> <code>Qubit</code> <p>The qubit to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/_wrappers.py</code> <pre><code>@wraps(uop.Z)\ndef z(qarg: Qubit) -&gt; None:\n    \"\"\"\n    Pauli-Z gate.\n\n    Args:\n        qarg: The qubit to apply the gate to.\n\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/glob/","title":"Glob","text":"<p>QASM2 extension for global gates.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/glob/#bloqade.qasm2.glob.u","title":"u","text":"<pre><code>u(\n    registers: IList[QReg, Any] | list,\n    theta: float,\n    phi: float,\n    lam: float,\n) -&gt; None\n</code></pre> <p>Apply a U gate to all qubits in the input registers.</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>The angle theta.</p> required <code>phi</code> <code>float</code> <p>The angle phi.</p> required <code>lam</code> <code>float</code> <p>The angle lam.</p> required <code>registers</code> <code>IList[QReg] | list[QReg]</code> <p>The registers to apply the gate to.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/glob.py</code> <pre><code>@wraps(glob.UGate)\ndef u(\n    registers: ilist.IList[QReg, Any] | list, theta: float, phi: float, lam: float\n) -&gt; None:\n    \"\"\"Apply a U gate to all qubits in the input registers.\n\n    Args:\n        theta (float): The angle theta.\n        phi (float): The angle phi.\n        lam (float): The angle lam.\n        registers (IList[QReg] | list[QReg]): The registers to apply the gate to.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/groups/","title":"Groups","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/noise/","title":"Noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/noise/#bloqade.qasm2.noise.atom_loss_channel","title":"atom_loss_channel","text":"<pre><code>atom_loss_channel(\n    qargs: IList[Qubit, Any] | list, *, prob: float\n) -&gt; None\n</code></pre> <p>Apply an atom loss channel to a list of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>IList[Qubit, Any] | list</code> <p>List of qubits to apply the noise to.</p> required <code>prob</code> <code>float</code> <p>The loss probability.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/noise.py</code> <pre><code>@wraps(noise.AtomLossChannel)\ndef atom_loss_channel(qargs: ilist.IList[Qubit, Any] | list, *, prob: float) -&gt; None:\n    \"\"\"Apply an atom loss channel to a list of qubits.\n\n    Args:\n        qargs (ilist.IList[Qubit, Any] | list): List of qubits to apply the noise to.\n        prob (float): The loss probability.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/noise/#bloqade.qasm2.noise.cz_pauli_channel","title":"cz_pauli_channel","text":"<pre><code>cz_pauli_channel(\n    ctrls: IList[Qubit, Any] | list,\n    qargs: IList[Qubit, Any] | list,\n    *,\n    px_ctrl: float,\n    py_ctrl: float,\n    pz_ctrl: float,\n    px_qarg: float,\n    py_qarg: float,\n    pz_qarg: float,\n    paired: bool\n) -&gt; None\n</code></pre> <p>Insert noise for a CZ gate with a Pauli channel on qubits.</p> <p>Parameters:</p> Name Type Description Default <code>ctrls</code> <code>IList[Qubit, Any] | list</code> <p>List of control qubits.</p> required <code>qarg2</code> <p>List of target qubits.</p> required <code>px_ctrl</code> <code>float</code> <p>Probability of X error on control qubits.</p> required <code>py_ctrl</code> <code>float</code> <p>Probability of Y error on control qubits.</p> required <code>pz_ctrl</code> <code>float</code> <p>Probability of Z error on control qubits.</p> required <code>px_qarg</code> <code>float</code> <p>Probability of X error on target qubits.</p> required <code>py_qarg</code> <code>float</code> <p>Probability of Y error on target qubits.</p> required <code>pz_qarg</code> <code>float</code> <p>Probability of Z error on target qubits.</p> required <code>paired</code> <code>bool</code> <p>If True, the noise is applied to both control and target qubits are not lost otherwise skip this error. If False Apply the noise on the whatever qubit is not lost.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/noise.py</code> <pre><code>@wraps(noise.CZPauliChannel)\ndef cz_pauli_channel(\n    ctrls: ilist.IList[Qubit, Any] | list,\n    qargs: ilist.IList[Qubit, Any] | list,\n    *,\n    px_ctrl: float,\n    py_ctrl: float,\n    pz_ctrl: float,\n    px_qarg: float,\n    py_qarg: float,\n    pz_qarg: float,\n    paired: bool,\n) -&gt; None:\n    \"\"\"Insert noise for a CZ gate with a Pauli channel on qubits.\n\n    Args:\n        ctrls: List of control qubits.\n        qarg2: List of target qubits.\n        px_ctrl: Probability of X error on control qubits.\n        py_ctrl: Probability of Y error on control qubits.\n        pz_ctrl: Probability of Z error on control qubits.\n        px_qarg: Probability of X error on target qubits.\n        py_qarg: Probability of Y error on target qubits.\n        pz_qarg: Probability of Z error on target qubits.\n        paired: If True, the noise is applied to both control and target qubits\n            are not lost otherwise skip this error. If False Apply the noise on\n            the whatever qubit is not lost.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/noise/#bloqade.qasm2.noise.pauli_channel","title":"pauli_channel","text":"<pre><code>pauli_channel(\n    qargs: IList[Qubit, Any] | list,\n    *,\n    px: float,\n    py: float,\n    pz: float\n) -&gt; None\n</code></pre> <p>Apply a Pauli channel to a list of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>IList[Qubit, Any] | list</code> <p>List of qubits to apply the noise to.</p> required <code>px</code> <code>float</code> <p>Probability of X error.</p> required <code>py</code> <code>float</code> <p>Probability of Y error.</p> required <code>pz</code> <code>float</code> <p>Probability of Z error.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/noise.py</code> <pre><code>@wraps(noise.PauliChannel)\ndef pauli_channel(\n    qargs: ilist.IList[Qubit, Any] | list, *, px: float, py: float, pz: float\n) -&gt; None:\n    \"\"\"Apply a Pauli channel to a list of qubits.\n\n    Args:\n        qargs (ilist.IList[Qubit, Any] | list): List of qubits to apply the noise to.\n        px (float): Probability of X error.\n        py (float): Probability of Y error.\n        pz (float): Probability of Z error.\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parallel/","title":"Parallel","text":"<p>QASM2 extension for parallel execution of gates.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parallel/#bloqade.qasm2.parallel.cz","title":"cz","text":"<pre><code>cz(\n    ctrls: IList[Qubit, Any] | list,\n    qargs: IList[Qubit, Any] | list,\n) -&gt; None\n</code></pre> <p>Apply a controlled-Z gate to input qubits in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>ctrls</code> <code>IList[Qubit] | list[Qubit]</code> <p>The control qubits.</p> required <code>qargs</code> <code>IList[Qubit] | list[Qubit]</code> <p>The target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/parallel.py</code> <pre><code>@wraps(parallel.CZ)\ndef cz(\n    ctrls: ilist.IList[Qubit, Any] | list, qargs: ilist.IList[Qubit, Any] | list\n) -&gt; None:\n    \"\"\"Apply a controlled-Z gate to input qubits in parallel.\n\n    Args:\n        ctrls (IList[Qubit] | list[Qubit]): The control qubits.\n        qargs (IList[Qubit] | list[Qubit]): The target qubits.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parallel/#bloqade.qasm2.parallel.rz","title":"rz","text":"<pre><code>rz(qargs: IList[Qubit, Any] | list, theta: float) -&gt; None\n</code></pre> <p>Apply a RZ gate to input qubits in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>IList[Qubit] | list[Qubit]</code> <p>The target qubits.</p> required <code>theta</code> <code>float</code> <p>The angle theta.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/parallel.py</code> <pre><code>@wraps(parallel.RZ)\ndef rz(qargs: ilist.IList[Qubit, Any] | list, theta: float) -&gt; None:\n    \"\"\"Apply a RZ gate to input qubits in parallel.\n\n    Args:\n        qargs (IList[Qubit] | list[Qubit]): The target qubits.\n        theta (float): The angle theta.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parallel/#bloqade.qasm2.parallel.u","title":"u","text":"<pre><code>u(\n    qargs: IList[Qubit, Any] | list,\n    theta: float,\n    phi: float,\n    lam: float,\n) -&gt; None\n</code></pre> <p>Apply a U gate to input qubits in parallel.</p> <p>Parameters:</p> Name Type Description Default <code>qargs</code> <code>IList[Qubit] | list[Qubit]</code> <p>The target qubits.</p> required <code>theta</code> <code>float</code> <p>The angle theta.</p> required <code>phi</code> <code>float</code> <p>The angle phi.</p> required <code>lam</code> <code>float</code> <p>The angle lam.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/parallel.py</code> <pre><code>@wraps(parallel.UGate)\ndef u(\n    qargs: ilist.IList[Qubit, Any] | list, theta: float, phi: float, lam: float\n) -&gt; None:\n    \"\"\"Apply a U gate to input qubits in parallel.\n\n    Args:\n        qargs (IList[Qubit] | list[Qubit]): The target qubits.\n        theta (float): The angle theta.\n        phi (float): The angle phi.\n        lam (float): The angle lam.\n\n    \"\"\"\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/types/","title":"Types","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/types/#bloqade.qasm2.types.BitType","title":"BitType  <code>module-attribute</code>","text":"<pre><code>BitType = PyClass(Bit)\n</code></pre> <p>Kirin type for a classical bit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/types/#bloqade.qasm2.types.CRegType","title":"CRegType  <code>module-attribute</code>","text":"<pre><code>CRegType = PyClass(CReg)\n</code></pre> <p>Kirin type for a classical register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/types/#bloqade.qasm2.types.QRegType","title":"QRegType  <code>module-attribute</code>","text":"<pre><code>QRegType = IListType[QubitType, Any]\n</code></pre> <p>Kirin type for a quantum register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/types/#bloqade.qasm2.types.Bit","title":"Bit","text":"<p>Runtime representation of a bit.</p> Note <p>This is the base class of more specific bit types, such as a reference to a piece of classical register in some quantum register dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/types/#bloqade.qasm2.types.CReg","title":"CReg","text":"<p>Runtime representation of a classical register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/glob/","title":"Glob","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/indexing/","title":"Indexing","text":"<p>This dialect provides the indexing syntax in Python lowering for QASM2 dialects. The dialect itself does not contain new statements.</p> <p>Using this dialect will be conflict with Python semantics provided by <code>kirin.dialects.py.binop</code> and <code>kirin.dialects.py.indexing</code> dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/inline/","title":"Inline","text":"<p>Inline QASM dialect.</p> <p>This dialect allows users to use QASM string as part of a <code>@qasm2.main</code> kernel.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/address/","title":"Address","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq","title":"CRegEq","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.CRegEq[CRegEq]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.CRegEq href \"\" \"bloqade.qasm2.dialects.core.stmts.CRegEq\"\n            </code></pre> <p>Check if two classical registers are equal.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>lhs (CReg): The first register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (bool): True if the registers are equal, False otherwise.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>rhs (CReg): The second register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet","title":"CRegGet","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.CRegGet[CRegGet]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.CRegGet href \"\" \"bloqade.qasm2.dialects.core.stmts.CRegGet\"\n            </code></pre> <p>Get a bit from a classical register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the bit in the register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(CRegType)\n</code></pre> <p>reg (CReg): The classical register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(BitType)\n</code></pre> <p>result (Bit): The bit at position <code>idx</code>.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew","title":"CRegNew","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.CRegNew[CRegNew]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.CRegNew href \"\" \"bloqade.qasm2.dialects.core.stmts.CRegNew\"\n            </code></pre> <p>Create a new classical register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew.n_bits","title":"n_bits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_bits: SSAValue = argument(Int)\n</code></pre> <p>n_bits (Int): The number of bits in the register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(CRegType)\n</code></pre> <p>result (CReg): The new classical register with all bits set to 0.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure","title":"Measure","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.Measure[Measure]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.Measure href \"\" \"bloqade.qasm2.dialects.core.stmts.Measure\"\n            </code></pre> <p>Measure a qubit and store the result in a bit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure.carg","title":"carg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carg: SSAValue = argument(BitType | CRegType)\n</code></pre> <p>carg (Bit | CReg): The bit or register to store the result in.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType | QRegType)\n</code></pre> <p>qarg (Qubit | QReg): The qubit or quantum register to measure.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet","title":"QRegGet","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.QRegGet[QRegGet]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.QRegGet href \"\" \"bloqade.qasm2.dialects.core.stmts.QRegGet\"\n            </code></pre> <p>Get a qubit from a quantum register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the qubit in the register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(QRegType)\n</code></pre> <p>reg (QReg): The quantum register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QubitType)\n</code></pre> <p>result (Qubit): The qubit at position <code>idx</code>.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew","title":"QRegNew","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.QRegNew[QRegNew]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.QRegNew href \"\" \"bloqade.qasm2.dialects.core.stmts.QRegNew\"\n            </code></pre> <p>Create a new quantum register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew.n_qubits","title":"n_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_qubits: SSAValue = argument(Int)\n</code></pre> <p>n_qubits: The number of qubits in the register.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QRegType)\n</code></pre> <p>A new quantum register with n_qubits set to |0&gt;.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Reset","title":"Reset","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.core.stmts.Reset[Reset]\n\n              \n\n              click bloqade.qasm2.dialects.core.stmts.Reset href \"\" \"bloqade.qasm2.dialects.core.stmts.Reset\"\n            </code></pre> <p>Reset a qubit to the |0&gt; state.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Reset.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to reset.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add","title":"Add","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Add[Add]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Add href \"\" \"bloqade.qasm2.dialects.expr.stmts.Add\"\n            </code></pre> <p>Add two numbers.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the addition.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the addition.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the addition.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.ConstFloat[ConstFloat]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.ConstFloat href \"\" \"bloqade.qasm2.dialects.expr.stmts.ConstFloat\"\n            </code></pre> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.ConstInt[ConstInt]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.ConstInt href \"\" \"bloqade.qasm2.dialects.expr.stmts.ConstInt\"\n            </code></pre> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstPI","title":"ConstPI","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.ConstPI[ConstPI]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.ConstPI href \"\" \"bloqade.qasm2.dialects.expr.stmts.ConstPI\"\n            </code></pre> <p>The constant value of PI.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstPI.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (ConstPI): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos","title":"Cos","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Cos[Cos]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Cos href \"\" \"bloqade.qasm2.dialects.expr.stmts.Cos\"\n            </code></pre> <p>Take the cosine of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (float): The cosine of the number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the cosine of.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div","title":"Div","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Div[Div]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Div href \"\" \"bloqade.qasm2.dialects.expr.stmts.Div\"\n            </code></pre> <p>Divide two numbers.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The numerator.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the division.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The denominator.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp","title":"Exp","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Exp[Exp]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Exp href \"\" \"bloqade.qasm2.dialects.expr.stmts.Exp\"\n            </code></pre> <p>Take the exponential of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (float): The exponential of the number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the exponential of.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.GateFunction","title":"GateFunction","text":"<p>               Bases: <code>Function</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.GateFunction[GateFunction]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.GateFunction href \"\" \"bloqade.qasm2.dialects.expr.stmts.GateFunction\"\n            </code></pre> <p>Special Function for qasm2 gate subroutine.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log","title":"Log","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Log[Log]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Log href \"\" \"bloqade.qasm2.dialects.expr.stmts.Log\"\n            </code></pre> <p>Take the natural log of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (float): The natural log of the number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the natural log of.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul","title":"Mul","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Mul[Mul]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Mul href \"\" \"bloqade.qasm2.dialects.expr.stmts.Mul\"\n            </code></pre> <p>Multiply two numbers.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the multiplication.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the multiplication.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the multiplication.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Neg[Neg]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Neg href \"\" \"bloqade.qasm2.dialects.expr.stmts.Neg\"\n            </code></pre> <p>Negate a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The negated number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to negate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow","title":"Pow","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Pow[Pow]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Pow href \"\" \"bloqade.qasm2.dialects.expr.stmts.Pow\"\n            </code></pre> <p>Take the power of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The base.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the power operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The exponent.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin","title":"Sin","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Sin[Sin]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Sin href \"\" \"bloqade.qasm2.dialects.expr.stmts.Sin\"\n            </code></pre> <p>Take the sine of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (float): The sine of the number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the sine of.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt","title":"Sqrt","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Sqrt[Sqrt]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Sqrt href \"\" \"bloqade.qasm2.dialects.expr.stmts.Sqrt\"\n            </code></pre> <p>Take the square root of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (float): The square root of the number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the square root of.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub","title":"Sub","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Sub[Sub]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Sub href \"\" \"bloqade.qasm2.dialects.expr.stmts.Sub\"\n            </code></pre> <p>Subtract two numbers.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the subtraction.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the subtraction.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the subtraction.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan","title":"Tan","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.expr.stmts.Tan[Tan]\n\n              \n\n              click bloqade.qasm2.dialects.expr.stmts.Tan href \"\" \"bloqade.qasm2.dialects.expr.stmts.Tan\"\n            </code></pre> <p>Take the tangent of a number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (float): The tangent of the number.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the tangent of.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/","title":"Index","text":"<p>NOTE: This module is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/fidelity/","title":"Fidelity","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/","title":"Model","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC","title":"MoveNoiseModelABC  <code>dataclass</code>","text":"<pre><code>MoveNoiseModelABC(\n    *,\n    local_px: float = 0.0004102,\n    local_py: float = 0.0004102,\n    local_pz: float = 0.0004112,\n    local_loss_prob: float = 0.0,\n    local_unaddressed_px: float = 2e-07,\n    local_unaddressed_py: float = 2e-07,\n    local_unaddressed_pz: float = 1.2e-06,\n    local_unaddressed_loss_prob: float = 0.0,\n    global_px: float = 6.5e-05,\n    global_py: float = 6.5e-05,\n    global_pz: float = 6.5e-05,\n    global_loss_prob: float = 0.0,\n    cz_paired_gate_px: float = 0.0006549,\n    cz_paired_gate_py: float = 0.0006549,\n    cz_paired_gate_pz: float = 0.003184,\n    cz_gate_loss_prob: float = 0.0,\n    cz_unpaired_gate_px: float = 0.0005149,\n    cz_unpaired_gate_py: float = 0.0005149,\n    cz_unpaired_gate_pz: float = 0.002185,\n    cz_unpaired_loss_prob: float = 0.0,\n    mover_px: float = 0.000806,\n    mover_py: float = 0.000806,\n    mover_pz: float = 0.002458,\n    move_loss_prob: float = 0.0,\n    sitter_px: float = 0.0003066,\n    sitter_py: float = 0.0003066,\n    sitter_pz: float = 0.0004639,\n    sit_loss_prob: float = 0.0\n)\n</code></pre> <p>               Bases: <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC[MoveNoiseModelABC]\n\n              \n\n              click bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC href \"\" \"bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC\"\n            </code></pre> <p>Abstract base class for noise based on atom movement.</p> <p>This class defines the interface for a noise model. The gate noise is calculated from the parameters provided in this dataclass which can be updated when inheriting from this class. The move error is calculated by implementing the parallel_cz_errors method which takes a set of ctrl and qarg qubits and returns a noise model for all the qubits. The noise model is a dictionary with the keys being the error rates for the qubits and the values being the list of qubits that the error rate applies to.</p> <p>Once implemented the class can be used with the NoisePass to analyze a circuit and apply the noise model to the circuit.</p> <p>NOTE: This model is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_gate_loss_prob","title":"cz_gate_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_gate_loss_prob: float = field(default=0.0, kw_only=True)\n</code></pre> <p>The error probability for a loss during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_paired_errors","title":"cz_paired_errors  <code>property</code>","text":"<pre><code>cz_paired_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a CZ gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_paired_gate_px","title":"cz_paired_gate_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_gate_px: float = field(\n    default=0.0006549, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-X error during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_paired_gate_py","title":"cz_paired_gate_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_gate_py: float = field(\n    default=0.0006549, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-Y error during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_paired_gate_pz","title":"cz_paired_gate_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_paired_gate_pz: float = field(\n    default=0.003184, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-Z error during CZ gate operation when two qubits are within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_unpaired_errors","title":"cz_unpaired_errors  <code>property</code>","text":"<pre><code>cz_unpaired_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a CZ gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_unpaired_gate_px","title":"cz_unpaired_gate_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_gate_px: float = field(\n    default=0.0005149, kw_only=True\n)\n</code></pre> <p>The error probability for Pauli-X error during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_unpaired_gate_py","title":"cz_unpaired_gate_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_gate_py: float = field(\n    default=0.0005149, kw_only=True\n)\n</code></pre> <p>The error probability for Pauli-Y error during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_unpaired_gate_pz","title":"cz_unpaired_gate_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_gate_pz: float = field(\n    default=0.002185, kw_only=True\n)\n</code></pre> <p>The error probability for Pauli-Z error during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.cz_unpaired_loss_prob","title":"cz_unpaired_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>cz_unpaired_loss_prob: float = field(\n    default=0.0, kw_only=True\n)\n</code></pre> <p>The error probability for a loss during CZ gate operation when another qubit is not within blockade radius.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.global_errors","title":"global_errors  <code>property</code>","text":"<pre><code>global_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a global single qubit gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.global_loss_prob","title":"global_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_loss_prob: float = field(default=0.0, kw_only=True)\n</code></pre> <p>The error probability for a loss during a global single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.global_px","title":"global_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_px: float = field(default=6.5e-05, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-X error during a global single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.global_py","title":"global_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_py: float = field(default=6.5e-05, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Y error during a global single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.global_pz","title":"global_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>global_pz: float = field(default=6.5e-05, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Z error during a global single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_errors","title":"local_errors  <code>property</code>","text":"<pre><code>local_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a local single qubit gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_loss_prob","title":"local_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_loss_prob: float = field(default=0.0, kw_only=True)\n</code></pre> <p>The error probability for a loss during a local single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_px","title":"local_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_px: float = field(default=0.0004102, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-X error during a local single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_py","title":"local_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_py: float = field(default=0.0004102, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Y error during a local single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_pz","title":"local_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_pz: float = field(default=0.0004112, kw_only=True)\n</code></pre> <p>The error probability for a Pauli-Z error during a local single qubit gate operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_unaddressed_errors","title":"local_unaddressed_errors  <code>property</code>","text":"<pre><code>local_unaddressed_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a local single qubit gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_unaddressed_loss_prob","title":"local_unaddressed_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_unaddressed_loss_prob: float = field(\n    default=0.0, kw_only=True\n)\n</code></pre> <p>The error probability for a loss during a local single qubit gate operation when the qubit is not addressed.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_unaddressed_px","title":"local_unaddressed_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_unaddressed_px: float = field(\n    default=2e-07, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-X error during a local single qubit gate operation when the qubit is not addressed.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_unaddressed_py","title":"local_unaddressed_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_unaddressed_py: float = field(\n    default=2e-07, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-Y error during a local single qubit gate operation when the qubit is not addressed.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.local_unaddressed_pz","title":"local_unaddressed_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>local_unaddressed_pz: float = field(\n    default=1.2e-06, kw_only=True\n)\n</code></pre> <p>The error probability for a Pauli-Z error during a local single qubit gate operation when the qubit is not addressed.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.move_loss_prob","title":"move_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>move_loss_prob: float = field(default=0.0, kw_only=True)\n</code></pre> <p>Probability of loss occurring on a moving qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.mover_px","title":"mover_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mover_px: float = field(default=0.000806, kw_only=True)\n</code></pre> <p>Probability of X error occurring on a moving qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.mover_py","title":"mover_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mover_py: float = field(default=0.000806, kw_only=True)\n</code></pre> <p>Probability of Y error occurring on a moving qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.mover_pz","title":"mover_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>mover_pz: float = field(default=0.002458, kw_only=True)\n</code></pre> <p>Probability of Z error occurring on a moving qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.sit_loss_prob","title":"sit_loss_prob  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sit_loss_prob: float = field(default=0.0, kw_only=True)\n</code></pre> <p>Probability of loss occurring on a stationary qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.sitter_errors","title":"sitter_errors  <code>property</code>","text":"<pre><code>sitter_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a move operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.sitter_px","title":"sitter_px  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sitter_px: float = field(default=0.0003066, kw_only=True)\n</code></pre> <p>Probability of X error occurring on a stationary qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.sitter_py","title":"sitter_py  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sitter_py: float = field(default=0.0003066, kw_only=True)\n</code></pre> <p>Probability of Y error occurring on a stationary qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.sitter_pz","title":"sitter_pz  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>sitter_pz: float = field(default=0.0004639, kw_only=True)\n</code></pre> <p>Probability of Z error occurring on a stationary qubit during a move operation</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.join_binary_probs","title":"join_binary_probs  <code>classmethod</code>","text":"<pre><code>join_binary_probs(p1: float, *args: float) -&gt; float\n</code></pre> <p>Merge the probabilities of an event happening if the event can only happen once.</p> <p>For example, finding the effective probability of losing an atom from multiple sources, since a qubit can only be lost once. This is done by using the formula:</p> <p>p = p1 * (1 - p2) + p2 * (1 - p1)</p> <p>applied recursively to all the probabilities in the list.</p> <p>Parameters:</p> Name Type Description Default <code>p1</code> <code>float</code> <p>The probability of the event happening.</p> required <code>arg</code> <code>float</code> <p>The probabilities of the event happening from other sources.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The effective probability of the event happening.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/dialects/noise/model.py</code> <pre><code>@classmethod\ndef join_binary_probs(cls, p1: float, *args: float) -&gt; float:\n    \"\"\"Merge the probabilities of an event happening if the event can only happen once.\n\n    For example, finding the effective probability of losing an atom from multiple sources, since\n    a qubit can only be lost once. This is done by using the formula:\n\n    p = p1 * (1 - p2) + p2 * (1 - p1)\n\n    applied recursively to all the probabilities in the list.\n\n    Args:\n        p1 (float): The probability of the event happening.\n        arg (float): The probabilities of the event happening from other sources.\n\n    Returns:\n        float: The effective probability of the event happening.\n\n    \"\"\"\n    if len(args) == 0:\n        return p1\n    else:\n        p2 = cls.join_binary_probs(*args)\n        return p1 * (1 - p2) + p2 * (1 - p1)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC.parallel_cz_errors","title":"parallel_cz_errors  <code>abstractmethod</code>","text":"<pre><code>parallel_cz_errors(\n    ctrls: Sequence[int],\n    qargs: Sequence[int],\n    rest: Sequence[int],\n) -&gt; dict[tuple[float, float, float, float], list[int]]\n</code></pre> <p>Takes a set of ctrls and qargs and returns a noise model for all qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/dialects/noise/model.py</code> <pre><code>@abc.abstractmethod\ndef parallel_cz_errors(\n    self, ctrls: Sequence[int], qargs: Sequence[int], rest: Sequence[int]\n) -&gt; dict[tuple[float, float, float, float], list[int]]:\n    \"\"\"Takes a set of ctrls and qargs and returns a noise model for all qubits.\"\"\"\n    pass\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.TwoRowZoneModel","title":"TwoRowZoneModel  <code>dataclass</code>","text":"<pre><code>TwoRowZoneModel(\n    *,\n    local_px: float = 0.0004102,\n    local_py: float = 0.0004102,\n    local_pz: float = 0.0004112,\n    local_loss_prob: float = 0.0,\n    local_unaddressed_px: float = 2e-07,\n    local_unaddressed_py: float = 2e-07,\n    local_unaddressed_pz: float = 1.2e-06,\n    local_unaddressed_loss_prob: float = 0.0,\n    global_px: float = 6.5e-05,\n    global_py: float = 6.5e-05,\n    global_pz: float = 6.5e-05,\n    global_loss_prob: float = 0.0,\n    cz_paired_gate_px: float = 0.0006549,\n    cz_paired_gate_py: float = 0.0006549,\n    cz_paired_gate_pz: float = 0.003184,\n    cz_gate_loss_prob: float = 0.0,\n    cz_unpaired_gate_px: float = 0.0005149,\n    cz_unpaired_gate_py: float = 0.0005149,\n    cz_unpaired_gate_pz: float = 0.002185,\n    cz_unpaired_loss_prob: float = 0.0,\n    mover_px: float = 0.000806,\n    mover_py: float = 0.000806,\n    mover_pz: float = 0.002458,\n    move_loss_prob: float = 0.0,\n    sitter_px: float = 0.0003066,\n    sitter_py: float = 0.0003066,\n    sitter_pz: float = 0.0004639,\n    sit_loss_prob: float = 0.0\n)\n</code></pre> <p>               Bases: <code>MoveNoiseModelABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.noise.model.TwoRowZoneModel[TwoRowZoneModel]\n              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC[MoveNoiseModelABC]\n\n                              bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC --&gt; bloqade.qasm2.dialects.noise.model.TwoRowZoneModel\n                \n\n\n              click bloqade.qasm2.dialects.noise.model.TwoRowZoneModel href \"\" \"bloqade.qasm2.dialects.noise.model.TwoRowZoneModel\"\n              click bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC href \"\" \"bloqade.qasm2.dialects.noise.model.MoveNoiseModelABC\"\n            </code></pre> <p>This model assumes that the qubits are arranged in a single storage row with a row corresponding to a gate zone below it.</p> <p>The CZ gate noise is calculated using the following heuristic: The idle error is calculated by the total duration required to do the move and entangle the qubits. Not every pair can be entangled at the same time, so we first deconflict the qargs by finding subsets in which both the ctrl and the qarg qubits are in ascending order. This breaks the pairs into groups that can be moved and entangled separately. We then take each group and assign each pair to a gate zone slot. The slots are allocated by starting from the middle of the atoms and moving outwards making sure to keep the ctrl qubits in ascending order. The time to move a group is calculated by finding the maximum travel distance of the qarg and ctrl qubits and dviding by the move speed. The total move time is the sum of all the group move times. The error rate for all the qubits is then calculated by using the poisson_pauli_prob function. An additional error for the pick operation is calculated by joining the binary probabilities of the pick operation and the move operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.TwoRowZoneModel.move_errors","title":"move_errors  <code>property</code>","text":"<pre><code>move_errors: tuple[float, float, float, float]\n</code></pre> <p>Returns the error rates for a move operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.TwoRowZoneModel.deconflict","title":"deconflict","text":"<pre><code>deconflict(\n    ctrls: list[int], qargs: list[int]\n) -&gt; list[tuple[tuple[int, ...], tuple[int, ...]]]\n</code></pre> <p>Return a list of groups of ctrl and qarg qubits that can be moved and entangled separately.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/dialects/noise/model.py</code> <pre><code>def deconflict(\n    self, ctrls: list[int], qargs: list[int]\n) -&gt; list[tuple[tuple[int, ...], tuple[int, ...]]]:\n    \"\"\"Return a list of groups of ctrl and qarg qubits that can be moved and entangled separately.\"\"\"\n    # sort by ctrl qubit first to guarantee that they will be in ascending order\n    sorted_pairs = sorted(zip(ctrls, qargs))\n\n    groups: list[list[tuple[int, int]]] = []\n    # group by qarg only putting it in a group if the qarg is greater than the last qarg in the group\n    # thus ensuring that the qargs are in ascending order\n    while len(sorted_pairs) &gt; 0:\n        ctrl, qarg = sorted_pairs.pop(0)\n\n        found = False\n        for group in groups:\n            if group[-1][1] &lt; qarg:\n                group.append((ctrl, qarg))\n                found = True\n                break\n        if not found:\n            groups.append([(ctrl, qarg)])\n\n    new_groups: list[tuple[tuple[int, ...], tuple[int, ...]]] = []\n\n    for group in groups:\n        ctrl, qarg = zip(*group)\n        ctrl = tuple(ctrl)\n        qarg = tuple(qarg)\n        new_groups.append((ctrl, qarg))\n\n    return new_groups\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/model/#bloqade.qasm2.dialects.noise.model.TwoRowZoneModel.parallel_cz_errors","title":"parallel_cz_errors","text":"<pre><code>parallel_cz_errors(\n    ctrls: list[int], qargs: list[int], rest: list[int]\n) -&gt; dict[tuple[float, float, float, float], list[int]]\n</code></pre> <p>Apply parallel gates by moving ctrl qubits to qarg qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/dialects/noise/model.py</code> <pre><code>def parallel_cz_errors(\n    self, ctrls: list[int], qargs: list[int], rest: list[int]\n) -&gt; dict[tuple[float, float, float, float], list[int]]:\n    \"\"\"Apply parallel gates by moving ctrl qubits to qarg qubits.\"\"\"\n    groups = self.deconflict(ctrls, qargs)\n    movers = ctrls + qargs\n    num_moves = len(groups)\n    # ignore order O(p^2) errors since they are small\n    effective_move_errors = (\n        self.move_errors[0] + self.sitter_errors[0] * (num_moves - 1),\n        self.move_errors[1] + self.sitter_errors[1] * (num_moves - 1),\n        self.move_errors[2] + self.sitter_errors[2] * (num_moves - 1),\n        self.move_errors[3] + self.sitter_errors[3] * (num_moves - 1),\n    )\n    effective_sitter_errors = (\n        self.sitter_errors[0] * num_moves,\n        self.sitter_errors[1] * num_moves,\n        self.sitter_errors[2] * num_moves,\n        self.sitter_errors[3] * num_moves,\n    )\n    result = {effective_move_errors: list(movers)}\n    result.setdefault(effective_sitter_errors, []).extend(rest)\n\n    return result\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/noise/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/schedule/","title":"Schedule","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Barrier","title":"Barrier","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Barrier[Barrier]\n\n              \n\n              click bloqade.qasm2.dialects.uop.stmts.Barrier href \"\" \"bloqade.qasm2.dialects.uop.stmts.Barrier\"\n            </code></pre> <p>Apply the Barrier statement.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Barrier.qargs","title":"qargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qargs: tuple[SSAValue, ...] = argument(QubitType)\n</code></pre> <p>qargs: tuple of qubits to apply the barrier to.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX","title":"CCX","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CCX[CCX]\n\n              \n\n              click bloqade.qasm2.dialects.uop.stmts.CCX href \"\" \"bloqade.qasm2.dialects.uop.stmts.CCX\"\n            </code></pre> <p>Apply the doubly controlled X gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.ctrl1","title":"ctrl1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl1: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl1 (Qubit): The first control qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.ctrl2","title":"ctrl2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl2: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl2 (Qubit): The second control qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CH","title":"CH","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CH[CH]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CH\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CH href \"\" \"bloqade.qasm2.dialects.uop.stmts.CH\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-H gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRX","title":"CRX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CRX[CRX]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CRX\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CRX href \"\" \"bloqade.qasm2.dialects.uop.stmts.CRX\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-RX gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRX.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the X axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRY","title":"CRY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CRY[CRY]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CRY\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CRY href \"\" \"bloqade.qasm2.dialects.uop.stmts.CRY\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-RY gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRY.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the Y axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRZ","title":"CRZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CRZ[CRZ]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CRZ\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CRZ href \"\" \"bloqade.qasm2.dialects.uop.stmts.CRZ\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-RZ gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRZ.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The angle to rotate around the Z axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSX","title":"CSX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CSX[CSX]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CSX\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CSX href \"\" \"bloqade.qasm2.dialects.uop.stmts.CSX\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-Sqrt(X) gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap","title":"CSwap","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CSwap[CSwap]\n\n              \n\n              click bloqade.qasm2.dialects.uop.stmts.CSwap href \"\" \"bloqade.qasm2.dialects.uop.stmts.CSwap\"\n            </code></pre> <p>Apply the controlled swap gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap.qarg1","title":"qarg1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg1: SSAValue = argument(QubitType)\n</code></pre> <p>qarg1 (Qubit): The first target qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CSwap.qarg2","title":"qarg2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg2: SSAValue = argument(QubitType)\n</code></pre> <p>qarg2 (Qubit): The second target qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU","title":"CU","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CU[CU]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CU\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CU href \"\" \"bloqade.qasm2.dialects.uop.stmts.CU\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-U gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU1","title":"CU1","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CU1[CU1]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CU1\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CU1 href \"\" \"bloqade.qasm2.dialects.uop.stmts.CU1\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-U1 gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3","title":"CU3","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CU3[CU3]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CU3\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CU3 href \"\" \"bloqade.qasm2.dialects.uop.stmts.CU3\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-U3 gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CX","title":"CX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CX[CX]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CX\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CX href \"\" \"bloqade.qasm2.dialects.uop.stmts.CX\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Alias for the CNOT or CH gate operations.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CY","title":"CY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CY[CY]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CY\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CY href \"\" \"bloqade.qasm2.dialects.uop.stmts.CY\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-Y gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CZ","title":"CZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.CZ[CZ]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.CZ\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.CZ href \"\" \"bloqade.qasm2.dialects.uop.stmts.CZ\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Controlled-Z gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.H","title":"H","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.H[H]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.H\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.H href \"\" \"bloqade.qasm2.dialects.uop.stmts.H\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the Hadamard gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Id","title":"Id","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Id[Id]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.Id\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.Id href \"\" \"bloqade.qasm2.dialects.uop.stmts.Id\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the Identity gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RX","title":"RX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.RX[RX]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.RX\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.RX href \"\" \"bloqade.qasm2.dialects.uop.stmts.RX\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the RX gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around x axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RXX","title":"RXX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.RXX[RXX]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.RXX\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.RXX href \"\" \"bloqade.qasm2.dialects.uop.stmts.RXX\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the XX rotation gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RXX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around the X axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RY","title":"RY","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.RY[RY]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.RY\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.RY href \"\" \"bloqade.qasm2.dialects.uop.stmts.RY\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the RY gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RY.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around y axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZ","title":"RZ","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.RZ[RZ]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.RZ\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.RZ href \"\" \"bloqade.qasm2.dialects.uop.stmts.RZ\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the RZ gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): the angle of rotation around Z axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZZ","title":"RZZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.RZZ[RZZ]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.RZZ\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.RZZ href \"\" \"bloqade.qasm2.dialects.uop.stmts.RZZ\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the ZZ rotation gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around the Z axis.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.S","title":"S","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.S[S]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.S\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.S href \"\" \"bloqade.qasm2.dialects.uop.stmts.S\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the S gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SX","title":"SX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.SX[SX]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.SX\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.SX href \"\" \"bloqade.qasm2.dialects.uop.stmts.SX\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the quantum Sqrt(X) gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SXdag","title":"SXdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.SXdag[SXdag]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.SXdag\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.SXdag href \"\" \"bloqade.qasm2.dialects.uop.stmts.SXdag\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the dagger of quantum Sqrt(X) gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Sdag","title":"Sdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Sdag[Sdag]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.Sdag\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.Sdag href \"\" \"bloqade.qasm2.dialects.uop.stmts.Sdag\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the hermitian conj of S gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SingleQubitGate","title":"SingleQubitGate","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n              \n\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Base class for single qubit gates.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SingleQubitGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit argument.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Swap","title":"Swap","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Swap[Swap]\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate --&gt; bloqade.qasm2.dialects.uop.stmts.Swap\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.Swap href \"\" \"bloqade.qasm2.dialects.uop.stmts.Swap\"\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre> <p>Apply the Swap gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.T","title":"T","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.T[T]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.T\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.T href \"\" \"bloqade.qasm2.dialects.uop.stmts.T\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the T gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Tdag","title":"Tdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Tdag[Tdag]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.Tdag\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.Tdag href \"\" \"bloqade.qasm2.dialects.uop.stmts.Tdag\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the hermitian conj of T gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate","title":"TwoQubitCtrlGate","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate[TwoQubitCtrlGate]\n\n              \n\n              click bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U1","title":"U1","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.U1[U1]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.U1\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.U1 href \"\" \"bloqade.qasm2.dialects.uop.stmts.U1\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the U1 gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2","title":"U2","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.U2[U2]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.U2\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.U2 href \"\" \"bloqade.qasm2.dialects.uop.stmts.U2\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the U2 gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate","title":"UGate","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.UGate[UGate]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.UGate\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.UGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.UGate\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply A general single qubit unitary gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The theta parameter.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.X","title":"X","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.X[X]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.X\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.X href \"\" \"bloqade.qasm2.dialects.uop.stmts.X\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the X gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Y","title":"Y","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Y[Y]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.Y\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.Y href \"\" \"bloqade.qasm2.dialects.uop.stmts.Y\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the Y gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Z","title":"Z","text":"<p>               Bases: <code>SingleQubitGate</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.dialects.uop.stmts.Z[Z]\n              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate[SingleQubitGate]\n\n                              bloqade.qasm2.dialects.uop.stmts.SingleQubitGate --&gt; bloqade.qasm2.dialects.uop.stmts.Z\n                \n\n\n              click bloqade.qasm2.dialects.uop.stmts.Z href \"\" \"bloqade.qasm2.dialects.uop.stmts.Z\"\n              click bloqade.qasm2.dialects.uop.stmts.SingleQubitGate href \"\" \"bloqade.qasm2.dialects.uop.stmts.SingleQubitGate\"\n            </code></pre> <p>Apply the Z gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/base/","title":"Base","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/gate/","title":"Gate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/main/","title":"Main","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/target/","title":"Target","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/target/#bloqade.qasm2.emit.target.QASM2","title":"QASM2","text":"<pre><code>QASM2(\n    qelib1: bool = True,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    custom_gate: bool = True,\n    unroll_ifs: bool = True,\n    allow_noise: bool = True,\n)\n</code></pre> <p>QASM2 target for Bloqade kernels.</p> <p>QASM2 target that accepts a Bloqade kernel and produces an AST that you can then obtain a string for printing or saving as a file.</p> <p>Parameters:</p> Name Type Description Default <code>allow_parallel</code> <code>bool</code> <p>Allow parallel gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.</p> <code>False</code> <code>allow_global</code> <code>bool</code> <p>Allow global gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates. If both <code>allow_parallel</code> and <code>allow_global</code> are False, the input kernel will be rewritten to use uop gates.</p> <code>False</code> <code>qelib1</code> <code>bool</code> <p>Include the <code>include \"qelib1.inc\"</code> line in the resulting QASM2 AST that's submitted to qBraid. Defaults to <code>True</code>.</p> <code>True</code> <code>custom_gate</code> <code>bool</code> <p>Include the custom gate definitions in the resulting QASM2 AST. Defaults to <code>True</code>. If <code>False</code>, all the qasm2.gate will be inlined.</p> <code>True</code> <code>unroll_ifs</code> <code>bool</code> <p>Unrolls if statements with multiple qasm2 statements in the body in order to produce valid qasm2 output, which only allows a single operation in an if body. Defaults to <code>True</code>.</p> <code>True</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/emit/target.py</code> <pre><code>def __init__(\n    self,\n    qelib1: bool = True,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    custom_gate: bool = True,\n    unroll_ifs: bool = True,\n    allow_noise: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the QASM2 target.\n\n    Args:\n        allow_parallel (bool):\n            Allow parallel gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.\n\n        allow_global (bool):\n            Allow global gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates.\n            If both `allow_parallel` and `allow_global` are False, the input kernel will be rewritten to use uop gates.\n\n        qelib1 (bool):\n            Include the `include \"qelib1.inc\"` line in the resulting QASM2 AST that's\n            submitted to qBraid. Defaults to `True`.\n\n        custom_gate (bool):\n            Include the custom gate definitions in the resulting QASM2 AST. Defaults to `True`. If `False`, all the qasm2.gate will be inlined.\n\n        unroll_ifs (bool):\n            Unrolls if statements with multiple qasm2 statements in the body in order to produce valid qasm2 output, which only allows a single\n            operation in an if body. Defaults to `True`.\n\n\n\n    \"\"\"\n    from bloqade import qasm2\n\n    self.main_target = qasm2.main\n    self.gate_target = qasm2.gate\n\n    self.qelib1 = qelib1\n    self.custom_gate = custom_gate\n    self.allow_parallel = allow_parallel\n    self.allow_global = allow_global\n    self.unroll_ifs = unroll_ifs\n\n    if allow_parallel:\n        self.main_target = self.main_target.add(qasm2.dialects.parallel)\n        self.gate_target = self.gate_target.add(qasm2.dialects.parallel)\n\n    if allow_global:\n        self.main_target = self.main_target.add(qasm2.dialects.glob)\n        self.gate_target = self.gate_target.add(qasm2.dialects.glob)\n\n    if allow_noise:\n        self.main_target = self.main_target.add(qasm2.dialects.noise)\n        self.gate_target = self.gate_target.add(qasm2.dialects.noise)\n\n    if allow_global or allow_parallel or allow_noise:\n        self.main_target = self.main_target.add(ilist)\n        self.gate_target = self.gate_target.add(ilist)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/target/#bloqade.qasm2.emit.target.QASM2.emit","title":"emit","text":"<pre><code>emit(entry: Method) -&gt; ast.MainProgram\n</code></pre> <p>Emit a QASM2 AST from the Bloqade kernel.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Method</code> <p>The Bloqade kernel to convert to the QASM2 AST</p> required <p>Returns:</p> Type Description <code>MainProgram</code> <p>ast.MainProgram: A QASM2 AST object</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/emit/target.py</code> <pre><code>def emit(self, entry: ir.Method) -&gt; ast.MainProgram:\n    \"\"\"Emit a QASM2 AST from the Bloqade kernel.\n\n    Args:\n        entry (ir.Method):\n            The Bloqade kernel to convert to the QASM2 AST\n\n    Returns:\n        ast.MainProgram:\n            A QASM2 AST object\n\n    \"\"\"\n    assert len(entry.args) == 0, \"entry method should not have arguments\"\n\n    # make a cloned instance of kernel\n    entry = entry.similar()\n    QASM2Fold(\n        entry.dialects,\n        inline_gate_subroutine=not self.custom_gate,\n        unroll_ifs=self.unroll_ifs,\n    ).fixpoint(entry)\n\n    if not self.allow_global:\n        # rewrite global to parallel\n        GlobalToParallel(dialects=entry.dialects)(entry)\n\n    if not self.allow_parallel:\n        # rewrite parallel to uop\n        ParallelToUOp(dialects=entry.dialects)(entry)\n\n    Py2QASM(entry.dialects)(entry)\n    target_main = EmitQASM2Main(self.main_target).initialize()\n    target_main.run(entry)\n\n    main_program = target_main.output\n    assert main_program is not None, f\"failed to emit {entry.sym_name}\"\n\n    extra = []\n    if self.qelib1:\n        extra.append(ast.Include(\"qelib1.inc\"))\n\n    if self.custom_gate:\n        cg = CallGraph(entry)\n        target_gate = EmitQASM2Gate(self.gate_target).initialize()\n\n        for _, fns in cg.defs.items():\n            if len(fns) != 1:\n                raise ValueError(\"Incorrect callgraph\")\n\n            (fn,) = fns\n            if fn is entry:\n                continue\n\n            fn = fn.similar()\n            QASM2Fold(fn.dialects).fixpoint(fn)\n\n            if not self.allow_global:\n                # rewrite global to parallel\n                GlobalToParallel(dialects=fn.dialects)(fn)\n\n            if not self.allow_parallel:\n                # rewrite parallel to uop\n                ParallelToUOp(dialects=fn.dialects)(fn)\n\n            Py2QASM(fn.dialects)(fn)\n\n            target_gate.run(fn)\n            assert target_gate.output is not None, f\"failed to emit {fn.sym_name}\"\n            extra.append(target_gate.output)\n\n    main_program.statements = extra + main_program.statements\n    return main_program\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/target/#bloqade.qasm2.emit.target.QASM2.emit_str","title":"emit_str","text":"<pre><code>emit_str(entry: Method) -&gt; str\n</code></pre> <p>Emit a QASM2 AST from the Bloqade kernel.</p> <p>Parameters:</p> Name Type Description Default <code>entry</code> <code>Method</code> <p>The Bloqade kernel to convert to the QASM2 AST</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string with the QASM2 representation of the kernel</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/emit/target.py</code> <pre><code>def emit_str(self, entry: ir.Method) -&gt; str:\n    \"\"\"Emit a QASM2 AST from the Bloqade kernel.\n\n    Args:\n        entry (ir.Method):\n            The Bloqade kernel to convert to the QASM2 AST\n\n    Returns:\n        str:\n            A string with the QASM2 representation of the kernel\n\n    \"\"\"\n    console = Console(\n        file=io.StringIO(),\n        force_terminal=False,\n        force_interactive=False,\n        force_jupyter=False,\n        record=True,\n    )\n    pprint(self.emit(entry), console=console)\n    return console.export_text()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/impls/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/emit/impls/noise/","title":"Noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/ast/","title":"Ast","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/build/","title":"Build","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/lowering/#bloqade.qasm2.parse.lowering.QASM2","title":"QASM2  <code>dataclass</code>","text":"<pre><code>QASM2(\n    *,\n    max_lines: int = 3,\n    hint_indent: int = 2,\n    hint_show_lineno: bool = True,\n    stacktrace: bool = True\n)\n</code></pre> <p>               Bases: <code>LoweringABC[Node]</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.parse.lowering.QASM2[QASM2]\n\n              \n\n              click bloqade.qasm2.parse.lowering.QASM2 href \"\" \"bloqade.qasm2.parse.lowering.QASM2\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/lowering/#bloqade.qasm2.parse.lowering.QASM2.branch_next_if_not_terminated","title":"branch_next_if_not_terminated","text":"<pre><code>branch_next_if_not_terminated(frame: Frame)\n</code></pre> <p>Branch to the next block if the current block is not terminated.</p> <p>This must be used after exhausting the current frame and before popping the frame.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qasm2/parse/lowering.py</code> <pre><code>def branch_next_if_not_terminated(self, frame: lowering.Frame):\n    \"\"\"Branch to the next block if the current block is not terminated.\n\n    This must be used after exhausting the current frame and before popping the frame.\n    \"\"\"\n    if not frame.curr_block.last_stmt or not frame.curr_block.last_stmt.has_trait(\n        ir.IsTerminator\n    ):\n        frame.curr_block.stmts.append(\n            cf.Branch(arguments=(), successor=frame.next_block)\n        )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/parser/","title":"Parser","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/print/","title":"Print","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/parse/visitor/","title":"Visitor","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/fold/","title":"Fold","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/fold/#bloqade.qasm2.passes.fold.QASM2Fold","title":"QASM2Fold  <code>dataclass</code>","text":"<pre><code>QASM2Fold(\n    inline_gate_subroutine: bool = True,\n    unroll_ifs: bool = True,\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.fold.QASM2Fold[QASM2Fold]\n\n              \n\n              click bloqade.qasm2.passes.fold.QASM2Fold href \"\" \"bloqade.qasm2.passes.fold.QASM2Fold\"\n            </code></pre> <p>Fold pass for qasm2.extended</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/glob/","title":"Glob","text":"<p>Passes that deal with global gates. As of now, only one rewrite pass exists which converts global gates to single qubit gates.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToParallel","title":"GlobalToParallel","text":"<p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.glob.GlobalToParallel[GlobalToParallel]\n\n              \n\n              click bloqade.qasm2.passes.glob.GlobalToParallel href \"\" \"bloqade.qasm2.passes.glob.GlobalToParallel\"\n            </code></pre> <p>Pass to convert Global gates into parallel gates.</p> <p>This pass rewrites the global unitary gate from the <code>qasm2.glob</code> dialect into multiple parallel gates in the <code>qasm2.parallel</code> dialect.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToParallel--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.extended\ndef main():\n    q1 = qasm2.qreg(1)\n    q2 = qasm2.qreg(2)\n\n    theta = 1.3\n    phi = 1.1\n    lam = 1.2\n\n    qasm2.glob.u(theta=theta, phi=phi, lam=lam, registers=[q1, q2])\n\nGlobalToParallel(dialects=main.dialects)(main)\n\n# Run rewrite\nGlobalToParallel(main.dialects)(main)\n</code></pre> <p>The <code>qasm2.glob.u</code> statement has been rewritten to individual gates:</p> <pre><code>qasm2.parallel.u(theta=theta, phi=phi, lam=lam, qargs=[q1[0], q2[0], q2[1]])\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToUOP","title":"GlobalToUOP","text":"<p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.glob.GlobalToUOP[GlobalToUOP]\n\n              \n\n              click bloqade.qasm2.passes.glob.GlobalToUOP href \"\" \"bloqade.qasm2.passes.glob.GlobalToUOP\"\n            </code></pre> <p>Pass to convert Global gates into single gates.</p> <p>This pass rewrites the global unitary gate from the <code>qasm2.glob</code> dialect into multiple single gates in the <code>qasm2.uop</code> dialect, bringing the program closer to conforming to standard QASM2 syntax.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/glob/#bloqade.qasm2.passes.glob.GlobalToUOP--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.extended\ndef main():\n    q1 = qasm2.qreg(1)\n    q2 = qasm2.qreg(2)\n\n    theta = 1.3\n    phi = 1.1\n    lam = 1.2\n\n    qasm2.glob.u(theta=theta, phi=phi, lam=lam, registers=[q1, q2])\n\nGlobalToUOP(dialects=main.dialects)(main)\n\n# Run rewrite\nGlobalToUOP(main.dialects)(main)\n</code></pre> <p>The <code>qasm2.glob.u</code> statement has been rewritten to individual gates:</p> <pre><code>qasm2.uop.u(q1[0], theta, phi, lam)\nqasm2.uop.u(q2[0], theta, phi, lam)\nqasm2.uop.u(q2[1], theta, phi, lam)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/lift_qubits/","title":"Lift qubits","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/lift_qubits/#bloqade.qasm2.passes.lift_qubits.LiftQubits","title":"LiftQubits","text":"<p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.lift_qubits.LiftQubits[LiftQubits]\n\n              \n\n              click bloqade.qasm2.passes.lift_qubits.LiftQubits href \"\" \"bloqade.qasm2.passes.lift_qubits.LiftQubits\"\n            </code></pre> <p>This pass lifts the creation of qubits to the block where the register is defined.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/noise/","title":"Noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/noise/#bloqade.qasm2.passes.noise.NoisePass","title":"NoisePass  <code>dataclass</code>","text":"<pre><code>NoisePass(\n    noise_model: MoveNoiseModelABC = noise.TwoRowZoneModel(),\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.noise.NoisePass[NoisePass]\n\n              \n\n              click bloqade.qasm2.passes.noise.NoisePass href \"\" \"bloqade.qasm2.passes.noise.NoisePass\"\n            </code></pre> <p>Apply a noise model to a quantum circuit.</p> <p>NOTE: This pass is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/noise/#bloqade.qasm2.passes.noise.NoisePass--usage-examples","title":"Usage examples","text":"<pre><code>from bloqade import qasm2\nfrom bloqade.qasm2.passes import NoisePass\n\n@qasm2.extended\ndef main():\n    q = qasm2.qreg(2)\n    qasm2.h(q[0])\n    qasm2.cx(q[0], q[1])\n    return q\n\n# simple IR without any nosie\nmain.print()\n\nnoise_pass = NoisePass(noise_main)\n\n# rewrite stuff in-place\nnoise_pass.unsafe_run(main)\n\n# now, we do have noise channels in the IR\nmain.print()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/parallel/","title":"Parallel","text":"<p>Passes for converting parallel gates into multiple single gates as well as converting multiple single gates to parallel gates.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.ParallelToUOp","title":"ParallelToUOp  <code>dataclass</code>","text":"<pre><code>ParallelToUOp()\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.parallel.ParallelToUOp[ParallelToUOp]\n\n              \n\n              click bloqade.qasm2.passes.parallel.ParallelToUOp href \"\" \"bloqade.qasm2.passes.parallel.ParallelToUOp\"\n            </code></pre> <p>Pass to convert parallel gates into single gates.</p> <p>This pass rewrites any parallel gates from the <code>qasm2.parallel</code> dialect into multiple single gates in the <code>qasm2.uop</code> dialect, bringing the program closer to conforming to standard QASM2 syntax.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.ParallelToUOp--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.extended\ndef main():\n    q = qasm2.qreg(4)\n\n    qasm2.parallel.cz(ctrls=[q[0], q[2]], qargs=[q[1], q[3]])\n\n# Run rewrite\nParallelToUOp(main.dialects)(main)\n</code></pre> <p>The <code>qasm2.parallel.cz</code> statement has been rewritten to individual gates:</p> <pre><code>qasm2.uop.cz(ctrl=q[0], qarg=q[1])\nqasm2.uop.cz(ctrl=q[2], qarg=q[3])\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.UOpToParallel","title":"UOpToParallel  <code>dataclass</code>","text":"<pre><code>UOpToParallel(\n    merge_policy_type: Type[\n        MergePolicyABC\n    ] = SimpleOptimalMergePolicy,\n    rewrite_to_native_first: bool = False,\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.parallel.UOpToParallel[UOpToParallel]\n\n              \n\n              click bloqade.qasm2.passes.parallel.UOpToParallel href \"\" \"bloqade.qasm2.passes.parallel.UOpToParallel\"\n            </code></pre> <p>Pass to convert single gates into parallel gates.</p> <p>This pass looks for single gates from the <code>qasm2.uop</code> dialect that can be combined into parallel gates from the <code>qasm2.parallel</code> dialect and performs a rewrite to do so.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/parallel/#bloqade.qasm2.passes.parallel.UOpToParallel--usage-examples","title":"Usage Examples","text":"<pre><code># Define kernel\n@qasm2.main\ndef test():\n    q = qasm2.qreg(4)\n\n    theta = 0.1\n    phi = 0.2\n    lam = 0.3\n\n    qasm2.u(q[1], theta, phi, lam)\n    qasm2.u(q[3], theta, phi, lam)\n    qasm2.cx(q[1], q[3])\n    qasm2.u(q[2], theta, phi, lam)\n    qasm2.u(q[0], theta, phi, lam)\n    qasm2.cx(q[0], q[2])\n\n# Run rewrite\nUOpToParallel(main.dialects)(main)\n</code></pre> <p>The individual <code>qasm2.u</code> statements have now been combined into a single <code>qasm2.parallel.u</code> statement.</p> <pre><code>qasm2.parallel.u(qargs = [q[0], q[1], q[2], q[3]], theta, phi, lam)\nqasm2.uop.CX(q[1], q[3])\nqasm2.uop.CX(q[0], q[2])\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/py2qasm/","title":"Py2qasm","text":"<p>Rewrite py dialects into qasm dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/qasm2py/","title":"Qasm2py","text":"<p>Rewrite qasm dialects into py dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/unroll_if/","title":"Unroll if","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/passes/unroll_if/#bloqade.qasm2.passes.unroll_if.UnrollIfs","title":"UnrollIfs","text":"<p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.passes.unroll_if.UnrollIfs[UnrollIfs]\n\n              \n\n              click bloqade.qasm2.passes.unroll_if.UnrollIfs href \"\" \"bloqade.qasm2.passes.unroll_if.UnrollIfs\"\n            </code></pre> <p>This pass lifts statements that are not UOP out of the if body and then splits whatever is left into multiple if statements so you obtain valid QASM2</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/desugar/","title":"Desugar","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/glob/","title":"Glob","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/insert_qubits/","title":"Insert qubits","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/native_gates/","title":"Native gates","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/parallel_to_glob/","title":"Parallel to glob","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/parallel_to_uop/","title":"Parallel to uop","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/register/","title":"Register","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/register/#bloqade.qasm2.rewrite.register.RaiseRegisterRule","title":"RaiseRegisterRule","text":"<p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.rewrite.register.RaiseRegisterRule[RaiseRegisterRule]\n\n              \n\n              click bloqade.qasm2.rewrite.register.RaiseRegisterRule href \"\" \"bloqade.qasm2.rewrite.register.RaiseRegisterRule\"\n            </code></pre> <p>This rule puts all registers at the top of the block.</p> <p>This is required for the UOpToParallel rules to work correctly to handle cases where a register is defined in between two statements that can be parallelized.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/","title":"Uop to parallel","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.GreedyMixin","title":"GreedyMixin","text":"<p>               Bases: <code>MergePolicyABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.rewrite.uop_to_parallel.GreedyMixin[GreedyMixin]\n              bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC[MergePolicyABC]\n\n                              bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC --&gt; bloqade.qasm2.rewrite.uop_to_parallel.GreedyMixin\n                \n\n\n              click bloqade.qasm2.rewrite.uop_to_parallel.GreedyMixin href \"\" \"bloqade.qasm2.rewrite.uop_to_parallel.GreedyMixin\"\n              click bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC href \"\" \"bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC\"\n            </code></pre> <p>Merge policy that greedily merges gates together.</p> <p>The <code>merge_gates</code> method will merge policy will try greedily merge gates together. This policy has a worst case complexity of O(n) where n is the number of gates in the input iterable.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.OptimalMixIn","title":"OptimalMixIn","text":"<p>               Bases: <code>MergePolicyABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.rewrite.uop_to_parallel.OptimalMixIn[OptimalMixIn]\n              bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC[MergePolicyABC]\n\n                              bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC --&gt; bloqade.qasm2.rewrite.uop_to_parallel.OptimalMixIn\n                \n\n\n              click bloqade.qasm2.rewrite.uop_to_parallel.OptimalMixIn href \"\" \"bloqade.qasm2.rewrite.uop_to_parallel.OptimalMixIn\"\n              click bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC href \"\" \"bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC\"\n            </code></pre> <p>Merge policy that merges gates together optimally.</p> <p>The <code>merge_gates</code> method will merge policy will try to merge every gate into every group of gates, terminating when it finds a group that can be merged with the current gate. This policy has a worst case complexity of O(n^2) where n is the number of gates in the input iterable.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy","title":"SimpleMergePolicy  <code>dataclass</code>","text":"<pre><code>SimpleMergePolicy(\n    address_analysis: Dict[SSAValue, Address],\n    merge_groups: List[List[Statement]],\n    group_numbers: Dict[Statement, int],\n    group_has_merged: Dict[int, bool] = dict(),\n)\n</code></pre> <p>               Bases: <code>MergePolicyABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy[SimpleMergePolicy]\n              bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC[MergePolicyABC]\n\n                              bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC --&gt; bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy\n                \n\n\n              click bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy href \"\" \"bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy\"\n              click bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC href \"\" \"bloqade.qasm2.rewrite.uop_to_parallel.MergePolicyABC\"\n            </code></pre> <p>General merge policy for merging gates based on their type and arguments.</p> <p>Base class to implement a merge policy for CZ, U and RZ gates, To completed the policy implement the <code>merge_gates</code> class method. This will take an iterable of statements and return a list of groups of statements that can be merged together. There are two mix-in classes that can be used to implement the <code>merge_gates</code> method. The <code>GreedyMixin</code> will merge gates together greedily, while the <code>OptimalMixIn</code> will merge gates together optimally.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.address_analysis","title":"address_analysis  <code>instance-attribute</code>","text":"<pre><code>address_analysis: Dict[SSAValue, Address]\n</code></pre> <p>Mapping from SSA values to their address analysis results. Needed for rewrites</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.group_has_merged","title":"group_has_merged  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>group_has_merged: Dict[int, bool] = field(\n    default_factory=dict\n)\n</code></pre> <p>Mapping from group number to whether the group has been merged</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.group_numbers","title":"group_numbers  <code>instance-attribute</code>","text":"<pre><code>group_numbers: Dict[Statement, int]\n</code></pre> <p>Mapping from statements to their group number</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/uop_to_parallel/#bloqade.qasm2.rewrite.uop_to_parallel.SimpleMergePolicy.merge_groups","title":"merge_groups  <code>instance-attribute</code>","text":"<pre><code>merge_groups: List[List[Statement]]\n</code></pre> <p>List of groups of statements that can be merged together</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/noise/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/noise/heuristic_noise/","title":"Heuristic noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/noise/heuristic_noise/#bloqade.qasm2.rewrite.noise.heuristic_noise.NoiseRewriteRule","title":"NoiseRewriteRule  <code>dataclass</code>","text":"<pre><code>NoiseRewriteRule(\n    address_analysis: Dict[SSAValue, Address],\n    qubit_ssa_value: Dict[int, SSAValue],\n    noise_model: MoveNoiseModelABC = noise.TwoRowZoneModel(),\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.qasm2.rewrite.noise.heuristic_noise.NoiseRewriteRule[NoiseRewriteRule]\n\n              \n\n              click bloqade.qasm2.rewrite.noise.heuristic_noise.NoiseRewriteRule href \"\" \"bloqade.qasm2.rewrite.noise.heuristic_noise.NoiseRewriteRule\"\n            </code></pre> <p>NOTE: This pass is not guaranteed to be supported long-term in bloqade. We will be moving towards a more general approach to noise modeling in the future.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qasm2/rewrite/noise/remove_noise/","title":"Remove noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/lowering/#bloqade.qbraid.lowering.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/lowering/#bloqade.qbraid.lowering.Lowering.lower","title":"lower","text":"<pre><code>lower(\n    sym_name: str,\n    noise_model: NoiseModel,\n    return_qreg: bool = False,\n) -&gt; ir.Method\n</code></pre> <p>Lower the noise model to a method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the method to generate.</p> required <code>return_qreg</code> <code>bool</code> <p>Use the quantum register as the return value.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Method</code> <code>Method</code> <p>The generated kirin method.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/lowering.py</code> <pre><code>def lower(\n    self,\n    sym_name: str,\n    noise_model: schema.NoiseModel,\n    return_qreg: bool = False,\n) -&gt; ir.Method:\n    \"\"\"Lower the noise model to a method.\n\n    Args:\n        name (str): The name of the method to generate.\n        return_qreg (bool): Use the quantum register as the return value.\n\n    Returns:\n        Method: The generated kirin method.\n\n    \"\"\"\n    self.process_noise_model(noise_model, return_qreg)\n    block = ir.Block(stmts=self.block_list)\n    ret_type = qasm2.types.QRegType if return_qreg else qasm2.types.CRegType\n    block.args.append_from(types.MethodType[[], ret_type], name=f\"{sym_name}_self\")\n    region = ir.Region(block)\n    func_stmt = func.Function(\n        sym_name=sym_name,\n        signature=func.Signature(inputs=(), output=qasm2.types.QRegType),\n        body=region,\n    )\n\n    mt = ir.Method(\n        mod=None,\n        py_func=None,\n        sym_name=sym_name,\n        dialects=qbraid_noise,\n        code=func_stmt,\n        arg_names=[],\n    )\n    qbraid_noise.run_pass(mt)  # type: ignore\n    return mt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/","title":"Schema","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.CZ","title":"CZ","text":"<p>               Bases: <code>Operation</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.CZ[CZ]\n              bloqade.qbraid.schema.Operation[Operation]\n\n                              bloqade.qbraid.schema.Operation --&gt; bloqade.qbraid.schema.CZ\n                \n\n\n              click bloqade.qbraid.schema.CZ href \"\" \"bloqade.qbraid.schema.CZ\"\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>A CZ gate operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"CZ\"]). participants (Tuple[Union[Tuple[int], Tuple[int, int]], ...]): The qubit indices that are participating in the CZ gate.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.CZError","title":"CZError","text":"<p>               Bases: <code>ErrorOperation[ErrorModelType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.CZError[CZError]\n              bloqade.qbraid.schema.ErrorOperation[ErrorOperation]\n\n                              bloqade.qbraid.schema.ErrorOperation --&gt; bloqade.qbraid.schema.CZError\n                \n\n\n              click bloqade.qbraid.schema.CZError href \"\" \"bloqade.qbraid.schema.CZError\"\n              click bloqade.qbraid.schema.ErrorOperation href \"\" \"bloqade.qbraid.schema.ErrorOperation\"\n            </code></pre> <p>CZError operation.</p> Fields <p>survival_prob (Tuple[float, ...]): The survival probabilities for each qubit. error_type (str): The type of error (Literal[\"CZError\"]). storage_error (ErrorModelType): The error model for storage. entangled_error (ErrorModelType): The error model for entangled qubits. single_error (ErrorModelType): The error model for single qubits.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.ErrorModel","title":"ErrorModel","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.ErrorModel[ErrorModel]\n\n              \n\n              click bloqade.qbraid.schema.ErrorModel href \"\" \"bloqade.qbraid.schema.ErrorModel\"\n            </code></pre> <p>Base class for error models.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.ErrorOperation","title":"ErrorOperation","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.ErrorOperation[ErrorOperation]\n\n              \n\n              click bloqade.qbraid.schema.ErrorOperation href \"\" \"bloqade.qbraid.schema.ErrorOperation\"\n            </code></pre> <p>Base class for error operations.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.GateEvent","title":"GateEvent","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.GateEvent[GateEvent]\n\n              \n\n              click bloqade.qbraid.schema.GateEvent href \"\" \"bloqade.qbraid.schema.GateEvent\"\n            </code></pre> <p>A gate event.</p> Fields <p>error (Union[SingleQubitError[ErrorModelType], CZError[ErrorModelType]]): The error model for the gate event. operation (OperationType): The operation for the gate event.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.GlobalRz","title":"GlobalRz","text":"<p>               Bases: <code>Operation</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.GlobalRz[GlobalRz]\n              bloqade.qbraid.schema.Operation[Operation]\n\n                              bloqade.qbraid.schema.Operation --&gt; bloqade.qbraid.schema.GlobalRz\n                \n\n\n              click bloqade.qbraid.schema.GlobalRz href \"\" \"bloqade.qbraid.schema.GlobalRz\"\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>GlobalRz operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"GlobalRz\"]). phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.GlobalW","title":"GlobalW","text":"<p>               Bases: <code>Operation</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.GlobalW[GlobalW]\n              bloqade.qbraid.schema.Operation[Operation]\n\n                              bloqade.qbraid.schema.Operation --&gt; bloqade.qbraid.schema.GlobalW\n                \n\n\n              click bloqade.qbraid.schema.GlobalW href \"\" \"bloqade.qbraid.schema.GlobalW\"\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>GlobalW operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"GlobalW\"]). theta (float): The angle of rotation. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.LocalRz","title":"LocalRz","text":"<p>               Bases: <code>Operation</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.LocalRz[LocalRz]\n              bloqade.qbraid.schema.Operation[Operation]\n\n                              bloqade.qbraid.schema.Operation --&gt; bloqade.qbraid.schema.LocalRz\n                \n\n\n              click bloqade.qbraid.schema.LocalRz href \"\" \"bloqade.qbraid.schema.LocalRz\"\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>LocalRz operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"LocalRz\"]). participants (Tuple[int, ...]): The qubit indices that are participating in the local Rz gate. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.LocalW","title":"LocalW","text":"<p>               Bases: <code>Operation</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.LocalW[LocalW]\n              bloqade.qbraid.schema.Operation[Operation]\n\n                              bloqade.qbraid.schema.Operation --&gt; bloqade.qbraid.schema.LocalW\n                \n\n\n              click bloqade.qbraid.schema.LocalW href \"\" \"bloqade.qbraid.schema.LocalW\"\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>LocalW operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"LocalW\"]). participants (Tuple[int, ...]): The qubit indices that are participating in the local W gate. theta (float): The angle of rotation. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.Measurement","title":"Measurement","text":"<p>               Bases: <code>Operation</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.Measurement[Measurement]\n              bloqade.qbraid.schema.Operation[Operation]\n\n                              bloqade.qbraid.schema.Operation --&gt; bloqade.qbraid.schema.Measurement\n                \n\n\n              click bloqade.qbraid.schema.Measurement href \"\" \"bloqade.qbraid.schema.Measurement\"\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>Measurement operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"Measurement\"]). measure_tag (str): The tag to use for the measurement. participants (Tuple[int, ...]): The qubit indices that are participating in the measurement.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel","title":"NoiseModel","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.NoiseModel[NoiseModel]\n\n              \n\n              click bloqade.qbraid.schema.NoiseModel href \"\" \"bloqade.qbraid.schema.NoiseModel\"\n            </code></pre> <p>Noise model for a circuit.</p> Fields <p>all_qubits (Tuple[int, ...]): The qubit indices for the noise model. gate_events (List[GateEvent[ErrorModelType]]): The gate events for the noise model.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.num_qubits","title":"num_qubits  <code>property</code>","text":"<pre><code>num_qubits: int\n</code></pre> <p>Return the number of qubits in the noise model.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.decompiled_circuit","title":"decompiled_circuit","text":"<pre><code>decompiled_circuit() -&gt; str\n</code></pre> <p>Clean the circuit of noise.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decompiled circuit from hardware execution.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/schema.py</code> <pre><code>def decompiled_circuit(self) -&gt; str:\n    \"\"\"Clean the circuit of noise.\n\n    Returns:\n        str: The decompiled circuit from hardware execution.\n\n    \"\"\"\n    from bloqade.qasm2.emit import QASM2\n    from bloqade.qasm2.passes import glob, parallel\n    from bloqade.qasm2.rewrite.noise import remove_noise\n\n    mt = self.lower_noise_model(\"method\")\n\n    remove_noise.RemoveNoisePass(mt.dialects)(mt)\n    parallel.ParallelToUOp(mt.dialects)(mt)\n    glob.GlobalToUOP(mt.dialects)(mt)\n    return QASM2(qelib1=True).emit_str(mt)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.lower_noise_model","title":"lower_noise_model","text":"<pre><code>lower_noise_model(sym_name: str, return_qreg: bool = False)\n</code></pre> <p>Lower the noise model to a method.</p> <p>Parameters:</p> Name Type Description Default <code>sym_name</code> <code>str</code> <p>The name of the method to generate.</p> required <code>return_qreg</code> <code>bool</code> <p>Whether to return the quantum register after the method has completed execution. Useful for obtaining the full state vector.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>Method</code> <p>The generated kirin method.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/schema.py</code> <pre><code>def lower_noise_model(self, sym_name: str, return_qreg: bool = False):\n    \"\"\"Lower the noise model to a method.\n\n    Args:\n        sym_name (str): The name of the method to generate.\n        return_qreg (bool): Whether to return the quantum register after the method\n            has completed execution. Useful for obtaining the full state vector.\n\n    Returns:\n        Method: The generated kirin method.\n\n    \"\"\"\n    from bloqade.qbraid.lowering import Lowering\n\n    return Lowering().lower(sym_name, self, return_qreg)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.Operation","title":"Operation","text":"<p>               Bases: <code>BaseModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.Operation[Operation]\n\n              \n\n              click bloqade.qbraid.schema.Operation href \"\" \"bloqade.qbraid.schema.Operation\"\n            </code></pre> <p>Base class for operations.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.PauliErrorModel","title":"PauliErrorModel","text":"<p>               Bases: <code>ErrorModel</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.PauliErrorModel[PauliErrorModel]\n              bloqade.qbraid.schema.ErrorModel[ErrorModel]\n\n                              bloqade.qbraid.schema.ErrorModel --&gt; bloqade.qbraid.schema.PauliErrorModel\n                \n\n\n              click bloqade.qbraid.schema.PauliErrorModel href \"\" \"bloqade.qbraid.schema.PauliErrorModel\"\n              click bloqade.qbraid.schema.ErrorModel href \"\" \"bloqade.qbraid.schema.ErrorModel\"\n            </code></pre> <p>Pauli error model.</p> Fields <p>error_model_type (str): The type of error model (Literal[\"PauliNoise\"]). errors (Tuple[Tuple[int, Tuple[float, float, float]], ...]): The qubit indices and the error rates for each qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/schema/#bloqade.qbraid.schema.SingleQubitError","title":"SingleQubitError","text":"<p>               Bases: <code>ErrorOperation[ErrorModelType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.qbraid.schema.SingleQubitError[SingleQubitError]\n              bloqade.qbraid.schema.ErrorOperation[ErrorOperation]\n\n                              bloqade.qbraid.schema.ErrorOperation --&gt; bloqade.qbraid.schema.SingleQubitError\n                \n\n\n              click bloqade.qbraid.schema.SingleQubitError href \"\" \"bloqade.qbraid.schema.SingleQubitError\"\n              click bloqade.qbraid.schema.ErrorOperation href \"\" \"bloqade.qbraid.schema.ErrorOperation\"\n            </code></pre> <p>SingleQubitError operation.</p> Fields <p>survival_prob (Tuple[float, ...]): The survival probabilities for each qubit. error_type (str): The type of error (Literal[\"SingleQubitError\"]). operator_error (ErrorModelType): The error model for the single qubit.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/simulation_result/","title":"Simulation result","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult","title":"QuEraSimulationResult  <code>dataclass</code>","text":"<pre><code>QuEraSimulationResult(\n    flair_visual_version: str,\n    counts: dict[str, int],\n    logs: DataFrame,\n    atom_animation_state: AnimateQPUState,\n    noise_model: NoiseModel,\n)\n</code></pre> <p>Results of the QuEra hardware model simulation.</p> Fields <p>flair_visual_version (str): The version of the Flair Visual package used to generate the simulation result. counts (dict[str, int]): The measurement bitstrings of the simulation. logs (DataFrame): Grainular logs events of what happened to each atom during the simulation. atom_animation_state (vis_qpustate.AnimateQPUState): Object used to play back atom trajectories and events during the simulation. noise_model (NoiseModel): The noise model used in the simulation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.animate","title":"animate","text":"<pre><code>animate(\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: Optional[int] = None,\n)\n</code></pre> <p>animate the qpu state</p> <p>Parameters:</p> Name Type Description Default <code>dilation_rate</code> <code>float</code> <p>Conversion factor from the qpu time to animation time units. when dilation_rate=1.0, 1 (us) of qpu exec time corresponds to 1 second of animation time.</p> <code>0.05</code> <code>fps</code> <code>int</code> <p>frame per second. Defaults to 30.</p> <code>30</code> <code>gate_display_dilation</code> <code>float</code> <p>relative dilation rate of a gate event. Defaults to 1. When setting higher value, the gate event will be displayed longer.</p> <code>1.0</code> <code>save_mpeg</code> <code>bool</code> <p>Save as mpeg. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>The file name of saved mpeg file. Defaults to \"vqpu_animation\". When <code>save_mpeg</code> is False, this argument is ignored.</p> <code>'vqpu_animation'</code> <code>start_block</code> <code>int</code> <p>The start block to animate. Defaults to 0.</p> <code>0</code> <code>n_blocks</code> <code>int</code> <p>number of blocks to animate. Defaults to None. When None, animate all blocks after <code>start_block</code>.</p> <code>None</code> <p>Returns:     ani: matplotlib animation object</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/simulation_result.py</code> <pre><code>def animate(\n    self,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: Optional[int] = None,\n):\n    \"\"\"animate the qpu state\n\n    Args:\n        dilation_rate (float): Conversion factor from the qpu time to animation time units. when dilation_rate=1.0, 1 (us) of qpu exec time corresponds to 1 second of animation time.\n        fps (int, optional): frame per second. Defaults to 30.\n        gate_display_dilation (float, optional): relative dilation rate of a gate event. Defaults to 1. When setting higher value, the gate event will be displayed longer.\n        save_mpeg (bool, optional): Save as mpeg. Defaults to False.\n        filename (str, optional): The file name of saved mpeg file. Defaults to \"vqpu_animation\". When `save_mpeg` is False, this argument is ignored.\n        start_block (int, optional): The start block to animate. Defaults to 0.\n        n_blocks (int, optional): number of blocks to animate. Defaults to None. When None, animate all blocks after `start_block`.\n    Returns:\n        ani: matplotlib animation object\n    \"\"\"\n    from bloqade.visual.animation.animate import animate_qpu_state\n\n    ani = animate_qpu_state(\n        state=self.atom_animation_state,\n        dilation_rate=dilation_rate,\n        fps=fps,\n        gate_display_dilation=gate_display_dilation,\n        start_block=start_block,\n        n_blocks=n_blocks,\n        save_mpeg=save_mpeg,\n        filename=filename,\n    )\n    return ani\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json: dict) -&gt; QuEraSimulationResult\n</code></pre> <p>deserialize the object from a JSON serializable dictionary.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/simulation_result.py</code> <pre><code>@classmethod\ndef from_json(cls, json: dict) -&gt; \"QuEraSimulationResult\":\n    \"\"\"deserialize the object from a JSON serializable dictionary.\"\"\"\n    flair_visual_version = json[\"flair_visual_version\"]\n    counts = json[\"counts\"]\n    logs = pd.read_csv(StringIO(json[\"logs\"]), index_col=0)\n    atom_animation_state = vis_qpustate.AnimateQPUState.from_json(\n        json[\"atom_animation_state\"]\n    )\n    noise_model = NoiseModel(**json[\"noise_model\"])\n\n    return cls(\n        flair_visual_version=flair_visual_version,\n        counts=counts,\n        logs=logs,\n        atom_animation_state=atom_animation_state,\n        noise_model=noise_model,\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; Dict[str, Any]\n</code></pre> <p>Turn the object into a JSON serializable dictionary.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/simulation_result.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"Turn the object into a JSON serializable dictionary.\"\"\"\n    return {\n        \"flair_visual_version\": self.flair_visual_version,\n        \"counts\": self.counts,\n        \"logs\": self.logs.to_csv(),\n        \"atom_animation_state\": self.atom_animation_state.to_json(),\n        \"noise_model\": self.noise_model.model_dump(mode=\"json\"),\n    }\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/target/","title":"Target","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/target/#bloqade.qbraid.target.qBraid","title":"qBraid","text":"<pre><code>qBraid(\n    *,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    provider: QbraidProvider,\n    qelib1: bool = True\n)\n</code></pre> <p>qBraid target for Bloqade kernels.</p> <p>qBraid target that accepts a Bloqade kernel and submits the kernel to the QuEra simulator hosted on qBraid. A <code>QbraidJob</code> is obtainable that then lets you query the status of the submitted program on the simulator as well as obtain results.</p> <p>Parameters:</p> Name Type Description Default <code>allow_parallel</code> <code>bool</code> <p>Allow parallel gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.</p> <code>False</code> <code>allow_global</code> <code>bool</code> <p>Allow global gate in the resulting QASM2 AST. Defaults to <code>False</code>. In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates. If both <code>allow_parallel</code> and <code>allow_global</code> are False, the input kernel will be rewritten to use uop gates.</p> <code>False</code> <code>provider</code> <code>QbraidProvider</code> <p>Qbraid-provided object to allow submission of the kernel to the QuEra simulator.</p> required <code>qelib1</code> <code>bool</code> <p>Include the <code>include \"qelib1.inc\"</code> line in the resulting QASM2 AST that's submitted to qBraid. Defaults to <code>True</code>.</p> <code>True</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/target.py</code> <pre><code>def __init__(\n    self,\n    *,\n    allow_parallel: bool = False,\n    allow_global: bool = False,\n    provider: \"QbraidProvider\",  # inject externally for easier mocking\n    qelib1: bool = True,\n) -&gt; None:\n    \"\"\"Initialize the qBraid target.\n\n    Args:\n        allow_parallel (bool):\n            Allow parallel gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses parallel gates, they will get rewrite into uop gates.\n\n        allow_global (bool):\n            Allow global gate in the resulting QASM2 AST. Defaults to `False`.\n            In the case its False, and the input kernel uses global gates, they will get rewrite into parallel gates.\n            If both `allow_parallel` and `allow_global` are False, the input kernel will be rewritten to use uop gates.\n\n        provider (QbraidProvider):\n            Qbraid-provided object to allow submission of the kernel to the QuEra simulator.\n        qelib1 (bool):\n            Include the `include \"qelib1.inc\"` line in the resulting QASM2 AST that's\n            submitted to qBraid. Defaults to `True`.\n    \"\"\"\n\n    self.qelib1 = qelib1\n    self.provider = provider\n    self.allow_parallel = allow_parallel\n    self.allow_global = allow_global\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qbraid/target/#bloqade.qbraid.target.qBraid.emit","title":"emit","text":"<pre><code>emit(\n    method: Method,\n    shots: Optional[int] = None,\n    tags: Optional[dict[str, str]] = None,\n) -&gt; Union[QbraidJob, list[QbraidJob]]\n</code></pre> <p>Submit the Bloqade kernel to the QuEra simulator on qBraid.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>Method</code> <p>The kernel to submit to qBraid.</p> required <code>shots</code> <code>Optional[int]</code> <p>(Optional[int]): Number of times to run the kernel. Defaults to None.</p> <code>None</code> <code>tags</code> <code>Optional[dict[str, str]]</code> <p>(Optional[dict[str,str]]): A dictionary of tags to associate with the Job.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[QbraidJob, list[QbraidJob]]</code> <p>Union[QbraidJob, list[QbraidJob]]: An object you can query for the status of your submission as well as obtain simulator results from.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qbraid/target.py</code> <pre><code>def emit(\n    self,\n    method: ir.Method,\n    shots: Optional[int] = None,\n    tags: Optional[dict[str, str]] = None,\n) -&gt; Union[\"QbraidJob\", list[\"QbraidJob\"]]:\n    \"\"\"Submit the Bloqade kernel to the QuEra simulator on qBraid.\n\n    Args:\n        method (ir.Method):\n            The kernel to submit to qBraid.\n        shots: (Optional[int]):\n            Number of times to run the kernel. Defaults to None.\n        tags: (Optional[dict[str,str]]):\n            A dictionary of tags to associate with the Job.\n\n    Returns:\n        Union[QbraidJob, list[QbraidJob]]:\n            An object you can query for the status of your submission as well as\n            obtain simulator results from.\n    \"\"\"\n\n    # Convert method to QASM2 string\n    qasm2_emitter = QASM2(\n        allow_parallel=self.allow_parallel,\n        allow_global=self.allow_global,\n        qelib1=self.qelib1,\n    )\n    qasm2_prog = qasm2_emitter.emit_str(method)\n\n    # Submit the QASM2 string to the qBraid simulator\n    quera_qasm_simulator = self.provider.get_device(\"quera_qasm_simulator\")\n\n    return quera_qasm_simulator.run(qasm2_prog, shots=shots, tags=tags)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/analysis/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/analysis/address_impl/","title":"Address impl","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/broadcast/","title":"Broadcast","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/broadcast/#bloqade.qubit.stdlib.broadcast.get_measurement_id","title":"get_measurement_id","text":"<pre><code>get_measurement_id(\n    measurements: IList[MeasurementResult, N],\n) -&gt; ilist.IList[int, N]\n</code></pre> <p>Get the global, unique ID of each of the measurement results in the list.</p> <p>Parameters:</p> Name Type Description Default <code>measurements</code> <code>IList[MeasurementResult, N]</code> <p>The previously taken measurement of which you want to know the ID.</p> required <p>Returns:     measurement_ids (IList[int, N]): The list of global, unique IDs of the measurements.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/broadcast.py</code> <pre><code>@kernel\ndef get_measurement_id(\n    measurements: ilist.IList[MeasurementResult, N],\n) -&gt; ilist.IList[int, N]:\n    \"\"\"Get the global, unique ID of each of the measurement results in the list.\n\n    Args:\n        measurements (IList[MeasurementResult, N]): The previously taken measurement of which you want to know the ID.\n    Returns:\n        measurement_ids (IList[int, N]): The list of global, unique IDs of the measurements.\n    \"\"\"\n    return _qubit.get_measurement_id(measurements)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/broadcast/#bloqade.qubit.stdlib.broadcast.get_qubit_id","title":"get_qubit_id","text":"<pre><code>get_qubit_id(\n    qubits: IList[Qubit, N],\n) -&gt; ilist.IList[int, N]\n</code></pre> <p>Get the global, unique ID of each qubit in the list.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, N]</code> <p>The list of qubits of which you want the ID.</p> required <p>Returns:</p> Name Type Description <code>qubit_ids</code> <code>IList[int, N]</code> <p>The list of global, unique IDs of the qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/broadcast.py</code> <pre><code>@kernel\ndef get_qubit_id(qubits: ilist.IList[Qubit, N]) -&gt; ilist.IList[int, N]:\n    \"\"\"Get the global, unique ID of each qubit in the list.\n\n    Args:\n        qubits (IList[Qubit, N]): The list of qubits of which you want the ID.\n\n    Returns:\n        qubit_ids (IList[int, N]): The list of global, unique IDs of the qubits.\n    \"\"\"\n    return _qubit.get_qubit_id(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/broadcast/#bloqade.qubit.stdlib.broadcast.measure","title":"measure","text":"<pre><code>measure(\n    qubits: IList[Qubit, N],\n) -&gt; ilist.IList[MeasurementResult, N]\n</code></pre> <p>Measure a list of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, N]</code> <p>The list of qubits to measure.</p> required <p>Returns:</p> Type Description <code>IList[MeasurementResult, N]</code> <p>IList[MeasurementResult, N]: The list containing the results of the measurements. A MeasurementResult can represent both 0 and 1 as well as atom loss.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/broadcast.py</code> <pre><code>@kernel\ndef measure(qubits: ilist.IList[Qubit, N]) -&gt; ilist.IList[MeasurementResult, N]:\n    \"\"\"Measure a list of qubits.\n\n    Args:\n        qubits (IList[Qubit, N]): The list of qubits to measure.\n\n    Returns:\n        IList[MeasurementResult, N]: The list containing the results of the measurements.\n            A MeasurementResult can represent both 0 and 1 as well as atom loss.\n    \"\"\"\n    return _qubit.measure(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/broadcast/#bloqade.qubit.stdlib.broadcast.reset","title":"reset","text":"<pre><code>reset(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Reset a list of qubits to the zero state.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to reset.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/broadcast.py</code> <pre><code>@kernel\ndef reset(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"\n    Reset a list of qubits to the zero state.\n\n    Args:\n        qubits (IList[Qubit, Any]): The list of qubits to reset.\n    \"\"\"\n    _qubit.reset(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/simple/","title":"Simple","text":""},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/simple/#bloqade.qubit.stdlib.simple.get_measurement_id","title":"get_measurement_id","text":"<pre><code>get_measurement_id(measurement: MeasurementResult) -&gt; int\n</code></pre> <p>Get the global, unique ID of the measurement result.</p> <p>Parameters:</p> Name Type Description Default <code>measurement</code> <code>MeasurementResult</code> <p>The previously taken measurement of which you want to know the ID.</p> required <p>Returns:     measurement_id (int): The global, unique ID of the measurement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/simple.py</code> <pre><code>@kernel\ndef get_measurement_id(measurement: MeasurementResult) -&gt; int:\n    \"\"\"Get the global, unique ID of the measurement result.\n\n    Args:\n        measurement (MeasurementResult): The previously taken measurement of which you want to know the ID.\n    Returns:\n        measurement_id (int): The global, unique ID of the measurement.\n    \"\"\"\n    ids = broadcast.get_measurement_id(ilist.IList([measurement]))\n    return ids[0]\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/simple/#bloqade.qubit.stdlib.simple.get_qubit_id","title":"get_qubit_id","text":"<pre><code>get_qubit_id(qubit: Qubit) -&gt; int\n</code></pre> <p>Get the global, unique ID of the qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit of which you want the ID.</p> required <p>Returns:</p> Name Type Description <code>qubit_id</code> <code>int</code> <p>The global, unique ID of the qubit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/simple.py</code> <pre><code>@kernel\ndef get_qubit_id(qubit: Qubit) -&gt; int:\n    \"\"\"Get the global, unique ID of the qubit.\n\n    Args:\n        qubit (Qubit): The qubit of which you want the ID.\n\n    Returns:\n        qubit_id (int): The global, unique ID of the qubit.\n    \"\"\"\n    ids = broadcast.get_qubit_id(ilist.IList([qubit]))\n    return ids[0]\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/simple/#bloqade.qubit.stdlib.simple.measure","title":"measure","text":"<pre><code>measure(qubit: Qubit) -&gt; MeasurementResult\n</code></pre> <p>Measure a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The qubit to measure.</p> required <p>Returns:</p> Name Type Description <code>MeasurementResult</code> <code>MeasurementResult</code> <p>The result of the measurement. A MeasurementResult can represent both 0 and 1, but also atoms that are lost.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/simple.py</code> <pre><code>@kernel\ndef measure(qubit: Qubit) -&gt; MeasurementResult:\n    \"\"\"Measure a qubit.\n\n    Args:\n        qubit (Qubit): The qubit to measure.\n\n    Returns:\n        MeasurementResult: The result of the measurement.\n            A MeasurementResult can represent both 0 and 1, but also atoms that are lost.\n    \"\"\"\n    measurement_results = broadcast.measure(ilist.IList([qubit]))\n    return measurement_results[0]\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/qubit/stdlib/simple/#bloqade.qubit.stdlib.simple.reset","title":"reset","text":"<pre><code>reset(qubit: Qubit) -&gt; None\n</code></pre> <p>Reset a qubit to the zero state.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>The list qubit to reset.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/qubit/stdlib/simple.py</code> <pre><code>@kernel\ndef reset(qubit: Qubit) -&gt; None:\n    \"\"\"\n    Reset a qubit to the zero state.\n\n    Args:\n        qubit (Qubit): The list qubit to reset.\n    \"\"\"\n    return broadcast.reset(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/aggressive_unroll/","title":"Aggressive unroll","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/aggressive_unroll/#bloqade.rewrite.passes.aggressive_unroll.AggressiveUnroll","title":"AggressiveUnroll  <code>dataclass</code>","text":"<pre><code>AggressiveUnroll(\n    additional_inline_heuristic: Callable[\n        [Statement], bool\n    ] = lambda node: True,\n)\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.rewrite.passes.aggressive_unroll.AggressiveUnroll[AggressiveUnroll]\n\n              \n\n              click bloqade.rewrite.passes.aggressive_unroll.AggressiveUnroll href \"\" \"bloqade.rewrite.passes.aggressive_unroll.AggressiveUnroll\"\n            </code></pre> <p>A pass to unroll structured control flow</p>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/aggressive_unroll/#bloqade.rewrite.passes.aggressive_unroll.AggressiveUnroll.inline_heuristic","title":"inline_heuristic","text":"<pre><code>inline_heuristic(node: Statement) -&gt; bool\n</code></pre> <p>The heuristic to decide whether to inline a function call or not. inside loops and if-else, only inline simple functions, i.e. functions with a single block</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/rewrite/passes/aggressive_unroll.py</code> <pre><code>def inline_heuristic(self, node: ir.Statement) -&gt; bool:\n    \"\"\"The heuristic to decide whether to inline a function call or not.\n    inside loops and if-else, only inline simple functions, i.e.\n    functions with a single block\n    \"\"\"\n    return not isinstance(\n        node.parent_stmt, (scf.For, scf.IfElse)\n    ) and self.additional_inline_heuristic(\n        node\n    )  # always inline calls outside of loops and if-else\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/callgraph/","title":"Callgraph","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/callgraph/#bloqade.rewrite.passes.callgraph.CallGraphPass","title":"CallGraphPass  <code>dataclass</code>","text":"<pre><code>CallGraphPass(rule: RewriteRule)\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.rewrite.passes.callgraph.CallGraphPass[CallGraphPass]\n\n              \n\n              click bloqade.rewrite.passes.callgraph.CallGraphPass href \"\" \"bloqade.rewrite.passes.callgraph.CallGraphPass\"\n            </code></pre> <p>Copy all functions in the call graph and apply a rule to each of them.</p> Usage <p>rule = Walk(SomeRewriteRule()) pass_ = CallGraphPass(rule=rule, dialects=...) pass_(some_method)</p> <p>Note: This pass modifies the input method in place, but copies all methods invoked within it before applying the rule to them.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/callgraph/#bloqade.rewrite.passes.callgraph.CallGraphPass.rule","title":"rule  <code>instance-attribute</code>","text":"<pre><code>rule: RewriteRule\n</code></pre> <p>The rule to apply to each function in the call graph.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/callgraph/#bloqade.rewrite.passes.callgraph.UpdateDialectsOnCallGraph","title":"UpdateDialectsOnCallGraph  <code>dataclass</code>","text":"<pre><code>UpdateDialectsOnCallGraph()\n</code></pre> <p>               Bases: <code>Pass</code></p> <pre><code>\n              flowchart TD\n              bloqade.rewrite.passes.callgraph.UpdateDialectsOnCallGraph[UpdateDialectsOnCallGraph]\n\n              \n\n              click bloqade.rewrite.passes.callgraph.UpdateDialectsOnCallGraph href \"\" \"bloqade.rewrite.passes.callgraph.UpdateDialectsOnCallGraph\"\n            </code></pre> <p>Update All dialects on the call graph to a new set of dialects given to this pass.</p> Usage <p>pass_ = UpdateDialectsOnCallGraph(rule=rule, dialects=new_dialects) pass_(some_method)</p> <p>Note: This pass does not update the dialects of the input method, but copies all other methods invoked within it before updating their dialects.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/passes/canonicalize_ilist/","title":"Canonicalize ilist","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/rules/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/rules/split_ifs/","title":"Split ifs","text":""},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/rules/split_ifs/#bloqade.rewrite.rules.split_ifs.LiftThenBody","title":"LiftThenBody  <code>dataclass</code>","text":"<pre><code>LiftThenBody(\n    exclude_stmts: tuple[type[Statement], ...] = tuple(),\n)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.rewrite.rules.split_ifs.LiftThenBody[LiftThenBody]\n\n              \n\n              click bloqade.rewrite.rules.split_ifs.LiftThenBody href \"\" \"bloqade.rewrite.rules.split_ifs.LiftThenBody\"\n            </code></pre> <p>Lifts anything that's not in the <code>exclude_stmts</code> in the then body</p> <p>Parameters:</p> Name Type Description Default <code>exclude_stmts</code> <code>tuple[type[Statement], ...]</code> <p>A tuple of statement types that should not be lifted from the then body. Defaults to an empty tuple, meaning all statements are lifted.</p> <code>tuple()</code>"},{"location":"reference/bloqade-circuit/src/bloqade/rewrite/rules/split_ifs/#bloqade.rewrite.rules.split_ifs.SplitIfStmts","title":"SplitIfStmts","text":"<p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.rewrite.rules.split_ifs.SplitIfStmts[SplitIfStmts]\n\n              \n\n              click bloqade.rewrite.rules.split_ifs.SplitIfStmts href \"\" \"bloqade.rewrite.rules.split_ifs.SplitIfStmts\"\n            </code></pre> <p>Splits the then body of an if-else statement into multiple if statements</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/groups/","title":"Groups","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/analysis/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/analysis/schedule/","title":"Schedule","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/analysis/schedule/#bloqade.squin.analysis.schedule.StmtDag","title":"StmtDag  <code>dataclass</code>","text":"<pre><code>StmtDag(\n    id_table: IdTable[Statement] = (\n        lambda: idtable.IdTable()\n    )(),\n    stmts: Dict[str, Statement] = OrderedDict(),\n    out_edges: Dict[str, Set[str]] = OrderedDict(),\n    inc_edges: Dict[str, Set[str]] = OrderedDict(),\n    stmt_index: Dict[Statement, int] = OrderedDict(),\n)\n</code></pre> <p>               Bases: <code>Graph[Statement]</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.analysis.schedule.StmtDag[StmtDag]\n\n              \n\n              click bloqade.squin.analysis.schedule.StmtDag href \"\" \"bloqade.squin.analysis.schedule.StmtDag\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/analysis/schedule/#bloqade.squin.analysis.schedule.StmtDag.topological_groups","title":"topological_groups","text":"<pre><code>topological_groups()\n</code></pre> <p>Split the dag into topological groups where each group contains nodes that have no dependencies on each other, but have dependencies on nodes in one or more previous groups.</p> <p>Yields:</p> Type Description <p>List[str]: A list of node ids in a topological group</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a cyclic dependency is detected</p> <p>The idea is to yield all nodes with no dependencies, then remove those nodes from the graph repeating until no nodes are left or we reach some upper limit. Worse case is a linear dag, so we can use len(dag.stmts) as the upper limit</p> <p>If we reach the limit and there are still nodes left, then we have a cyclic dependency.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/analysis/schedule.py</code> <pre><code>def topological_groups(self):\n    \"\"\"Split the dag into topological groups where each group\n    contains nodes that have no dependencies on each other, but\n    have dependencies on nodes in one or more previous groups.\n\n    Yields:\n        List[str]: A list of node ids in a topological group\n\n\n    Raises:\n        ValueError: If a cyclic dependency is detected\n\n\n    The idea is to yield all nodes with no dependencies, then remove\n    those nodes from the graph repeating until no nodes are left\n    or we reach some upper limit. Worse case is a linear dag,\n    so we can use len(dag.stmts) as the upper limit\n\n    If we reach the limit and there are still nodes left, then we\n    have a cyclic dependency.\n    \"\"\"\n\n    inc_edges = {k: set(v) for k, v in self.inc_edges.items()}\n\n    check_next = inc_edges.keys()\n\n    for _ in range(len(self.stmts)):\n        if len(inc_edges) == 0:\n            break\n\n        group = [node_id for node_id in check_next if len(inc_edges[node_id]) == 0]\n        yield group\n\n        check_next = set()\n        for n in group:\n            inc_edges.pop(n)\n            for m in self.out_edges[n]:\n                check_next.add(m)\n                inc_edges[m].remove(n)\n\n    if inc_edges:\n        raise ValueError(\"Cyclic dependency detected\")\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/gate/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/gate/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/#bloqade.squin.noise.stmts.CorrelatedQubitLoss","title":"CorrelatedQubitLoss","text":"<p>               Bases: <code>NoiseChannel</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.noise.stmts.CorrelatedQubitLoss[CorrelatedQubitLoss]\n              bloqade.squin.noise.stmts.NoiseChannel[NoiseChannel]\n\n                              bloqade.squin.noise.stmts.NoiseChannel --&gt; bloqade.squin.noise.stmts.CorrelatedQubitLoss\n                \n\n\n              click bloqade.squin.noise.stmts.CorrelatedQubitLoss href \"\" \"bloqade.squin.noise.stmts.CorrelatedQubitLoss\"\n              click bloqade.squin.noise.stmts.NoiseChannel href \"\" \"bloqade.squin.noise.stmts.NoiseChannel\"\n            </code></pre> <p>Apply a correlated atom loss channel.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/#bloqade.squin.noise.stmts.Depolarize","title":"Depolarize","text":"<p>               Bases: <code>SingleQubitNoiseChannel</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.noise.stmts.Depolarize[Depolarize]\n              bloqade.squin.noise.stmts.SingleQubitNoiseChannel[SingleQubitNoiseChannel]\n              bloqade.squin.noise.stmts.NoiseChannel[NoiseChannel]\n\n                              bloqade.squin.noise.stmts.SingleQubitNoiseChannel --&gt; bloqade.squin.noise.stmts.Depolarize\n                                bloqade.squin.noise.stmts.NoiseChannel --&gt; bloqade.squin.noise.stmts.SingleQubitNoiseChannel\n                \n\n\n\n              click bloqade.squin.noise.stmts.Depolarize href \"\" \"bloqade.squin.noise.stmts.Depolarize\"\n              click bloqade.squin.noise.stmts.SingleQubitNoiseChannel href \"\" \"bloqade.squin.noise.stmts.SingleQubitNoiseChannel\"\n              click bloqade.squin.noise.stmts.NoiseChannel href \"\" \"bloqade.squin.noise.stmts.NoiseChannel\"\n            </code></pre> <p>Apply depolarize error to single qubit.</p> <p>This randomly picks one of the three Pauli operators to apply. Each Pauli operator has the probability <code>p / 3</code> to be selected. No operator is applied with the probability <code>1 - p</code>.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/#bloqade.squin.noise.stmts.Depolarize2","title":"Depolarize2","text":"<p>               Bases: <code>TwoQubitNoiseChannel</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.noise.stmts.Depolarize2[Depolarize2]\n              bloqade.squin.noise.stmts.TwoQubitNoiseChannel[TwoQubitNoiseChannel]\n              bloqade.squin.noise.stmts.NoiseChannel[NoiseChannel]\n\n                              bloqade.squin.noise.stmts.TwoQubitNoiseChannel --&gt; bloqade.squin.noise.stmts.Depolarize2\n                                bloqade.squin.noise.stmts.NoiseChannel --&gt; bloqade.squin.noise.stmts.TwoQubitNoiseChannel\n                \n\n\n\n              click bloqade.squin.noise.stmts.Depolarize2 href \"\" \"bloqade.squin.noise.stmts.Depolarize2\"\n              click bloqade.squin.noise.stmts.TwoQubitNoiseChannel href \"\" \"bloqade.squin.noise.stmts.TwoQubitNoiseChannel\"\n              click bloqade.squin.noise.stmts.NoiseChannel href \"\" \"bloqade.squin.noise.stmts.NoiseChannel\"\n            </code></pre> <p>Apply correlated depolarize error to two qubits</p> <p>This will apply one of the randomly chosen Pauli products each with probability <code>p / 15</code>:</p> <p><code>{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}</code></p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/#bloqade.squin.noise.stmts.QubitLoss","title":"QubitLoss","text":"<p>               Bases: <code>SingleQubitNoiseChannel</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.noise.stmts.QubitLoss[QubitLoss]\n              bloqade.squin.noise.stmts.SingleQubitNoiseChannel[SingleQubitNoiseChannel]\n              bloqade.squin.noise.stmts.NoiseChannel[NoiseChannel]\n\n                              bloqade.squin.noise.stmts.SingleQubitNoiseChannel --&gt; bloqade.squin.noise.stmts.QubitLoss\n                                bloqade.squin.noise.stmts.NoiseChannel --&gt; bloqade.squin.noise.stmts.SingleQubitNoiseChannel\n                \n\n\n\n              click bloqade.squin.noise.stmts.QubitLoss href \"\" \"bloqade.squin.noise.stmts.QubitLoss\"\n              click bloqade.squin.noise.stmts.SingleQubitNoiseChannel href \"\" \"bloqade.squin.noise.stmts.SingleQubitNoiseChannel\"\n              click bloqade.squin.noise.stmts.NoiseChannel href \"\" \"bloqade.squin.noise.stmts.NoiseChannel\"\n            </code></pre> <p>Apply an atom loss with channel.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/#bloqade.squin.noise.stmts.SingleQubitPauliChannel","title":"SingleQubitPauliChannel","text":"<p>               Bases: <code>SingleQubitNoiseChannel</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.noise.stmts.SingleQubitPauliChannel[SingleQubitPauliChannel]\n              bloqade.squin.noise.stmts.SingleQubitNoiseChannel[SingleQubitNoiseChannel]\n              bloqade.squin.noise.stmts.NoiseChannel[NoiseChannel]\n\n                              bloqade.squin.noise.stmts.SingleQubitNoiseChannel --&gt; bloqade.squin.noise.stmts.SingleQubitPauliChannel\n                                bloqade.squin.noise.stmts.NoiseChannel --&gt; bloqade.squin.noise.stmts.SingleQubitNoiseChannel\n                \n\n\n\n              click bloqade.squin.noise.stmts.SingleQubitPauliChannel href \"\" \"bloqade.squin.noise.stmts.SingleQubitPauliChannel\"\n              click bloqade.squin.noise.stmts.SingleQubitNoiseChannel href \"\" \"bloqade.squin.noise.stmts.SingleQubitNoiseChannel\"\n              click bloqade.squin.noise.stmts.NoiseChannel href \"\" \"bloqade.squin.noise.stmts.NoiseChannel\"\n            </code></pre> <p>This will apply one of the randomly chosen Pauli operators according to the given probabilities (p_x, p_y, p_z).</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/noise/stmts/#bloqade.squin.noise.stmts.TwoQubitPauliChannel","title":"TwoQubitPauliChannel","text":"<p>               Bases: <code>TwoQubitNoiseChannel</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.noise.stmts.TwoQubitPauliChannel[TwoQubitPauliChannel]\n              bloqade.squin.noise.stmts.TwoQubitNoiseChannel[TwoQubitNoiseChannel]\n              bloqade.squin.noise.stmts.NoiseChannel[NoiseChannel]\n\n                              bloqade.squin.noise.stmts.TwoQubitNoiseChannel --&gt; bloqade.squin.noise.stmts.TwoQubitPauliChannel\n                                bloqade.squin.noise.stmts.NoiseChannel --&gt; bloqade.squin.noise.stmts.TwoQubitNoiseChannel\n                \n\n\n\n              click bloqade.squin.noise.stmts.TwoQubitPauliChannel href \"\" \"bloqade.squin.noise.stmts.TwoQubitPauliChannel\"\n              click bloqade.squin.noise.stmts.TwoQubitNoiseChannel href \"\" \"bloqade.squin.noise.stmts.TwoQubitNoiseChannel\"\n              click bloqade.squin.noise.stmts.NoiseChannel href \"\" \"bloqade.squin.noise.stmts.NoiseChannel\"\n            </code></pre> <p>This will apply one of the randomly chosen Pauli products:</p> <p>{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}</p> <p>but the choice is weighed with the given probability.</p> <p>NOTE: the given parameters are ordered as given in the list above!</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/U3_to_clifford/","title":"U3 to clifford","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/U3_to_clifford/#bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford","title":"SquinU3ToClifford","text":"<p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford[SquinU3ToClifford]\n\n              \n\n              click bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford href \"\" \"bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford\"\n            </code></pre> <p>Rewrite squin U3 statements to clifford when possible.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/U3_to_clifford/#bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford.decompose_U3_gates","title":"decompose_U3_gates","text":"<pre><code>decompose_U3_gates(\n    node: U3,\n) -&gt; list[type[ir.Statement]] | list[None]\n</code></pre> <p>Rewrite U3 statements to clifford gates if possible.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/rewrite/U3_to_clifford.py</code> <pre><code>def decompose_U3_gates(\n    self, node: gate.stmts.U3\n) -&gt; list[type[ir.Statement]] | list[None]:\n    \"\"\"\n    Rewrite U3 statements to clifford gates if possible.\n    \"\"\"\n    theta = self.get_constant(node.theta)\n    phi = self.get_constant(node.phi)\n    lam = self.get_constant(node.lam)\n\n    if theta is None or phi is None or lam is None:\n        return []\n\n    # Angles will be in units of turns, we convert to radians\n    # to allow for the old logic to work\n    theta = theta * math.tau\n    phi = phi * math.tau\n    lam = lam * math.tau\n\n    # For U3(2*pi*n, phi, lam) = U3(0, 0, lam + phi) which is a Z rotation.\n    if np.isclose(np.mod(theta, math.tau), 0):\n        lam = lam + phi\n        phi = 0.0\n    elif np.isclose(np.mod(theta + np.pi, math.tau), 0):\n        lam = lam - phi\n        phi = 0.0\n\n    theta_half_pi: int | None = self.resolve_angle(theta)\n    phi_half_pi: int | None = self.resolve_angle(phi)\n    lam_half_pi: int | None = self.resolve_angle(lam)\n\n    if theta_half_pi is None or phi_half_pi is None or lam_half_pi is None:\n        return []\n\n    angles_key = (theta_half_pi, phi_half_pi, lam_half_pi)\n    if angles_key not in U3_HALF_PI_ANGLE_TO_GATES:\n        angles_key = equivalent_u3_para(*angles_key)\n        if angles_key not in U3_HALF_PI_ANGLE_TO_GATES:\n            return []\n\n    gates_stmts = U3_HALF_PI_ANGLE_TO_GATES.get(angles_key)\n\n    # no consistent gates, then:\n    assert (\n        gates_stmts is not None\n    ), \"internal error, U3 gates not found for angles: {}\".format(angles_key)\n\n    return gates_stmts\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/U3_to_clifford/#bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford.resolve_angle","title":"resolve_angle","text":"<pre><code>resolve_angle(angle: float) -&gt; int | None\n</code></pre> <p>Normalize the angle to be in the range [0, 2\u03c0).</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/rewrite/U3_to_clifford.py</code> <pre><code>def resolve_angle(self, angle: float) -&gt; int | None:\n    \"\"\"\n    Normalize the angle to be in the range [0, 2\u03c0).\n    \"\"\"\n    # convert to 0.0~1.0, in unit of pi/2\n    angle_half_pi = angle / math.pi * 2.0\n\n    mod = angle_half_pi % 1.0\n    if not (np.isclose(mod, 0.0) or np.isclose(mod, 1.0)):\n        return None\n\n    else:\n        return round((angle / math.tau) % 1 * 4) % 4\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/U3_to_clifford/#bloqade.squin.rewrite.U3_to_clifford.SquinU3ToClifford.rewrite_U3","title":"rewrite_U3","text":"<pre><code>rewrite_U3(node: U3) -&gt; RewriteResult\n</code></pre> <p>Rewrite Apply and Broadcast nodes to their clifford equivalent statements.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/rewrite/U3_to_clifford.py</code> <pre><code>def rewrite_U3(self, node: gate.stmts.U3) -&gt; RewriteResult:\n    \"\"\"\n    Rewrite Apply and Broadcast nodes to their clifford equivalent statements.\n    \"\"\"\n\n    gates = self.decompose_U3_gates(node)\n\n    if len(gates) == 0:\n        return RewriteResult()\n\n    # Get rid of the U3 gate altogether if it's identity\n    if len(gates) == 1 and gates[0] is None:\n        node.delete()\n        return RewriteResult(has_done_something=True)\n\n    for gate_stmt in gates:\n        if gate_stmt is Sdag:\n            new_stmt = gate.stmts.S(adjoint=True, qubits=node.qubits)\n        elif gate_stmt is SqrtXdag:\n            new_stmt = gate.stmts.SqrtX(adjoint=True, qubits=node.qubits)\n        elif gate_stmt is SqrtYdag:\n            new_stmt = gate.stmts.SqrtY(adjoint=True, qubits=node.qubits)\n        else:\n            new_stmt = gate_stmt(qubits=node.qubits)\n        new_stmt.insert_before(node)\n\n    node.delete()\n\n    return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/U3_to_clifford/#bloqade.squin.rewrite.U3_to_clifford.equivalent_u3_para","title":"equivalent_u3_para","text":"<pre><code>equivalent_u3_para(\n    theta_half_pi: int, phi_half_pi: int, lam_half_pi: int\n) -&gt; tuple[int, int, int]\n</code></pre> <ol> <li>Assume all three angles are in the range [0, 4].</li> <li>U3(theta, phi, lam) = -U3(2pi-theta, phi+pi, lam+pi).</li> </ol> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/rewrite/U3_to_clifford.py</code> <pre><code>def equivalent_u3_para(\n    theta_half_pi: int, phi_half_pi: int, lam_half_pi: int\n) -&gt; tuple[int, int, int]:\n    \"\"\"\n    1. Assume all three angles are in the range [0, 4].\n    2. U3(theta, phi, lam) = -U3(2pi-theta, phi+pi, lam+pi).\n    \"\"\"\n    return ((4 - theta_half_pi) % 4, (phi_half_pi + 2) % 4, (lam_half_pi + 2) % 4)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/remove_dangling_qubits/","title":"Remove dangling qubits","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/rewrite/wrap_analysis/","title":"Wrap analysis","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/","title":"Gate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.cx","title":"cx","text":"<pre><code>cx(\n    controls: IList[Qubit, Len], targets: IList[Qubit, Len]\n) -&gt; None\n</code></pre> <p>Apply a controlled-X gate to pairs of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>IList[Qubit, N]</code> <p>Control qubits.</p> required <code>targets</code> <code>IList[Qubit, N]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef cx(controls: ilist.IList[Qubit, Len], targets: ilist.IList[Qubit, Len]) -&gt; None:\n    \"\"\"Apply a controlled-X gate to pairs of qubits.\n\n    Args:\n        controls (ilist.IList[Qubit, N]): Control qubits.\n        targets (ilist.IList[Qubit, N]): Target qubits.\n    \"\"\"\n    gate.cx(controls, targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.cy","title":"cy","text":"<pre><code>cy(\n    controls: IList[Qubit, Len], targets: IList[Qubit, Len]\n) -&gt; None\n</code></pre> <p>Apply a controlled-Y gate to pairs of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>IList[Qubit, N]</code> <p>Control qubits.</p> required <code>targets</code> <code>IList[Qubit, N]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef cy(controls: ilist.IList[Qubit, Len], targets: ilist.IList[Qubit, Len]) -&gt; None:\n    \"\"\"Apply a controlled-Y gate to pairs of qubits.\n\n    Args:\n        controls (ilist.IList[Qubit, N]): Control qubits.\n        targets (ilist.IList[Qubit, N]): Target qubits.\n    \"\"\"\n    gate.cy(controls, targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.cz","title":"cz","text":"<pre><code>cz(\n    controls: IList[Qubit, Len], targets: IList[Qubit, Len]\n) -&gt; None\n</code></pre> <p>Apply a controlled-Z gate to pairs of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>IList[Qubit, N]</code> <p>Control qubits.</p> required <code>targets</code> <code>IList[Qubit, N]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef cz(controls: ilist.IList[Qubit, Len], targets: ilist.IList[Qubit, Len]) -&gt; None:\n    \"\"\"Apply a controlled-Z gate to pairs of qubits.\n\n    Args:\n        controls (ilist.IList[Qubit, N]): Control qubits.\n        targets (ilist.IList[Qubit, N]): Target qubits.\n    \"\"\"\n    gate.cz(controls, targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.h","title":"h","text":"<pre><code>h(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a Hadamard gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef h(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a Hadamard gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.h(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.rx","title":"rx","text":"<pre><code>rx(angle: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply an RX rotation gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef rx(angle: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply an RX rotation gate to a group of qubits.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.rx(_radian_to_turn(angle), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.ry","title":"ry","text":"<pre><code>ry(angle: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply an RY rotation gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef ry(angle: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply an RY rotation gate to a group of qubits.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.ry(_radian_to_turn(angle), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.rz","title":"rz","text":"<pre><code>rz(angle: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply an RZ rotation gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef rz(angle: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply an RZ rotation gate to a group of qubits.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.rz(_radian_to_turn(angle), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.s","title":"s","text":"<pre><code>s(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply an S gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef s(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply an S gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.s(qubits, adjoint=False)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.s_adj","title":"s_adj","text":"<pre><code>s_adj(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply the adjoint of an S gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef s_adj(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply the adjoint of an S gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.s(qubits, adjoint=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.shift","title":"shift","text":"<pre><code>shift(angle: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a phase shift to the |1&gt; state to a group of qubits. Args:     angle (float): Phase shift angle in radians.     qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef shift(angle: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a phase shift to the |1&gt; state to a group of qubits.\n    Args:\n        angle (float): Phase shift angle in radians.\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    rz(angle / 2.0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.sqrt_x","title":"sqrt_x","text":"<pre><code>sqrt_x(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a Sqrt(X) gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef sqrt_x(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a Sqrt(X) gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.sqrt_x(qubits, adjoint=False)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.sqrt_x_adj","title":"sqrt_x_adj","text":"<pre><code>sqrt_x_adj(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply the adjoint of a Sqrt(X) gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef sqrt_x_adj(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply the adjoint of a Sqrt(X) gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.sqrt_x(qubits, adjoint=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.sqrt_y","title":"sqrt_y","text":"<pre><code>sqrt_y(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a sqrt(Y) gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef sqrt_y(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a sqrt(Y) gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.sqrt_y(qubits, adjoint=False)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.sqrt_y_adj","title":"sqrt_y_adj","text":"<pre><code>sqrt_y_adj(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply the adjoint of a Sqrt(Y) gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef sqrt_y_adj(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply the adjoint of a Sqrt(Y) gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.sqrt_y(qubits, adjoint=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.sqrt_z","title":"sqrt_z","text":"<pre><code>sqrt_z(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a Sqrt(Z) gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef sqrt_z(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a Sqrt(Z) gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.s(qubits, adjoint=False)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.sqrt_z_adj","title":"sqrt_z_adj","text":"<pre><code>sqrt_z_adj(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply the adjoint of a Sqrt(Z) gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef sqrt_z_adj(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply the adjoint of a Sqrt(Z) gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.s(qubits, adjoint=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.t","title":"t","text":"<pre><code>t(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a T gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef t(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a T gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.t(qubits, adjoint=False)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.t_adj","title":"t_adj","text":"<pre><code>t_adj(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply the adjoint of a T gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef t_adj(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply the adjoint of a T gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.t(qubits, adjoint=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.u3","title":"u3","text":"<pre><code>u3(\n    theta: float,\n    phi: float,\n    lam: float,\n    qubits: IList[Qubit, Any],\n)\n</code></pre> <p>Apply the U3 gate to a group of qubits.</p> <p>The applied gate is represented by the unitary matrix given by:</p> \\[ U3(\\theta, \\phi, \\lambda) = R_z(\\phi)R_y(\\theta)R_z(\\lambda) \\] <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation around Y axis (radians).</p> required <code>phi</code> <code>float</code> <p>Global phase shift component (radians).</p> required <code>lam</code> <code>float</code> <p>Z rotations in decomposition (radians).</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef u3(theta: float, phi: float, lam: float, qubits: ilist.IList[Qubit, Any]):\n    \"\"\"Apply the U3 gate to a group of qubits.\n\n    The applied gate is represented by the unitary matrix given by:\n\n    $$ U3(\\\\theta, \\\\phi, \\\\lambda) = R_z(\\\\phi)R_y(\\\\theta)R_z(\\\\lambda) $$\n\n    Args:\n        theta (float): Rotation around Y axis (radians).\n        phi (float): Global phase shift component (radians).\n        lam (float): Z rotations in decomposition (radians).\n        qubits (ilist.IList[qubit.Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.u3(_radian_to_turn(theta), _radian_to_turn(phi), _radian_to_turn(lam), qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.x","title":"x","text":"<pre><code>x(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a Pauli-X gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef x(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a Pauli-X gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.x(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.y","title":"y","text":"<pre><code>y(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a Pauli-Y gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef y(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a Pauli-Y gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.y(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/gate/#bloqade.squin.stdlib.broadcast.gate.z","title":"z","text":"<pre><code>z(qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a Pauli-Z gate to a group of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>qubits</code> <code>IList[Qubit, Any]</code> <p>Target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/gate.py</code> <pre><code>@kernel\ndef z(qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"Apply a Pauli-Z gate to a group of qubits.\n\n    Args:\n        qubits (ilist.IList[Qubit, Any]): Target qubits.\n    \"\"\"\n    gate.z(qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/","title":"Noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.bit_flip","title":"bit_flip","text":"<pre><code>bit_flip(p: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a bit flip error channel to the qubits in the given list with probability <code>p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Probability of a bit flip error being applied.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef bit_flip(p: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"\n    Apply a bit flip error channel to the qubits in the given list with probability `p`.\n\n    Args:\n        p (float): Probability of a bit flip error being applied.\n        qubits (IList[Qubit, Any]): The list of qubits to which the noise channel is applied.\n    \"\"\"\n    single_qubit_pauli_channel(p, 0, 0, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.correlated_qubit_loss","title":"correlated_qubit_loss","text":"<pre><code>correlated_qubit_loss(\n    p: float, qubits: IList[IList[Qubit, N], Any]\n) -&gt; None\n</code></pre> <p>Apply correlated qubit loss channels to groups of qubits.</p> <p>For each group of qubits, applies a correlated loss channel where all qubits within the group are lost together with probability <code>p</code>. Loss events are independent between different groups.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Loss probability for each group.</p> required <code>qubits</code> <code>IList[IList[Qubit, N], Any]</code> <p>List of qubit groups. Each sublist represents a group of qubits to which a correlated loss channel is applied.</p> required Example <p>q1 = squin.qalloc(3) # First group: qubits 0, 1, 2 q2 = squin.qalloc(3) # Second group: qubits 3, 4, 5 squin.broadcast.correlated_qubit_loss(0.5, [q1, q2])</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef correlated_qubit_loss(\n    p: float, qubits: ilist.IList[ilist.IList[Qubit, N], Any]\n) -&gt; None:\n    \"\"\"\n    Apply correlated qubit loss channels to groups of qubits.\n\n    For each group of qubits, applies a correlated loss channel where all qubits\n    within the group are lost together with probability `p`. Loss events are independent\n    between different groups.\n\n    Args:\n        p (float): Loss probability for each group.\n        qubits (IList[IList[Qubit, N], Any]): List of qubit groups. Each sublist\n            represents a group of qubits to which a correlated loss channel is applied.\n\n    Example:\n        &gt;&gt;&gt; q1 = squin.qalloc(3) # First group: qubits 0, 1, 2\n        &gt;&gt;&gt; q2 = squin.qalloc(3) # Second group: qubits 3, 4, 5\n        &gt;&gt;&gt; squin.broadcast.correlated_qubit_loss(0.5, [q1, q2])\n        # Each group has 50% chance: either all qubits lost or none lost.\n        # Group 1 and Group 2 outcomes are independent.\n    \"\"\"\n    noise.correlated_qubit_loss(p, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.correlated_qubit_loss--each-group-has-50-chance-either-all-qubits-lost-or-none-lost","title":"Each group has 50% chance: either all qubits lost or none lost.","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.correlated_qubit_loss--group-1-and-group-2-outcomes-are-independent","title":"Group 1 and Group 2 outcomes are independent.","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.depolarize","title":"depolarize","text":"<pre><code>depolarize(p: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a depolarizing noise channel to a list of qubits with probability <code>p</code>.</p> <p>For each qubit, this will randomly select one of the Pauli operators X, Y, Z with a probability <code>p / 3</code> and apply it to the qubit. No operator is applied with a probability of <code>1 - p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The probability with which a Pauli operator is applied.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef depolarize(p: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"\n    Apply a depolarizing noise channel to a list of qubits with probability `p`.\n\n    For each qubit, this will randomly select one of the Pauli operators X, Y, Z\n    with a probability `p / 3` and apply it to the qubit. No operator is applied\n    with a probability of `1 - p`.\n\n    Args:\n        p (float): The probability with which a Pauli operator is applied.\n        qubits (IList[Qubit, Any]): The list of qubits to which the noise channel is applied.\n    \"\"\"\n    noise.depolarize(p, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.depolarize2","title":"depolarize2","text":"<pre><code>depolarize2(\n    p: float,\n    controls: IList[Qubit, N],\n    targets: IList[Qubit, N],\n) -&gt; None\n</code></pre> <p>Symmetric two-qubit depolarization channel applied to a set of control and target qubits.</p> <p>For each pair of qubits from the <code>controls</code> and <code>targets</code> lists, this will randomly select one of the pauli products</p> <p><code>{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}</code></p> <p>each with a probability <code>p / 15</code>. No noise is applied with a probability of <code>1 - p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The probability with which a Pauli product is applied.</p> required <code>controls</code> <code>IList[Qubit, N]</code> <p>The list of control qubits.</p> required <code>targets</code> <code>IList[Qubit, N]</code> <p>The list of target qubits.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef depolarize2(\n    p: float, controls: ilist.IList[Qubit, N], targets: ilist.IList[Qubit, N]\n) -&gt; None:\n    \"\"\"\n    Symmetric two-qubit depolarization channel applied to a set of control and target qubits.\n\n    For each pair of qubits from the `controls` and `targets` lists, this will randomly select one\n    of the pauli products\n\n    `{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}`\n\n    each with a probability `p / 15`. No noise is applied with a probability of `1 - p`.\n\n    Args:\n        p (float): The probability with which a Pauli product is applied.\n        controls (IList[Qubit, N]): The list of control qubits.\n        targets (IList[Qubit, N]): The list of target qubits.\n    \"\"\"\n    noise.depolarize2(p, controls, targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.qubit_loss","title":"qubit_loss","text":"<pre><code>qubit_loss(p: float, qubits: IList[Qubit, Any]) -&gt; None\n</code></pre> <p>Apply a qubit loss channel to each of the qubits in the given list.</p> <p>Each qubit in the list is lost with a probability <code>p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Probability of the atom being lost.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef qubit_loss(p: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"\n    Apply a qubit loss channel to each of the qubits in the given list.\n\n    Each qubit in the list is lost with a probability `p`.\n\n    Args:\n        p (float): Probability of the atom being lost.\n        qubits (IList[Qubit, Any]): The list of qubits to which the noise channel is applied.\n    \"\"\"\n    noise.qubit_loss(p, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.single_qubit_pauli_channel","title":"single_qubit_pauli_channel","text":"<pre><code>single_qubit_pauli_channel(\n    px: float,\n    py: float,\n    pz: float,\n    qubits: IList[Qubit, Any],\n) -&gt; None\n</code></pre> <p>Apply a Pauli error channel with weighted <code>px, py, pz</code>. No error is applied with a probability <code>1 - (px + py + pz)</code>.</p> <p>This randomly selects one of the three Pauli operators X, Y, Z, weighted with the given probabilities in that order.</p> <p>Parameters:</p> Name Type Description Default <code>probabilities</code> <code>IList[float, Literal[3]]</code> <p>A list of 3 probabilities corresponding to the probabilities <code>(p_x, p_y, p_z)</code> in that order.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef single_qubit_pauli_channel(\n    px: float, py: float, pz: float, qubits: ilist.IList[Qubit, Any]\n) -&gt; None:\n    \"\"\"\n    Apply a Pauli error channel with weighted `px, py, pz`. No error is applied with a probability\n    `1 - (px + py + pz)`.\n\n    This randomly selects one of the three Pauli operators X, Y, Z, weighted with the given probabilities in that order.\n\n    Args:\n        probabilities (IList[float, Literal[3]]): A list of 3 probabilities corresponding to the probabilities `(p_x, p_y, p_z)` in that order.\n        qubits (IList[Qubit, Any]): The list of qubits to which the noise channel is applied.\n    \"\"\"\n    noise.single_qubit_pauli_channel(px, py, pz, qubits)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/broadcast/noise/#bloqade.squin.stdlib.broadcast.noise.two_qubit_pauli_channel","title":"two_qubit_pauli_channel","text":"<pre><code>two_qubit_pauli_channel(\n    probabilities: IList[float, Literal[15]],\n    controls: IList[Qubit, N],\n    targets: IList[Qubit, N],\n) -&gt; None\n</code></pre> <p>Apply a Pauli product error with weighted <code>probabilities</code> to the set of control and target qubits.</p> <p>No error is applied with the probability <code>1 - sum(probabilities)</code>.</p> <p>For each pair of qubits from the <code>controls</code> and <code>targets</code> lists, this will randomly select one of the pauli products</p> <p><code>{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}</code></p> <p>weighted with the corresponding list of probabilities.</p> <p>NOTE: The order of the given probabilities must match the order of the list of Pauli products above!</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/broadcast/noise.py</code> <pre><code>@kernel\ndef two_qubit_pauli_channel(\n    probabilities: ilist.IList[float, Literal[15]],\n    controls: ilist.IList[Qubit, N],\n    targets: ilist.IList[Qubit, N],\n) -&gt; None:\n    \"\"\"\n    Apply a Pauli product error with weighted `probabilities` to the set of control and target qubits.\n\n    No error is applied with the probability `1 - sum(probabilities)`.\n\n    For each pair of qubits from the `controls` and `targets` lists, this will randomly select one\n    of the pauli products\n\n    `{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}`\n\n    weighted with the corresponding list of probabilities.\n\n    **NOTE**: The order of the given probabilities must match the order of the list of Pauli products above!\n    \"\"\"\n    noise.two_qubit_pauli_channel(probabilities, controls, targets)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/","title":"Gate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.cx","title":"cx","text":"<pre><code>cx(control: Qubit, target: Qubit) -&gt; None\n</code></pre> <p>Apply a controlled-X gate to a pair of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>Qubit</code> <p>Control qubit.</p> required <code>targets</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef cx(control: Qubit, target: Qubit) -&gt; None:\n    \"\"\"Apply a controlled-X gate to a pair of qubits.\n\n    Args:\n        controls (Qubit): Control qubit.\n        targets (Qubit): Target qubit.\n    \"\"\"\n    broadcast.cx(ilist.IList([control]), ilist.IList([target]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.cy","title":"cy","text":"<pre><code>cy(control: Qubit, target: Qubit) -&gt; None\n</code></pre> <p>Apply a controlled-Y gate to a pair of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>Qubit</code> <p>Control qubit.</p> required <code>targets</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef cy(control: Qubit, target: Qubit) -&gt; None:\n    \"\"\"Apply a controlled-Y gate to a pair of qubits.\n\n    Args:\n        controls (Qubit): Control qubit.\n        targets (Qubit): Target qubit.\n    \"\"\"\n    broadcast.cy(ilist.IList([control]), ilist.IList([target]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.cz","title":"cz","text":"<pre><code>cz(control: Qubit, target: Qubit) -&gt; None\n</code></pre> <p>Apply a controlled-Z gate to a pair of qubits.</p> <p>Parameters:</p> Name Type Description Default <code>controls</code> <code>Qubit</code> <p>Control qubit.</p> required <code>targets</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef cz(control: Qubit, target: Qubit) -&gt; None:\n    \"\"\"Apply a controlled-Z gate to a pair of qubits.\n\n    Args:\n        controls (Qubit): Control qubit.\n        targets (Qubit): Target qubit.\n    \"\"\"\n    broadcast.cz(ilist.IList([control]), ilist.IList([target]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.h","title":"h","text":"<pre><code>h(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Hadamard gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef h(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Hadamard gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.h(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.rx","title":"rx","text":"<pre><code>rx(angle: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply an RX rotation gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef rx(angle: float, qubit: Qubit) -&gt; None:\n    \"\"\"Apply an RX rotation gate to a qubit.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.rx(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.ry","title":"ry","text":"<pre><code>ry(angle: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply an RY rotation gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef ry(angle: float, qubit: Qubit) -&gt; None:\n    \"\"\"Apply an RY rotation gate to a qubit.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.ry(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.rz","title":"rz","text":"<pre><code>rz(angle: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply an RZ rotation gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>Rotation angle in radians.</p> required <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef rz(angle: float, qubit: Qubit) -&gt; None:\n    \"\"\"Apply an RZ rotation gate to a qubit.\n\n    Args:\n        angle (float): Rotation angle in radians.\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.rz(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.s","title":"s","text":"<pre><code>s(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply an S gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef s(qubit: Qubit) -&gt; None:\n    \"\"\"Apply an S gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.s(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.s_adj","title":"s_adj","text":"<pre><code>s_adj(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply the adjoint of an S gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef s_adj(qubit: Qubit) -&gt; None:\n    \"\"\"Apply the adjoint of an S gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.s_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.shift","title":"shift","text":"<pre><code>shift(angle: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a phase shift to the |1&gt; state of a qubit. Args:     angle (float): Phase shift angle in radians.     qubit (Qubit): Target qubit.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef shift(angle: float, qubit: Qubit) -&gt; None:\n    \"\"\"Apply a phase shift to the |1&gt; state of a qubit.\n    Args:\n        angle (float): Phase shift angle in radians.\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.shift(angle, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.sqrt_x","title":"sqrt_x","text":"<pre><code>sqrt_x(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Sqrt(X) gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef sqrt_x(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Sqrt(X) gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.sqrt_x(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.sqrt_x_adj","title":"sqrt_x_adj","text":"<pre><code>sqrt_x_adj(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply the adjoint of a Sqrt(X) gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef sqrt_x_adj(qubit: Qubit) -&gt; None:\n    \"\"\"Apply the adjoint of a Sqrt(X) gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.sqrt_x_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.sqrt_y","title":"sqrt_y","text":"<pre><code>sqrt_y(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Sqrt(Y) gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef sqrt_y(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Sqrt(Y) gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.sqrt_y(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.sqrt_y_adj","title":"sqrt_y_adj","text":"<pre><code>sqrt_y_adj(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply the adjoint of a Sqrt(Y) gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef sqrt_y_adj(qubit: Qubit) -&gt; None:\n    \"\"\"Apply the adjoint of a Sqrt(Y) gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.sqrt_y_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.sqrt_z","title":"sqrt_z","text":"<pre><code>sqrt_z(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Sqrt(Z) gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef sqrt_z(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Sqrt(Z) gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.s(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.sqrt_z_adj","title":"sqrt_z_adj","text":"<pre><code>sqrt_z_adj(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply the adjoint of a Sqrt(Z) gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef sqrt_z_adj(qubit: Qubit) -&gt; None:\n    \"\"\"Apply the adjoint of a Sqrt(Z) gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.s_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.t","title":"t","text":"<pre><code>t(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a T gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef t(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a T gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.t(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.t_adj","title":"t_adj","text":"<pre><code>t_adj(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply the adjoint of a T gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef t_adj(qubit: Qubit) -&gt; None:\n    \"\"\"Apply the adjoint of a T gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.t_adj(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.u3","title":"u3","text":"<pre><code>u3(theta: float, phi: float, lam: float, qubit: Qubit)\n</code></pre> <p>Apply the U3 gate of a qubit.</p> <p>The applied gate is represented by the unitary matrix given by:</p> \\[ U3(\\theta, \\phi, \\lambda) = R_z(\\phi)R_y(\\theta)R_z(\\lambda) \\] <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>Rotation around Y axis (radians).</p> required <code>phi</code> <code>float</code> <p>Global phase shift component (radians).</p> required <code>lam</code> <code>float</code> <p>Z rotations in decomposition (radians).</p> required <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef u3(theta: float, phi: float, lam: float, qubit: Qubit):\n    \"\"\"Apply the U3 gate of a qubit.\n\n    The applied gate is represented by the unitary matrix given by:\n\n    $$ U3(\\\\theta, \\\\phi, \\\\lambda) = R_z(\\\\phi)R_y(\\\\theta)R_z(\\\\lambda) $$\n\n    Args:\n        theta (float): Rotation around Y axis (radians).\n        phi (float): Global phase shift component (radians).\n        lam (float): Z rotations in decomposition (radians).\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.u3(theta, phi, lam, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.x","title":"x","text":"<pre><code>x(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Pauli-X gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef x(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Pauli-X gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.x(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.y","title":"y","text":"<pre><code>y(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Pauli-Y gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef y(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Pauli-Y gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.y(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/gate/#bloqade.squin.stdlib.simple.gate.z","title":"z","text":"<pre><code>z(qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a Pauli-Z gate to a qubit.</p> <p>Parameters:</p> Name Type Description Default <code>qubit</code> <code>Qubit</code> <p>Target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/gate.py</code> <pre><code>@kernel\ndef z(qubit: Qubit) -&gt; None:\n    \"\"\"Apply a Pauli-Z gate to a qubit.\n\n    Args:\n        qubit (Qubit): Target qubit.\n    \"\"\"\n    broadcast.z(ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/","title":"Noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.bit_flip","title":"bit_flip","text":"<pre><code>bit_flip(p: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a bit flip error channel to the qubit with probability <code>p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Probability of a bit flip error being applied.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef bit_flip(p: float, qubit: Qubit) -&gt; None:\n    \"\"\"\n    Apply a bit flip error channel to the qubit with probability `p`.\n\n    Args:\n        p (float): Probability of a bit flip error being applied.\n        qubit (Qubit): The qubit to which the noise channel is applied.\n    \"\"\"\n    single_qubit_pauli_channel(p, 0, 0, qubit)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.correlated_qubit_loss","title":"correlated_qubit_loss","text":"<pre><code>correlated_qubit_loss(\n    p: float, qubits: IList[Qubit, Any]\n) -&gt; None\n</code></pre> <p>Apply a correlated qubit loss channel to the given qubits.</p> <p>All qubits are lost together with a probability <code>p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Probability of the qubits being lost.</p> required <code>qubits</code> <code>IList[Qubit, Any]</code> <p>The list of qubits to which the correlated noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef correlated_qubit_loss(p: float, qubits: ilist.IList[Qubit, Any]) -&gt; None:\n    \"\"\"\n    Apply a correlated qubit loss channel to the given qubits.\n\n    All qubits are lost together with a probability `p`.\n\n    Args:\n        p (float): Probability of the qubits being lost.\n        qubits (IList[Qubit, Any]): The list of qubits to which the correlated noise channel is applied.\n    \"\"\"\n    broadcast.correlated_qubit_loss(p, ilist.IList([qubits]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.depolarize","title":"depolarize","text":"<pre><code>depolarize(p: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a depolarizing noise channel to a qubit with probability <code>p</code>.</p> <p>This will randomly select one of the Pauli operators X, Y, Z with a probability <code>p / 3</code> and apply it to the qubit. No operator is applied with a probability of <code>1 - p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The probability with which a Pauli operator is applied.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef depolarize(p: float, qubit: Qubit) -&gt; None:\n    \"\"\"\n    Apply a depolarizing noise channel to a qubit with probability `p`.\n\n    This will randomly select one of the Pauli operators X, Y, Z\n    with a probability `p / 3` and apply it to the qubit. No operator is applied\n    with a probability of `1 - p`.\n\n    Args:\n        p (float): The probability with which a Pauli operator is applied.\n        qubit (Qubit): The qubit to which the noise channel is applied.\n    \"\"\"\n    broadcast.depolarize(p, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.depolarize2","title":"depolarize2","text":"<pre><code>depolarize2(\n    p: float, control: Qubit, target: Qubit\n) -&gt; None\n</code></pre> <p>Symmetric two-qubit depolarization channel applied to a pair of qubits.</p> <p>This will randomly select one of the pauli products</p> <p><code>{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}</code></p> <p>each with a probability <code>p / 15</code>. No noise is applied with a probability of <code>1 - p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>The probability with which a Pauli product is applied.</p> required <code>control</code> <code>Qubit</code> <p>The control qubit.</p> required <code>target</code> <code>Qubit</code> <p>The target qubit.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef depolarize2(p: float, control: Qubit, target: Qubit) -&gt; None:\n    \"\"\"\n    Symmetric two-qubit depolarization channel applied to a pair of qubits.\n\n    This will randomly select one of the pauli products\n\n    `{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}`\n\n    each with a probability `p / 15`. No noise is applied with a probability of `1 - p`.\n\n    Args:\n        p (float): The probability with which a Pauli product is applied.\n        control (Qubit): The control qubit.\n        target (Qubit): The target qubit.\n    \"\"\"\n    broadcast.depolarize2(p, ilist.IList([control]), ilist.IList([target]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.qubit_loss","title":"qubit_loss","text":"<pre><code>qubit_loss(p: float, qubit: Qubit) -&gt; None\n</code></pre> <p>Apply a qubit loss channel to the given qubit.</p> <p>The qubit is lost with a probability <code>p</code>.</p> <p>Parameters:</p> Name Type Description Default <code>p</code> <code>float</code> <p>Probability of the atom being lost.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef qubit_loss(p: float, qubit: Qubit) -&gt; None:\n    \"\"\"\n    Apply a qubit loss channel to the given qubit.\n\n    The qubit is lost with a probability `p`.\n\n    Args:\n        p (float): Probability of the atom being lost.\n        qubit (Qubit): The qubit to which the noise channel is applied.\n    \"\"\"\n    broadcast.qubit_loss(p, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.single_qubit_pauli_channel","title":"single_qubit_pauli_channel","text":"<pre><code>single_qubit_pauli_channel(\n    px: float, py: float, pz: float, qubit: Qubit\n) -&gt; None\n</code></pre> <p>Apply a Pauli error channel with weighted <code>px, py, pz</code>. No error is applied with a probability <code>1 - (px + py + pz)</code>.</p> <p>This randomly selects one of the three Pauli operators X, Y, Z, weighted with the given probabilities in that order.</p> <p>Parameters:</p> Name Type Description Default <code>probabilities</code> <code>IList[float, Literal[3]]</code> <p>A list of 3 probabilities corresponding to the probabilities <code>(p_x, p_y, p_z)</code> in that order.</p> required <code>qubit</code> <code>Qubit</code> <p>The qubit to which the noise channel is applied.</p> required Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef single_qubit_pauli_channel(px: float, py: float, pz: float, qubit: Qubit) -&gt; None:\n    \"\"\"\n    Apply a Pauli error channel with weighted `px, py, pz`. No error is applied with a probability\n    `1 - (px + py + pz)`.\n\n    This randomly selects one of the three Pauli operators X, Y, Z, weighted with the given probabilities in that order.\n\n    Args:\n        probabilities (IList[float, Literal[3]]): A list of 3 probabilities corresponding to the probabilities `(p_x, p_y, p_z)` in that order.\n        qubit (Qubit): The qubit to which the noise channel is applied.\n    \"\"\"\n    broadcast.single_qubit_pauli_channel(px, py, pz, ilist.IList([qubit]))\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/squin/stdlib/simple/noise/#bloqade.squin.stdlib.simple.noise.two_qubit_pauli_channel","title":"two_qubit_pauli_channel","text":"<pre><code>two_qubit_pauli_channel(\n    probabilities: IList[float, Literal[15]],\n    control: Qubit,\n    target: Qubit,\n) -&gt; None\n</code></pre> <p>Apply a Pauli product error with weighted <code>probabilities</code> to the pair of qubits.</p> <p>No error is applied with the probability <code>1 - sum(probabilities)</code>.</p> <p>This will randomly select one of the pauli products</p> <p><code>{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}</code></p> <p>weighted with the corresponding list of probabilities.</p> <p>NOTE: The order of the given probabilities must match the order of the list of Pauli products above!</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/squin/stdlib/simple/noise.py</code> <pre><code>@kernel\ndef two_qubit_pauli_channel(\n    probabilities: ilist.IList[float, Literal[15]], control: Qubit, target: Qubit\n) -&gt; None:\n    \"\"\"\n    Apply a Pauli product error with weighted `probabilities` to the pair of qubits.\n\n    No error is applied with the probability `1 - sum(probabilities)`.\n\n    This will randomly select one of the pauli products\n\n    `{IX, IY, IZ, XI, XX, XY, XZ, YI, YX, YY, YZ, ZI, ZX, ZY, ZZ}`\n\n    weighted with the corresponding list of probabilities.\n\n    **NOTE**: The order of the given probabilities must match the order of the list of Pauli products above!\n    \"\"\"\n    broadcast.two_qubit_pauli_channel(\n        probabilities, ilist.IList([control]), ilist.IList([target])\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/groups/","title":"Groups","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/emit/","title":"Emit","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/interp/","title":"Interp","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/types/","title":"Types","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/annotate/","title":"Annotate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/","title":"Const","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.auxiliary.stmts.const.ConstBool[ConstBool]\n\n              \n\n              click bloqade.stim.dialects.auxiliary.stmts.const.ConstBool href \"\" \"bloqade.stim.dialects.auxiliary.stmts.const.ConstBool\"\n            </code></pre> <p>IR Statement representing a constant boolean value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.auxiliary.stmts.const.ConstFloat[ConstFloat]\n\n              \n\n              click bloqade.stim.dialects.auxiliary.stmts.const.ConstFloat href \"\" \"bloqade.stim.dialects.auxiliary.stmts.const.ConstFloat\"\n            </code></pre> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.auxiliary.stmts.const.ConstInt[ConstInt]\n\n              \n\n              click bloqade.stim.dialects.auxiliary.stmts.const.ConstInt href \"\" \"bloqade.stim.dialects.auxiliary.stmts.const.ConstInt\"\n            </code></pre> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.auxiliary.stmts.const.ConstStr[ConstStr]\n\n              \n\n              click bloqade.stim.dialects.auxiliary.stmts.const.ConstStr href \"\" \"bloqade.stim.dialects.auxiliary.stmts.const.ConstStr\"\n            </code></pre> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/auxiliary/stmts/const/#bloqade.stim.dialects.auxiliary.stmts.const.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.auxiliary.stmts.const.Neg[Neg]\n\n              \n\n              click bloqade.stim.dialects.auxiliary.stmts.const.Neg href \"\" \"bloqade.stim.dialects.auxiliary.stmts.const.Neg\"\n            </code></pre> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/emit_str/","title":"Emit str","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/measure/","title":"Measure","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/measure/#bloqade.stim.dialects.collapse.stmts.measure.Measurement","title":"Measurement","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.collapse.stmts.measure.Measurement[Measurement]\n\n              \n\n              click bloqade.stim.dialects.collapse.stmts.measure.Measurement href \"\" \"bloqade.stim.dialects.collapse.stmts.measure.Measurement\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/measure/#bloqade.stim.dialects.collapse.stmts.measure.Measurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/pp_measure/","title":"Pp measure","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/pp_measure/#bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement[PPMeasurement]\n\n              \n\n              click bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement href \"\" \"bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/pp_measure/#bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/collapse/stmts/reset/","title":"Reset","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/emit/","title":"Emit","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/stmts/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/stmts/base/","title":"Base","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/stmts/clifford_1q/","title":"Clifford 1q","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/stmts/clifford_2q/","title":"Clifford 2q","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/stmts/control_2q/","title":"Control 2q","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/gate/stmts/pp/","title":"Pp","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/noise/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/noise/emit/","title":"Emit","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/dialects/noise/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/emit/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/emit/impls/","title":"Impls","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/emit/stim_str/","title":"Stim str","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/parse/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/parse/lowering/","title":"Lowering","text":"<p>One-to-one lowering routine from stim circuit to a stim-dialect kirin kernel.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/parse/lowering/#bloqade.stim.parse.lowering.loads","title":"loads","text":"<pre><code>loads(\n    stim_str: str,\n    *,\n    kernel_name: str = \"main\",\n    ignore_unknown_stim: bool = False,\n    error_unknown_nonstim: bool = False,\n    nonstim_noise_ops: dict[str, type[Statement]] = {},\n    dialects: DialectGroup | None = None,\n    globals: dict[str, Any] | None = None,\n    file: str | None = None,\n    lineno_offset: int = 0,\n    col_offset: int = 0,\n    compactify: bool = True\n) -&gt; ir.Method[[], None]\n</code></pre> <p>Loads a STIM string and returns the corresponding kernel object.</p> <p>Parameters:</p> Name Type Description Default <code>stim_str</code> <code>str</code> <p>The string representation of a STIM circuit to load.</p> required <p>Other Parameters:</p> Name Type Description <code>kernel_name</code> <code>str</code> <p>The name of the kernel to load. Defaults to \"main\".</p> <code>ignore_unknown_stim</code> <code>bool</code> <p>If True, don't throw a build error on an unimplemented stim instruction.</p> <code>error_unknown_nonstim</code> <code>bool</code> <p>If True, throw a build error if an unknown tag is used on the <code>I_ERROR</code> instruction.</p> <code>nonstim_noise_ops</code> <code>dict[str, Statement]</code> <p>Additional statements to represent non-standard stim operations.  The dictionary key should match the tag used to identify it in stim (stim format <code>I_ERROR[MY_NOISE](0.05) 0 1 2 3</code> or <code>I_ERROR[MY_CORRELATED_NOISE:2417696374](0.03) 1 3 5</code>).</p> <code>dialects</code> <code>DialectGroup | None</code> <p>The dialects to use. Defaults to <code>stim.main</code>.</p> <code>globals</code> <code>dict[str, Any] | None</code> <p>The global variables to use. Defaults to None.</p> <code>file</code> <code>str | None</code> <p>The file name for error reporting. Defaults to None.</p> <code>lineno_offset</code> <code>int</code> <p>The line number offset for error reporting. Defaults to 0.</p> <code>col_offset</code> <code>int</code> <p>The column number offset for error reporting. Defaults to 0.</p> <code>compactify</code> <code>bool</code> <p>Whether to compactify the output. Defaults to True.</p> <p>Example:</p> <pre><code>from bloqade.stim.lowering import loads\nmethod = loads('''\n    X 0 2 4\n    DEPOLARIZE1(0.01) 0\n    I_ERROR[CUSTOM_ERROR](0.02) 2 4\n    M 0 2 4\n    DETECTOR rec[-1] rec[-2]\n''')\n</code></pre> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/parse/lowering.py</code> <pre><code>def loads(\n    stim_str: str,\n    *,\n    kernel_name: str = \"main\",\n    ignore_unknown_stim: bool = False,\n    error_unknown_nonstim: bool = False,\n    nonstim_noise_ops: dict[str, type[kirin.ir.Statement]] = {},\n    dialects: ir.DialectGroup | None = None,\n    globals: dict[str, Any] | None = None,\n    file: str | None = None,\n    lineno_offset: int = 0,\n    col_offset: int = 0,\n    compactify: bool = True,\n) -&gt; ir.Method[[], None]:\n    \"\"\"Loads a STIM string and returns the corresponding kernel object.\n\n    Args:\n        stim_str: The string representation of a STIM circuit to load.\n\n    Keyword Args:\n        kernel_name (str): The name of the kernel to load. Defaults to \"main\".\n        ignore_unknown_stim (bool): If True, don't throw a build error on an\n            unimplemented stim instruction.\n        error_unknown_nonstim (bool): If True, throw a build error if an unknown tag is\n            used on the `I_ERROR` instruction.\n        nonstim_noise_ops (dict[str, kirin.ir.Statement]): Additional statements to\n            represent non-standard stim operations.  The dictionary key should match the\n            tag used to identify it in stim (stim format\n            `I_ERROR[MY_NOISE](0.05) 0 1 2 3` or\n            `I_ERROR[MY_CORRELATED_NOISE:2417696374](0.03) 1 3 5`).\n        dialects (ir.DialectGroup | None): The dialects to use. Defaults to `stim.main`.\n        globals (dict[str, Any] | None): The global variables to use. Defaults to None.\n        file (str | None): The file name for error reporting. Defaults to None.\n        lineno_offset (int): The line number offset for error reporting. Defaults to 0.\n        col_offset (int): The column number offset for error reporting. Defaults to 0.\n        compactify (bool): Whether to compactify the output. Defaults to True.\n\n    Example:\n\n    ```python\n    from bloqade.stim.lowering import loads\n    method = loads('''\n        X 0 2 4\n        DEPOLARIZE1(0.01) 0\n        I_ERROR[CUSTOM_ERROR](0.02) 2 4\n        M 0 2 4\n        DETECTOR rec[-1] rec[-2]\n    ''')\n    ```\n    \"\"\"\n    import stim  # Optional dependency required to lower stim circuits\n\n    circ = stim.Circuit(stim_str)\n    stim_lowering = Stim(\n        kstim.main if dialects is None else dialects,\n        ignore_unknown_stim=ignore_unknown_stim,\n        error_unknown_nonstim=error_unknown_nonstim,\n        nonstim_noise_ops=nonstim_noise_ops,\n    )\n    frame = stim_lowering.get_frame(\n        circ,\n        source=stim_str,\n        file=file,\n        globals=globals,\n        lineno_offset=lineno_offset,\n        col_offset=col_offset,\n        compactify=compactify,\n    )\n\n    return_value = func.ConstantNone()  # No return value\n    frame.push(return_value)\n    return_node = frame.push(func.Return(value_or_stmt=return_value))\n\n    body = frame.curr_region\n    code = func.Function(\n        sym_name=kernel_name,\n        signature=func.Signature((), return_node.value.type),\n        body=body,\n    )\n    self_arg = ir.BlockArgument(body.blocks[0], 0)  # Self argument\n    body.blocks[0]._args = (self_arg,)\n    return ir.Method(\n        mod=None,\n        py_func=None,\n        sym_name=kernel_name,\n        arg_names=[],\n        dialects=kstim.dialects,\n        code=code,\n    )\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/passes/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/passes/flatten/","title":"Flatten","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/passes/simplify_ifs/","title":"Simplify ifs","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/passes/squin_to_stim/","title":"Squin to stim","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/get_record_util/","title":"Get record util","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/get_record_util/#bloqade.stim.rewrite.get_record_util.insert_get_records","title":"insert_get_records","text":"<pre><code>insert_get_records(\n    node: Statement,\n    measure_id_tuple: MeasureIdTuple,\n    meas_count_at_stmt: int,\n)\n</code></pre> <p>Insert GetRecord statements before the given node</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/get_record_util.py</code> <pre><code>def insert_get_records(\n    node: ir.Statement, measure_id_tuple: MeasureIdTuple, meas_count_at_stmt: int\n):\n    \"\"\"\n    Insert GetRecord statements before the given node\n    \"\"\"\n    get_record_ssas = []\n    for measure_id_bool in measure_id_tuple.data:\n        assert isinstance(measure_id_bool, MeasureIdBool)\n        target_rec_idx = (measure_id_bool.idx - 1) - meas_count_at_stmt\n        idx_stmt = py.constant.Constant(target_rec_idx)\n        idx_stmt.insert_before(node)\n        get_record_stmt = auxiliary.GetRecord(idx_stmt.result)\n        get_record_stmt.insert_before(node)\n        get_record_ssas.append(get_record_stmt.result)\n\n    return get_record_ssas\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/","title":"Ifs to stim","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/#bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification","title":"IfElseSimplification  <code>dataclass</code>","text":"<pre><code>IfElseSimplification()\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/#bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification.contains_ifelse","title":"contains_ifelse","text":"<pre><code>contains_ifelse(stmt: IfElse) -&gt; bool\n</code></pre> <p>Check if the IfElse statement contains another IfElse statement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/ifs_to_stim.py</code> <pre><code>def contains_ifelse(self, stmt: scf.IfElse) -&gt; bool:\n    \"\"\"Check if the IfElse statement contains another IfElse statement.\"\"\"\n    for child in stmt.walk(include_self=False):\n        if isinstance(child, scf.IfElse):\n            return True\n    return False\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/#bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification.has_else_body","title":"has_else_body","text":"<pre><code>has_else_body(stmt: IfElse) -&gt; bool\n</code></pre> <p>Check if the IfElse statement has an else body.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/ifs_to_stim.py</code> <pre><code>def has_else_body(self, stmt: scf.IfElse) -&gt; bool:\n    \"\"\"Check if the IfElse statement has an else body.\"\"\"\n    if stmt.else_body.blocks and not (\n        len(stmt.else_body.blocks[0].stmts) == 1\n        and isinstance(stmt.else_body.blocks[0].last_stmt, scf.Yield)\n    ):\n        return True\n\n    return False\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/#bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification.is_nested_ifelse","title":"is_nested_ifelse","text":"<pre><code>is_nested_ifelse(stmt: IfElse) -&gt; bool\n</code></pre> <p>Check if the IfElse statement is nested.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/ifs_to_stim.py</code> <pre><code>def is_nested_ifelse(self, stmt: scf.IfElse) -&gt; bool:\n    \"\"\"Check if the IfElse statement is nested.\"\"\"\n    if stmt.parent_stmt is not None:\n        if isinstance(stmt.parent_stmt, scf.IfElse) or isinstance(\n            stmt.parent_stmt.parent_stmt, scf.IfElse\n        ):\n            return True\n        else:\n            return False\n    else:\n        return False\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/#bloqade.stim.rewrite.ifs_to_stim.IfToStim","title":"IfToStim  <code>dataclass</code>","text":"<pre><code>IfToStim(measure_frame: MeasureIDFrame)\n</code></pre> <p>               Bases: <code>IfElseSimplification</code>, <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.ifs_to_stim.IfToStim[IfToStim]\n              bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification[IfElseSimplification]\n\n                              bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification --&gt; bloqade.stim.rewrite.ifs_to_stim.IfToStim\n                \n\n\n              click bloqade.stim.rewrite.ifs_to_stim.IfToStim href \"\" \"bloqade.stim.rewrite.ifs_to_stim.IfToStim\"\n              click bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification href \"\" \"bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification\"\n            </code></pre> <p>Rewrite if statements to stim equivalent statements.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/ifs_to_stim/#bloqade.stim.rewrite.ifs_to_stim.StimSplitIfStmts","title":"StimSplitIfStmts  <code>dataclass</code>","text":"<pre><code>StimSplitIfStmts()\n</code></pre> <p>               Bases: <code>IfElseSimplification</code>, <code>SplitIfStmts</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.ifs_to_stim.StimSplitIfStmts[StimSplitIfStmts]\n              bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification[IfElseSimplification]\n              bloqade.rewrite.rules.split_ifs.SplitIfStmts[SplitIfStmts]\n\n                              bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification --&gt; bloqade.stim.rewrite.ifs_to_stim.StimSplitIfStmts\n                \n                bloqade.rewrite.rules.split_ifs.SplitIfStmts --&gt; bloqade.stim.rewrite.ifs_to_stim.StimSplitIfStmts\n                \n\n\n              click bloqade.stim.rewrite.ifs_to_stim.StimSplitIfStmts href \"\" \"bloqade.stim.rewrite.ifs_to_stim.StimSplitIfStmts\"\n              click bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification href \"\" \"bloqade.stim.rewrite.ifs_to_stim.IfElseSimplification\"\n              click bloqade.rewrite.rules.split_ifs.SplitIfStmts href \"\" \"bloqade.rewrite.rules.split_ifs.SplitIfStmts\"\n            </code></pre> <p>Splits the then body of an if-else statement into multiple if statements</p> <p>Given an IfElse with multiple valid statements in the then-body:</p> if measure_result <p>squin.x(q0) squin.y(q1)</p> <p>this should be rewritten to:</p> if measure_result <p>squin.x(q0)</p> if measure_result <p>squin.y(q1)</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/py_constant_to_stim/","title":"Py constant to stim","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/qubit_to_stim/","title":"Qubit to stim","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/qubit_to_stim/#bloqade.stim.rewrite.qubit_to_stim.SquinQubitToStim","title":"SquinQubitToStim","text":"<p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.qubit_to_stim.SquinQubitToStim[SquinQubitToStim]\n\n              \n\n              click bloqade.stim.rewrite.qubit_to_stim.SquinQubitToStim href \"\" \"bloqade.stim.rewrite.qubit_to_stim.SquinQubitToStim\"\n            </code></pre> <p>NOTE this require address analysis result to be wrapped before using this rule.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/qubit_to_stim/#bloqade.stim.rewrite.qubit_to_stim.SquinQubitToStim.rewrite_ControlledGate","title":"rewrite_ControlledGate","text":"<pre><code>rewrite_ControlledGate(\n    stmt: ControlledGate,\n) -&gt; RewriteResult\n</code></pre> <p>Rewrite controlled gate nodes to their stim equivalent statements. Address Analysis should have been run along with Wrap Analysis before this rewrite is applied.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/qubit_to_stim.py</code> <pre><code>def rewrite_ControlledGate(self, stmt: gate.stmts.ControlledGate) -&gt; RewriteResult:\n    \"\"\"\n    Rewrite controlled gate nodes to their stim equivalent statements.\n    Address Analysis should have been run along with Wrap Analysis before this rewrite is applied.\n    \"\"\"\n\n    controls_addr_attr = stmt.controls.hints.get(\"address\", None)\n    targets_addr_attr = stmt.targets.hints.get(\"address\", None)\n\n    if controls_addr_attr is None or targets_addr_attr is None:\n        return RewriteResult()\n\n    assert isinstance(controls_addr_attr, AddressAttribute)\n    assert isinstance(targets_addr_attr, AddressAttribute)\n\n    controls_idx_ssas = insert_qubit_idx_from_address(\n        address=controls_addr_attr, stmt_to_insert_before=stmt\n    )\n    targets_idx_ssas = insert_qubit_idx_from_address(\n        address=targets_addr_attr, stmt_to_insert_before=stmt\n    )\n\n    if controls_idx_ssas is None or targets_idx_ssas is None:\n        return RewriteResult()\n\n    # Get the name of the inputted stmt and see if there is an\n    # equivalently named statement in stim,\n    # then create an instance of that stim statement\n    stmt_name = type(stmt).__name__\n    stim_stmt_cls = getattr(stim_gate.stmts, stmt_name, None)\n    if stim_stmt_cls is None:\n        return RewriteResult()\n\n    stim_stmt = stim_stmt_cls(\n        targets=tuple(targets_idx_ssas), controls=tuple(controls_idx_ssas)\n    )\n    stmt.replace_by(stim_stmt)\n\n    return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/qubit_to_stim/#bloqade.stim.rewrite.qubit_to_stim.SquinQubitToStim.rewrite_SingleQubitGate","title":"rewrite_SingleQubitGate","text":"<pre><code>rewrite_SingleQubitGate(\n    stmt: SingleQubitGate,\n) -&gt; RewriteResult\n</code></pre> <p>Rewrite single qubit gate nodes to their stim equivalent statements. Address Analysis should have been run along with Wrap Analysis before this rewrite is applied.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/qubit_to_stim.py</code> <pre><code>def rewrite_SingleQubitGate(\n    self, stmt: gate.stmts.SingleQubitGate\n) -&gt; RewriteResult:\n    \"\"\"\n    Rewrite single qubit gate nodes to their stim equivalent statements.\n    Address Analysis should have been run along with Wrap Analysis before this rewrite is applied.\n    \"\"\"\n\n    qubit_addr_attr = stmt.qubits.hints.get(\"address\", None)\n    if qubit_addr_attr is None:\n        return RewriteResult()\n\n    assert isinstance(qubit_addr_attr, AddressAttribute)\n\n    qubit_idx_ssas = insert_qubit_idx_from_address(\n        address=qubit_addr_attr, stmt_to_insert_before=stmt\n    )\n\n    if qubit_idx_ssas is None:\n        return RewriteResult()\n\n    # Get the name of the inputted stmt and see if there is an\n    # equivalently named statement in stim,\n    # then create an instance of that stim statement\n    stmt_name = type(stmt).__name__\n    stim_stmt_cls = getattr(stim_gate.stmts, stmt_name, None)\n    if stim_stmt_cls is None:\n        return RewriteResult()\n\n    if isinstance(stmt, gate.stmts.SingleQubitNonHermitianGate):\n        stim_stmt = stim_stmt_cls(\n            targets=tuple(qubit_idx_ssas), dagger=stmt.adjoint\n        )\n    else:\n        stim_stmt = stim_stmt_cls(targets=tuple(qubit_idx_ssas))\n    stmt.replace_by(stim_stmt)\n\n    return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/set_detector_to_stim/","title":"Set detector to stim","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/set_detector_to_stim/#bloqade.stim.rewrite.set_detector_to_stim.SetDetectorToStim","title":"SetDetectorToStim  <code>dataclass</code>","text":"<pre><code>SetDetectorToStim(measure_id_frame: MeasureIDFrame)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.set_detector_to_stim.SetDetectorToStim[SetDetectorToStim]\n\n              \n\n              click bloqade.stim.rewrite.set_detector_to_stim.SetDetectorToStim href \"\" \"bloqade.stim.rewrite.set_detector_to_stim.SetDetectorToStim\"\n            </code></pre> <p>Rewrite SetDetector to GetRecord and Detector in the stim dialect</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/set_observable_to_stim/","title":"Set observable to stim","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/set_observable_to_stim/#bloqade.stim.rewrite.set_observable_to_stim.SetObservableToStim","title":"SetObservableToStim  <code>dataclass</code>","text":"<pre><code>SetObservableToStim(measure_id_frame: MeasureIDFrame)\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.set_observable_to_stim.SetObservableToStim[SetObservableToStim]\n\n              \n\n              click bloqade.stim.rewrite.set_observable_to_stim.SetObservableToStim href \"\" \"bloqade.stim.rewrite.set_observable_to_stim.SetObservableToStim\"\n            </code></pre> <p>Rewrite SetObservable to GetRecord and ObservableInclude in the stim dialect</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_measure/","title":"Squin measure","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_measure/#bloqade.stim.rewrite.squin_measure.SquinMeasureToStim","title":"SquinMeasureToStim  <code>dataclass</code>","text":"<pre><code>SquinMeasureToStim()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.squin_measure.SquinMeasureToStim[SquinMeasureToStim]\n\n              \n\n              click bloqade.stim.rewrite.squin_measure.SquinMeasureToStim href \"\" \"bloqade.stim.rewrite.squin_measure.SquinMeasureToStim\"\n            </code></pre> <p>Rewrite squin measure-related statements to stim statements.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_measure/#bloqade.stim.rewrite.squin_measure.SquinMeasureToStim.get_qubit_idx_ssas","title":"get_qubit_idx_ssas","text":"<pre><code>get_qubit_idx_ssas(\n    measure_stmt: Measure,\n) -&gt; tuple[ir.SSAValue, ...] | None\n</code></pre> <p>Extract the address attribute and insert qubit indices for the given measure statement.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_measure.py</code> <pre><code>def get_qubit_idx_ssas(\n    self, measure_stmt: qubit.stmts.Measure\n) -&gt; tuple[ir.SSAValue, ...] | None:\n    \"\"\"\n    Extract the address attribute and insert qubit indices for the given measure statement.\n    \"\"\"\n    address_attr = measure_stmt.qubits.hints.get(\"address\")\n    if address_attr is None:\n        return None\n\n    assert isinstance(address_attr, AddressAttribute)\n\n    qubit_idx_ssas = insert_qubit_idx_from_address(\n        address=address_attr, stmt_to_insert_before=measure_stmt\n    )\n\n    return qubit_idx_ssas\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/","title":"Squin noise","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim","title":"SquinNoiseToStim  <code>dataclass</code>","text":"<pre><code>SquinNoiseToStim()\n</code></pre> <p>               Bases: <code>RewriteRule</code></p> <pre><code>\n              flowchart TD\n              bloqade.stim.rewrite.squin_noise.SquinNoiseToStim[SquinNoiseToStim]\n\n              \n\n              click bloqade.stim.rewrite.squin_noise.SquinNoiseToStim href \"\" \"bloqade.stim.rewrite.squin_noise.SquinNoiseToStim\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_CorrelatedQubitLoss","title":"rewrite_CorrelatedQubitLoss","text":"<pre><code>rewrite_CorrelatedQubitLoss(\n    stmt: CorrelatedQubitLoss,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement\n</code></pre> <p>Rewrite squin.noise.CorrelatedQubitLoss to stim.CorrelatedQubitLoss.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_CorrelatedQubitLoss(\n    self,\n    stmt: squin_noise.stmts.CorrelatedQubitLoss,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement:\n    \"\"\"Rewrite squin.noise.CorrelatedQubitLoss to stim.CorrelatedQubitLoss.\"\"\"\n    stim_stmt = stim_noise.CorrelatedQubitLoss(\n        targets=qubit_idx_ssas,\n        probs=(stmt.p,),\n    )\n\n    return stim_stmt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_Depolarize","title":"rewrite_Depolarize","text":"<pre><code>rewrite_Depolarize(\n    stmt: Depolarize, qubit_idx_ssas: Tuple[SSAValue]\n) -&gt; Statement\n</code></pre> <p>Rewrite squin.noise.Depolarize to stim.Depolarize1.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_Depolarize(\n    self,\n    stmt: squin_noise.stmts.Depolarize,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement:\n    \"\"\"Rewrite squin.noise.Depolarize to stim.Depolarize1.\"\"\"\n\n    stim_stmt = stim_noise.Depolarize1(\n        targets=qubit_idx_ssas,\n        p=stmt.p,\n    )\n\n    return stim_stmt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_Depolarize2","title":"rewrite_Depolarize2","text":"<pre><code>rewrite_Depolarize2(\n    stmt: Depolarize2, qubit_idx_ssas: Tuple[SSAValue]\n) -&gt; Statement\n</code></pre> <p>Rewrite squin.noise.Depolarize2 to stim.Depolarize2.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_Depolarize2(\n    self,\n    stmt: squin_noise.stmts.Depolarize2,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement:\n    \"\"\"Rewrite squin.noise.Depolarize2 to stim.Depolarize2.\"\"\"\n\n    stim_stmt = stim_noise.Depolarize2(targets=qubit_idx_ssas, p=stmt.p)\n    return stim_stmt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_NoiseChannel","title":"rewrite_NoiseChannel","text":"<pre><code>rewrite_NoiseChannel(stmt: NoiseChannel) -&gt; RewriteResult\n</code></pre> <p>Rewrite NoiseChannel statements to their stim equivalents.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_NoiseChannel(\n    self, stmt: squin_noise.stmts.NoiseChannel\n) -&gt; RewriteResult:\n    \"\"\"Rewrite NoiseChannel statements to their stim equivalents.\"\"\"\n\n    rewrite_method = getattr(self, f\"rewrite_{type(stmt).__name__}\", None)\n\n    # No rewrite method exists and the rewrite should stop\n    if rewrite_method is None:\n        return RewriteResult()\n    if isinstance(stmt, squin_noise.stmts.CorrelatedQubitLoss):\n        # CorrelatedQubitLoss represents a broadcast operation, but Stim does not\n        # support broadcasting for multi-qubit noise channels.\n        # Therefore, we must expand the broadcast into individual stim statements.\n        qubit_address_attr = stmt.qubits.hints.get(\"address\", None)\n\n        if not isinstance(qubit_address_attr, AddressAttribute):\n            return RewriteResult()\n\n        if not isinstance(address := qubit_address_attr.address, PartialIList):\n            return RewriteResult()\n\n        if not types.is_tuple_of(data := address.data, AddressReg):\n            return RewriteResult()\n\n        for address_reg in data:\n\n            qubit_idx_ssas = insert_qubit_idx_from_address(\n                AddressAttribute(address_reg), stmt\n            )\n\n            stim_stmt = rewrite_method(stmt, qubit_idx_ssas)\n            stim_stmt.insert_before(stmt)\n\n        stmt.delete()\n\n        return RewriteResult(has_done_something=True)\n\n    if isinstance(stmt, squin_noise.stmts.SingleQubitNoiseChannel):\n        qubit_address_attr = stmt.qubits.hints.get(\"address\", None)\n        if qubit_address_attr is None:\n            return RewriteResult()\n        qubit_idx_ssas = insert_qubit_idx_from_address(qubit_address_attr, stmt)\n\n    elif isinstance(stmt, squin_noise.stmts.TwoQubitNoiseChannel):\n        control_address_attr = stmt.controls.hints.get(\"address\", None)\n        target_address_attr = stmt.targets.hints.get(\"address\", None)\n        if control_address_attr is None or target_address_attr is None:\n            return RewriteResult()\n        control_qubit_idx_ssas = insert_qubit_idx_from_address(\n            control_address_attr, stmt\n        )\n        target_qubit_idx_ssas = insert_qubit_idx_from_address(\n            target_address_attr, stmt\n        )\n        if control_qubit_idx_ssas is None or target_qubit_idx_ssas is None:\n            return RewriteResult()\n\n        # For stim statements you want to interleave the control and target qubit indices:\n        # ex: CX controls = (0,1) targets = (2,3) in stim is: CX 0 2 1 3\n        qubit_idx_ssas = list(\n            itertools.chain.from_iterable(\n                zip(control_qubit_idx_ssas, target_qubit_idx_ssas)\n            )\n        )\n    else:\n        return RewriteResult()\n\n    # guaranteed that you have a valid stim_stmt to plug in\n    stim_stmt = rewrite_method(stmt, tuple(qubit_idx_ssas))\n    stmt.replace_by(stim_stmt)\n\n    return RewriteResult(has_done_something=True)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_QubitLoss","title":"rewrite_QubitLoss","text":"<pre><code>rewrite_QubitLoss(\n    stmt: QubitLoss, qubit_idx_ssas: Tuple[SSAValue]\n) -&gt; Statement\n</code></pre> <p>Rewrite squin.noise.QubitLoss to stim.TrivialError.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_QubitLoss(\n    self,\n    stmt: squin_noise.stmts.QubitLoss,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement:\n    \"\"\"Rewrite squin.noise.QubitLoss to stim.TrivialError.\"\"\"\n\n    stim_stmt = stim_noise.QubitLoss(\n        targets=qubit_idx_ssas,\n        probs=(stmt.p,),\n    )\n\n    return stim_stmt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_SingleQubitPauliChannel","title":"rewrite_SingleQubitPauliChannel","text":"<pre><code>rewrite_SingleQubitPauliChannel(\n    stmt: SingleQubitPauliChannel,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement\n</code></pre> <p>Rewrite squin.noise.SingleQubitPauliChannel to stim.PauliChannel1.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_SingleQubitPauliChannel(\n    self,\n    stmt: squin_noise.stmts.SingleQubitPauliChannel,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement:\n    \"\"\"Rewrite squin.noise.SingleQubitPauliChannel to stim.PauliChannel1.\"\"\"\n\n    stim_stmt = stim_noise.PauliChannel1(\n        targets=qubit_idx_ssas,\n        px=stmt.px,\n        py=stmt.py,\n        pz=stmt.pz,\n    )\n    return stim_stmt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/squin_noise/#bloqade.stim.rewrite.squin_noise.SquinNoiseToStim.rewrite_TwoQubitPauliChannel","title":"rewrite_TwoQubitPauliChannel","text":"<pre><code>rewrite_TwoQubitPauliChannel(\n    stmt: TwoQubitPauliChannel,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement\n</code></pre> <p>Rewrite squin.noise.TwoQubitPauliChannel to stim.PauliChannel2.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/squin_noise.py</code> <pre><code>def rewrite_TwoQubitPauliChannel(\n    self,\n    stmt: squin_noise.stmts.TwoQubitPauliChannel,\n    qubit_idx_ssas: Tuple[SSAValue],\n) -&gt; Statement:\n    \"\"\"Rewrite squin.noise.TwoQubitPauliChannel to stim.PauliChannel2.\"\"\"\n\n    params = stmt.probabilities\n    prob_ssas = []\n    for idx in range(15):\n        idx_stmt = py.Constant(value=idx)\n        idx_stmt.insert_before(stmt)\n        getitem_stmt = py.GetItem(obj=params, index=idx_stmt.result)\n        getitem_stmt.insert_before(stmt)\n        prob_ssas.append(getitem_stmt.result)\n\n    stim_stmt = stim_noise.PauliChannel2(\n        targets=qubit_idx_ssas,\n        pix=prob_ssas[0],\n        piy=prob_ssas[1],\n        piz=prob_ssas[2],\n        pxi=prob_ssas[3],\n        pxx=prob_ssas[4],\n        pxy=prob_ssas[5],\n        pxz=prob_ssas[6],\n        pyi=prob_ssas[7],\n        pyx=prob_ssas[8],\n        pyy=prob_ssas[9],\n        pyz=prob_ssas[10],\n        pzi=prob_ssas[11],\n        pzx=prob_ssas[12],\n        pzy=prob_ssas[13],\n        pzz=prob_ssas[14],\n    )\n    return stim_stmt\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/util/","title":"Util","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/rewrite/util/#bloqade.stim.rewrite.util.insert_qubit_idx_from_address","title":"insert_qubit_idx_from_address","text":"<pre><code>insert_qubit_idx_from_address(\n    address: AddressAttribute,\n    stmt_to_insert_before: Statement,\n) -&gt; tuple[ir.SSAValue, ...] | None\n</code></pre> <p>Extract qubit indices from an AddressAttribute and insert them into the SSA form.</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/stim/rewrite/util.py</code> <pre><code>def insert_qubit_idx_from_address(\n    address: AddressAttribute, stmt_to_insert_before: ir.Statement\n) -&gt; tuple[ir.SSAValue, ...] | None:\n    \"\"\"\n    Extract qubit indices from an AddressAttribute and insert them into the SSA form.\n    \"\"\"\n    qubit_idx_ssas = []\n    if isinstance(address_data := address.address, AddressReg):\n        for qubit_idx in address_data.qubits:\n            create_and_insert_qubit_idx_stmt(\n                qubit_idx.data, stmt_to_insert_before, qubit_idx_ssas\n            )\n    elif isinstance(address_data, AddressQubit):\n        create_and_insert_qubit_idx_stmt(\n            address_data.data, stmt_to_insert_before, qubit_idx_ssas\n        )\n    else:\n        return\n\n    return tuple(qubit_idx_ssas)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/stim/upstream/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/stim/upstream/from_squin/","title":"From squin","text":""},{"location":"reference/bloqade-circuit/src/bloqade/validation/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/validation/kernel_validation/","title":"Kernel validation","text":""},{"location":"reference/bloqade-circuit/src/bloqade/validation/kernel_validation/#bloqade.validation.kernel_validation.KernelValidation","title":"KernelValidation  <code>dataclass</code>","text":"<pre><code>KernelValidation(\n    validation_analysis_cls: type[ValidationAnalysis],\n)\n</code></pre> <p>Validate a kernel according to a <code>ValidationAnalysis</code>.</p> <p>This is a simple wrapper around the analysis that runs the analysis, checks the <code>ValidationFrame</code> for errors and throws them if there are any.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/kernel_validation/#bloqade.validation.kernel_validation.KernelValidation.validation_analysis_cls","title":"validation_analysis_cls  <code>instance-attribute</code>","text":"<pre><code>validation_analysis_cls: type[ValidationAnalysis]\n</code></pre> <p>The analysis that you want to run in order to validate the kernel.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/kernel_validation/#bloqade.validation.kernel_validation.KernelValidation.run","title":"run","text":"<pre><code>run(mt: Method, no_raise: bool = True) -&gt; None\n</code></pre> <p>Run the kernel validation analysis and raise any errors found.</p> <p>Parameters:</p> Name Type Description Default <code>mt</code> <code>Method</code> <p>The method to validate</p> required <code>no_raise</code> <code>bool</code> <p>Whether or not to raise errors when running the analysis. This is only to make sure the analysis works. Errors found during the analysis will be raised regardless of this setting. Defaults to <code>True</code>.</p> <code>True</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/validation/kernel_validation.py</code> <pre><code>def run(self, mt: ir.Method, no_raise: bool = True) -&gt; None:\n    \"\"\"Run the kernel validation analysis and raise any errors found.\n\n    Args:\n        mt (ir.Method): The method to validate\n        no_raise (bool): Whether or not to raise errors when running the analysis.\n            This is only to make sure the analysis works. Errors found during\n            the analysis will be raised regardless of this setting. Defaults to `True`.\n\n    \"\"\"\n\n    validation_analysis = self.validation_analysis_cls(mt.dialects)\n\n    if no_raise:\n        validation_frame, _ = validation_analysis.run_no_raise(mt)\n    else:\n        validation_frame, _ = validation_analysis.run(mt)\n\n    errors = validation_frame.errors\n\n    if len(errors) == 0:\n        # Valid program\n        return\n    elif len(errors) == 1:\n        raise errors[0]\n    else:\n        raise ValidationErrorGroup(errors=errors)\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/analysis/#bloqade.validation.analysis.analysis.ValidationAnalysis","title":"ValidationAnalysis  <code>dataclass</code>","text":"<pre><code>ValidationAnalysis()\n</code></pre> <p>               Bases: <code>ForwardExtra[ValidationFrame, ErrorType]</code>, <code>ABC</code></p> <pre><code>\n              flowchart TD\n              bloqade.validation.analysis.analysis.ValidationAnalysis[ValidationAnalysis]\n\n              \n\n              click bloqade.validation.analysis.analysis.ValidationAnalysis href \"\" \"bloqade.validation.analysis.analysis.ValidationAnalysis\"\n            </code></pre> <p>Analysis pass that indicates errors in the IR according to the respective method tables.</p> <p>If you need to implement validation for a dialect shared by many groups (for example, if you need to ascertain if statements have a specific form) you'll need to inherit from this class.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/analysis/#bloqade.validation.analysis.analysis.ValidationFrame","title":"ValidationFrame  <code>dataclass</code>","text":"<pre><code>ValidationFrame(errors: list[ValidationError] = list())\n</code></pre> <p>               Bases: <code>ForwardFrame[ErrorType]</code></p> <pre><code>\n              flowchart TD\n              bloqade.validation.analysis.analysis.ValidationFrame[ValidationFrame]\n\n              \n\n              click bloqade.validation.analysis.analysis.ValidationFrame href \"\" \"bloqade.validation.analysis.analysis.ValidationFrame\"\n            </code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/analysis/#bloqade.validation.analysis.analysis.ValidationFrame.errors","title":"errors  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>errors: list[ValidationError] = field(default_factory=list)\n</code></pre> <p>List of all ecnountered errors.</p> <p>Append a <code>kirin.ir.ValidationError</code> to this list in the method implementation in order for it to get picked up by the <code>KernelValidation</code> run.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/lattice/#bloqade.validation.analysis.lattice.Error","title":"Error  <code>dataclass</code>","text":"<pre><code>Error(message: str = '')\n</code></pre> <p>               Bases: <code>ErrorType</code></p> <pre><code>\n              flowchart TD\n              bloqade.validation.analysis.lattice.Error[Error]\n              bloqade.validation.analysis.lattice.ErrorType[ErrorType]\n\n                              bloqade.validation.analysis.lattice.ErrorType --&gt; bloqade.validation.analysis.lattice.Error\n                \n\n\n              click bloqade.validation.analysis.lattice.Error href \"\" \"bloqade.validation.analysis.lattice.Error\"\n              click bloqade.validation.analysis.lattice.ErrorType href \"\" \"bloqade.validation.analysis.lattice.ErrorType\"\n            </code></pre> <p>Indicates an error in the IR.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/lattice/#bloqade.validation.analysis.lattice.Error.message","title":"message  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>message: str = ''\n</code></pre> <p>Optional error message to show in the IR.</p> <p>NOTE: this is just to show a message when printing the IR. Actual errors are collected by appending ir.ValidationError to the frame in the method implementation.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/validation/analysis/lattice/#bloqade.validation.analysis.lattice.InvalidErrorType","title":"InvalidErrorType  <code>dataclass</code>","text":"<pre><code>InvalidErrorType()\n</code></pre> <p>               Bases: <code>ErrorType</code></p> <pre><code>\n              flowchart TD\n              bloqade.validation.analysis.lattice.InvalidErrorType[InvalidErrorType]\n              bloqade.validation.analysis.lattice.ErrorType[ErrorType]\n\n                              bloqade.validation.analysis.lattice.ErrorType --&gt; bloqade.validation.analysis.lattice.InvalidErrorType\n                \n\n\n              click bloqade.validation.analysis.lattice.InvalidErrorType href \"\" \"bloqade.validation.analysis.lattice.InvalidErrorType\"\n              click bloqade.validation.analysis.lattice.ErrorType href \"\" \"bloqade.validation.analysis.lattice.ErrorType\"\n            </code></pre> <p>Bottom to represent when we encounter an error running the analysis.</p> <p>When this is encountered, it means there might be an error, but we were unable to tell.</p>"},{"location":"reference/bloqade-circuit/src/bloqade/visual/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/animate/","title":"Animate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/animate/#bloqade.visual.animation.animate.animate_qpu_state","title":"animate_qpu_state","text":"<pre><code>animate_qpu_state(\n    state: QPUStateABC,\n    display_fov: Optional[FieldOfView] = None,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    fig_args={},\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: int | None = None,\n)\n</code></pre> <p>Generate an animation from the QPU state</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>QPUStateABC</code> <p>The QPU state to animate</p> required <code>display_fov</code> <code>Optional[FieldOfView]</code> <p>The field of view to display. Defaults to None. If None, it will use the QPU's field of view.</p> <code>None</code> <code>dilation_rate</code> <code>float</code> <p>The rate at which to dilate the time. Defaults to 0.05.</p> <code>0.05</code> <code>fps</code> <code>int</code> <p>The frames per second. Defaults to 30.</p> <code>30</code> <code>gate_display_dilation</code> <code>float</code> <p>The rate at which to dilate the gate display. Defaults to 1.0.</p> <code>1.0</code> <code>fig_args</code> <code>dict</code> <p>The arguments to pass to the matplotlib.pyplot.figure. Defaults to {}.</p> <code>{}</code> <code>save_mpeg</code> <code>bool</code> <p>Whether to save the animation as an mpeg. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>The filename to save the mpeg as. Defaults to \"vqpu_animation\".</p> <code>'vqpu_animation'</code> <code>start_block</code> <code>int</code> <p>The block to start the animation at. Defaults to 0.</p> <code>0</code> <code>n_blocks</code> <code>int | None</code> <p>The number of blocks to animate. Defaults to None. If None, it will animate all blocks after <code>start_block</code>.</p> <code>None</code> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/visual/animation/animate.py</code> <pre><code>def animate_qpu_state(\n    state: QPUStateABC,\n    display_fov: Optional[FieldOfView] = None,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    fig_args={},\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: int | None = None,\n):\n    \"\"\"Generate an animation from the QPU state\n\n    Args:\n        state (QPUStateABC): The QPU state to animate\n        display_fov (Optional[FieldOfView], optional): The field of view to display. Defaults to None. If None, it will use the QPU's field of view.\n        dilation_rate (float, optional): The rate at which to dilate the time. Defaults to 0.05.\n        fps (int, optional): The frames per second. Defaults to 30.\n        gate_display_dilation (float, optional): The rate at which to dilate the gate display. Defaults to 1.0.\n        fig_args (dict, optional): The arguments to pass to the matplotlib.pyplot.figure. Defaults to {}.\n        save_mpeg (bool, optional): Whether to save the animation as an mpeg. Defaults to False.\n        filename (str, optional): The filename to save the mpeg as. Defaults to \"vqpu_animation\".\n        start_block (int, optional): The block to start the animation at. Defaults to 0.\n        n_blocks (int | None, optional): The number of blocks to animate. Defaults to None. If None, it will animate all blocks after `start_block`.\n\n    \"\"\"\n    qpu_fov = state.qpu_fov\n\n    if display_fov is None:\n        display_fov = qpu_fov\n\n    if start_block &gt;= len(state.block_durations) or start_block &lt; 0:\n        raise ValueError(\"Start block index is out of range\")\n\n    if n_blocks is None:\n        n_blocks = len(state.block_durations) - start_block\n\n    if n_blocks &lt; 0:\n        raise ValueError(\"Number of block to animate must be non-negative\")\n\n    slm_sites = state.get_slm_sites()\n\n    # Scale the figure to different screens and so that the number of SLM sites has the same\n    # \"area\" on screen\n    nsites = max([4, len(slm_sites)])\n    scale = (\n        np.sqrt(44.0 / nsites) * 2.0 * plt.rcParams[\"figure.dpi\"] / 100\n    )  # scale the size of the figure\n\n    # figure:\n    new_fig_args = {\"figsize\": (14, 8), **fig_args}\n    fig, mpl_axs = plt.subplot_mosaic(\n        mosaic=[[\"Reg\", \"Info\"], [\"Reg\", \"Gate\"], [\"Reg\", \"Gate\"]],\n        gridspec_kw={\"width_ratios\": [3, 1]},\n        **new_fig_args,\n    )\n\n    # mpl_axs[\"Reg\"].axis(\"equal\")  # Axis equal must come before axis limits\n    mpl_axs[\"Reg\"].set_xlim(left=display_fov.xmin, right=display_fov.xmax)\n    mpl_axs[\"Reg\"].set_ylim(bottom=display_fov.ymin, top=display_fov.ymax)\n    mpl_axs[\"Reg\"].set(xlabel=\"x (um)\", ylabel=\"y (um)\")\n    mpl_axs[\"Reg\"].set_aspect(\"equal\")\n\n    # slm:\n    slm_plt_arg = {\n        \"facecolors\": \"none\",\n        \"edgecolors\": \"k\",\n        \"linestyle\": \"-\",\n        \"s\": 80 * scale,\n        \"alpha\": 0.3,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    mpl_axs[\"Reg\"].scatter(\n        x=slm_sites[:, 0], y=slm_sites[:, 1], **slm_plt_arg\n    )  # this is statically generated, so it will be the background\n\n    # atoms:\n    reg_plt_arg = {\n        \"s\": 65 * scale,\n        \"marker\": \"o\",\n        \"facecolors\": quera_color_code.purple,\n        \"alpha\": 1.0,\n    }\n    reg_panel = mpl_axs[\"Reg\"]\n    reg_scat = reg_panel.scatter([], [], **reg_plt_arg)\n\n    # gates:\n    gp = GatePainter(mpl_ax=reg_panel, qpu_fov=qpu_fov, scale=scale)\n\n    # annotate_args = {\"fontsize\": 8, \"ha\": \"center\", \"alpha\": 0.7, \"color\": quera_color_code.yellow}\n    annotate_args = {\n        \"fontsize\": 6 * np.sqrt(scale),\n        \"ha\": \"center\",\n        \"va\": \"center\",\n        \"alpha\": 1.0,\n        \"color\": quera_color_code.yellow,\n        \"weight\": \"bold\",\n    }\n    reg_annot_list = [\n        reg_panel.annotate(f\"{i}\", atom_position, **annotate_args)\n        for i, atom_position in state.get_atoms_position(time=0.0, include_lost=False)\n    ]\n\n    # AODs:\n    aod_plot_args = {\n        \"s\": 260 * scale,\n        \"marker\": \"+\",\n        \"alpha\": 0.7,\n        \"facecolors\": quera_color_code.red,\n        \"zorder\": -100,\n        \"linewidth\": np.sqrt(scale),\n    }\n    aod_scat = reg_panel.scatter(x=[], y=[], **aod_plot_args)\n\n    aod_h_args = {\n        \"s\": 1e20,\n        \"marker\": \"|\",\n        \"alpha\": 1.0,\n        \"color\": \"#FFE8E9\",\n        \"zorder\": -101,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    aod_h_scat = reg_panel.scatter(x=[], y=[], **aod_h_args)\n    aod_v_args = {\n        \"s\": 1e20,\n        \"marker\": \"_\",\n        \"alpha\": 1.0,\n        \"color\": \"#FFE8E9\",\n        \"zorder\": -101,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    aod_v_scat = reg_panel.scatter(x=[], y=[], **aod_v_args)\n\n    ## Info Panel\n    info_text = mpl_axs[\"Info\"].text(x=0.05, y=0.5, s=\"\")\n    mpl_axs[\"Info\"].set_xticks([])\n    mpl_axs[\"Info\"].set_yticks([])\n    mpl_axs[\"Info\"].grid(False)\n\n    ## Event Panel:\n    log_text = mpl_axs[\"Gate\"].text(x=0.05, y=0.0, s=\"\", size=6)\n    mpl_axs[\"Gate\"].set_xticks([])\n    mpl_axs[\"Gate\"].set_yticks([])\n    mpl_axs[\"Gate\"].grid(False)\n\n    tstep_mv = 1.0 / (fps * dilation_rate)\n    tstep_gate = 1.0 / (fps * dilation_rate * gate_display_dilation)\n    blk_t_end = np.cumsum(state.block_durations)\n\n    # determine the dilation part of the timeline, and generate more frame\n    chunk_times = []\n    curr_t = 0 if start_block == 0 else blk_t_end[start_block - 1]\n\n    for glb_tstart_gate, duration in state.get_gate_events_timing():\n        if glb_tstart_gate &lt; curr_t:  # gate start before the current time\n            if glb_tstart_gate + duration &lt; curr_t:\n                continue\n        else:\n            dt = glb_tstart_gate - curr_t\n            chunk_times.append(np.linspace(curr_t, glb_tstart_gate, int(dt / tstep_mv)))\n            curr_t = glb_tstart_gate\n\n        t_gate_end = glb_tstart_gate + duration\n        dt = t_gate_end - curr_t\n        chunk_times.append(np.linspace(curr_t, t_gate_end, int(dt / tstep_gate)))\n        curr_t = t_gate_end\n\n    dt = blk_t_end[-1] - curr_t\n    chunk_times.append(np.linspace(curr_t, blk_t_end[-1], int(dt / tstep_mv)))\n\n    times = np.concatenate(chunk_times)\n\n    fig.tight_layout()\n    fig.subplots_adjust(wspace=0.1)\n\n    def _update_annotate(loc, idx, annotate_artist):\n        new_loc = (loc[0], loc[1] - 0.06)\n        annotate_artist.set_position(new_loc)\n        txt = f\"{idx}\"\n        annotate_artist.set_text(txt)\n        return loc\n\n    def update(frame: int, state: QPUStateABC, times: np.ndarray, blk_t_end: np.array):\n\n        # get positions:\n\n        blk_id = bisect.bisect_left(blk_t_end, times[frame])\n        lbl = f\"Block: [{blk_id}]\\n\"\n        lbl += f\"Block dur: {state.block_durations[blk_id]:.2f} us\\n\"\n        lbl += f\"Total elapsed time: {times[frame]:.2f} us\"\n        info_text.set_text(lbl)\n\n        # update atoms location and annotation\n        post = np.array(\n            [\n                _update_annotate(\n                    atom_position,\n                    i,\n                    reg_annot_list[i],\n                )\n                for i, atom_position in state.get_atoms_position(\n                    times[frame], include_lost=False\n                )\n            ]\n        )\n        post = post if post.size &gt; 0 else np.array([(None, None)])\n        reg_scat.set_offsets(post)\n\n        # update log event panels\n        lost_events = state.get_atoms_lost_info(times[frame])\n\n        # update log gate:\n        gate_events = state.get_gate_events(times[frame])\n        gate_events_log = [\n            f\"Gate: {gate.cls_name} @ {t:.6f} (us)\\n\"\n            for t, gate in state.get_gate_events(times[frame])\n        ]\n        log_text.set_text(\"\".join(lost_events) + \"\".join(gate_events_log))\n\n        gate_artists = gp.process_gates([gate for _, gate in gate_events])\n\n        # update AODs\n        post = state.sample_aod_traps(times[frame]) or [(None, None)]\n        aod_scat.set_offsets(post)\n        aod_v_scat.set_offsets(post)\n        aod_h_scat.set_offsets(post)\n\n        return (\n            [reg_scat, info_text, log_text, aod_scat, aod_v_scat, aod_h_scat]\n            + reg_annot_list\n            + gate_artists\n        )\n\n    ani = FuncAnimation(\n        fig=fig,\n        func=functools.partial(update, state=state, times=times, blk_t_end=blk_t_end),\n        frames=len(times),\n        interval=tstep_mv,\n        blit=True,\n        repeat=False,\n    )\n    if save_mpeg:\n        n_frame = len(times)\n        pbar = tqdm.tqdm(range(n_frame))\n\n        def p_call_back(i, total_n):\n            pbar.update()\n\n        ani.save(\n            f\"{filename}.mp4\", writer=\"ffmpeg\", fps=fps, progress_callback=p_call_back\n        )\n    else:\n        return ani\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/base/","title":"Base","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/base/#bloqade.visual.animation.base.RowRegionGateArtist","title":"RowRegionGateArtist  <code>dataclass</code>","text":"<pre><code>RowRegionGateArtist(\n    mpl_ax: Any,\n    xmin,\n    width,\n    ymin,\n    ymin_keepout,\n    ymax,\n    ymax_keepout,\n    color,\n)\n</code></pre> <p>               Bases: <code>GateArtist</code></p> <pre><code>\n              flowchart TD\n              bloqade.visual.animation.base.RowRegionGateArtist[RowRegionGateArtist]\n              bloqade.visual.animation.base.GateArtist[GateArtist]\n\n                              bloqade.visual.animation.base.GateArtist --&gt; bloqade.visual.animation.base.RowRegionGateArtist\n                \n\n\n              click bloqade.visual.animation.base.RowRegionGateArtist href \"\" \"bloqade.visual.animation.base.RowRegionGateArtist\"\n              click bloqade.visual.animation.base.GateArtist href \"\" \"bloqade.visual.animation.base.GateArtist\"\n            </code></pre> <p>A row region gate artist object.</p> <p>bound box is [y_origin - width/2, y_origin + width/2]</p> Source code in <code>.venv/lib/python3.12/site-packages/bloqade/visual/animation/base.py</code> <pre><code>def __init__(\n    self, mpl_ax: Any, xmin, width, ymin, ymin_keepout, ymax, ymax_keepout, color\n):\n    super().__init__(mpl_ax)\n    self.width = width\n    self.xmin = xmin\n    rc_btm = mpatches.Rectangle(\n        (xmin, ymin_keepout),\n        width,\n        ymin - ymin_keepout,\n        color=color,\n        alpha=0.3,\n        visible=False,\n    )\n    mpl_ax.add_patch(rc_btm)\n    self.mpl_obj_keepout_btm = rc_btm\n\n    rc = mpatches.Rectangle(\n        (xmin, ymin), width, ymax - ymin, color=color, alpha=0.6, visible=False\n    )\n    mpl_ax.add_patch(rc)\n    self.mpl_obj = rc\n\n    rc_top = mpatches.Rectangle(\n        (xmin, ymax),\n        width,\n        ymax_keepout - ymax,\n        color=color,\n        alpha=0.3,\n        visible=False,\n    )\n    mpl_ax.add_patch(rc_top)\n    self.mpl_obj_keepout_top = rc_top\n</code></pre>"},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/gate_event/","title":"Gate event","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/runtime/","title":"Index","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/runtime/aod/","title":"Aod","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/runtime/atoms/","title":"Atoms","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/runtime/ppoly/","title":"Ppoly","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/runtime/qpustate/","title":"Qpustate","text":""},{"location":"reference/bloqade-circuit/src/bloqade/visual/animation/runtime/utils/","title":"Utils","text":""},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2023/","title":"2023","text":""}]}