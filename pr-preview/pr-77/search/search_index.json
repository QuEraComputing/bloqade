{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\: )\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/","title":"Analog","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/#quick-start","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"analog/#navigating-the-bloqade-api","title":"Navigating the Bloqade API","text":"<p>As you develop your Bloqade program, you are expected to rely on pop-up \"hints\" provided in your development environment to help you determine what the next part of your program should be.</p>"},{"location":"analog/#vs-code","title":"VS Code","text":"<p>In VS Code this is automatic, just type the <code>.</code> and see what options pop up:</p> <p></p>"},{"location":"analog/#jetbrains-pycharm","title":"JetBrains PyCharm","text":"<p>The same goes for JetBrains PyCharm:</p> <p></p>"},{"location":"analog/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>In a Jupyter Notebook you'll need to type <code>.</code> and then hit tab for the hints to appear:</p> <p></p>"},{"location":"analog/#ipython","title":"IPython","text":"<p>The same goes for IPython:</p> <p></p>"},{"location":"analog/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"analog/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"analog/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"analog/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"analog/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"analog/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"analog/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"analog/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"analog/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"analog/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"background/","title":"Background","text":""},{"location":"background/#neutral-atom-qubits","title":"Neutral Atom Qubits","text":"<p>The qubits that QuEra's neutral atom computer Aquila and Bloqade are designed to emulate are based on neutral atoms. As the name implies they are atoms that are neutrally charged but are also capable of achieving a Rydberg state where a single electron can be excited to an incredibly high energy level without ionizing the atom.</p> <p>This incredibly excited electron energy level \\(|r\\rangle\\) and its default ground state \\(|g\\rangle\\) create a two-level system where superposition can occur. For enabling interaction between two or more qubits and achieving entanglement, when the neutral atoms are in the Rydberg state a phenomenon known as the Rydberg blockade can occur where an atom in the Rydberg state prevents a neighboring atom from also being excited to the same state.</p> <p>For a more nuanced and in-depth read about the neutral atoms that Bloqade and Aquila use, refer to QuEra's qBook section on Qubits by puffing up atoms.</p>"},{"location":"background/#analog-vs-digital-quantum-computing","title":"Analog vs Digital Quantum Computing","text":"<p>There are two modes of quantum computation that neutral atoms are capable of: Analog and Digital.</p> <p>You can find a brief explanation of the distinction below but for a more in-depth explanation you can refer to QuEra's qBook section on Analog vs Digital Quantum Computing</p>"},{"location":"background/#analog-mode","title":"Analog Mode","text":"<p>In the analog mode (supported by Bloqade and Aquila) you control your computation through the parameters of a time-dependent Hamiltonian that influences all the qubits at once. There are options for local control of the Hamiltonian on certain qubits however.</p>"},{"location":"background/#digital-mode","title":"Digital Mode","text":"<p>In the Digital Mode individual or multiple groups of qubits are controlled by applying gates (individual unitary operations). For neutral atoms, this digital mode can be accomplished with the introduction of hyperfine coupling, enabling a quantum state to be stored for long periods of time while also allowing for multi-qubit gates.</p>"},{"location":"background/#rydberg-many-body-hamiltonian","title":"Rydberg Many-Body Hamiltonian","text":"<p>When you emulate a program in Bloqade, you are emulating the time evolution of the Rydberg many-body Hamiltonian which looks like this:</p> \\[ i \\hbar \\dfrac{\\partial}{\\partial t} | \\psi \\rangle = \\hat{\\mathcal{H}}(t) | \\psi \\rangle,  \\\\ \\] \\[ \\frac{\\mathcal{H}(t)}{\\hbar} = \\sum_j \\frac{\\Omega_j(t)}{2} \\left( e^{i \\phi_j(t) } | g_j \\rangle  \\langle r_j | + e^{-i \\phi_j(t) } | r_j \\rangle  \\langle g_j | \\right) - \\sum_j \\Delta_j(t) \\hat{n}_j + \\sum_{j &lt; k} V_{jk} \\hat{n}_j \\hat{n}_k, \\] <p>where: \\(\\Omega_j\\), \\(\\phi_j\\), and \\(\\Delta_j\\) denote the Rabi frequency amplitude, laser phase, and the detuning of the driving laser field on atom (qubit) \\(j\\) coupling the two states  \\(| g_j \\rangle\\) (ground state) and \\(| r_j \\rangle\\) (Rydberg state); \\(\\hat{n}_j = |r_j\\rangle \\langle r_j|\\) is the number operator, and \\(V_{jk} = C_6/|\\mathbf{x}_j - \\mathbf{x}_k|^6\\) describes the Rydberg interaction (van der Waals interaction) between atoms \\(j\\) and \\(k\\) where \\(\\mathbf{x}_j\\) denotes the position of the atom \\(j\\); \\(C_6\\) is the Rydberg interaction constant that depends on the particular Rydberg state used. For Bloqade, the default \\(C_6 = 862690 \\times 2\\pi \\text{ MHz \u03bcm}^6\\) for \\(|r \\rangle = \\lvert 70S_{1/2} \\rangle\\) of the \\(^{87}\\)Rb atoms; \\(\\hbar\\) is the reduced Planck's constant.</p>"},{"location":"background/#local-control","title":"Local Control","text":"<p>The Rydberg Many-Body Hamiltonian already implies from its subscripts that you can also have local control over your atoms. In Bloqade this local control extends to any term in the Hamiltonian while on Aquila this is currently restricted to the \\(\\Delta_j\\) laser detuning term.</p> <p>Fields in Bloqade give you local (single-atom) control over the many-body Rydberg Hamiltonian.</p> <p>They are a sum of one or more spatial modulations, which allows you to scale the amplitude of the waveform across the different sites in the system:</p> \\[ F_{i}(t) = \\sum_{\\alpha} C_{i}^{\\alpha}f_{\\alpha}(t) \\] \\[ C_{i}^{\\alpha} \\in \\mathbb{R} \\] \\[ f_{\\alpha}(t) \\colon \\mathbb{R} \\to \\mathbb{R} \\] <p>The \\(i\\)-th component of the field is used to generate the drive at the \\(i\\)-th site.</p> <p>Note that the drive is only applied if the \\(i\\)-th site is filled with an atom.</p> <p>You build fields in Bloqade by first specifying the spatial modulation followed by the waveform it should be multiplied by.</p> <p>In the case of a uniform spatial modulation, it can be interpreted as a constant scaling factor where \\(C_{i}^{\\alpha} = 1.0\\).</p>"},{"location":"contrib/","title":"Contributing","text":"<p>Please see Installation for instructions on how to set up your development environment.</p>"},{"location":"contrib/#pre-commit-hooks","title":"Pre-commit hooks","text":"<p>We use <code>pre-commit</code> to run the linter checks before you commit your changes. The pre-commit hooks are installed as part of the development dependencies. You can setup <code>pre-commit</code> using the following command:</p> <pre><code>pre-commit install\n</code></pre> <p>This will run the linter checks before you commit your changes. If the checks fail, the commit will be rejected. Most of the following sections can be checked by the pre-commit hooks.</p>"},{"location":"contrib/#running-the-tests","title":"Running the tests","text":"<p>We use <code>pytest</code> for testing. To run the tests, simply run:</p> <pre><code>pytest\n</code></pre> <p>or for a specific test file with the <code>-s</code> flag to show the output of the program:</p> <pre><code>pytest -s tests/test_program.py\n</code></pre> <p>lots of tests contains pretty printing of the IR themselves, so it's useful to see the output.</p>"},{"location":"contrib/#code-style","title":"Code style","text":"<p>We use <code>black</code> for code formatting. Besides the linter requirements, we also require the following good-to-have practices:</p>"},{"location":"contrib/#naming","title":"Naming","text":"<ul> <li>try not to use abbreviation as names, unless it's a common abbreviation like <code>idx</code> for <code>index</code></li> <li>try not create a lot of duplicated name prefix unless the extra information is necessary when accessing the class object.</li> <li>try to use <code>snake_case</code> for naming variables and functions, and <code>CamelCase</code> for classes.</li> </ul>"},{"location":"contrib/#comments","title":"Comments","text":"<ul> <li>try not to write comments, unless it's really necessary. The code should be self-explanatory.</li> <li>if you have to write comments, try to use <code>NOTE:</code>, <code>TODO:</code> <code>FIXME:</code> tags to make it easier to search for them.</li> </ul>"},{"location":"contrib/#documentation","title":"Documentation","text":"<p>We use <code>just</code> for mangaging command line tools and scripts. It should be installed when you run <code>uv sync</code>. To build the documentation, simply run:</p> <pre><code>just doc\n</code></pre> <p>This will launch a local server to preview the documentation. You can also run <code>just doc-build</code> to build the documentation without launching the server.</p>"},{"location":"contrib/#license","title":"License","text":"<p>By contributing to this project, you agree to license your contributions under the Apache License 2.0 with LLVM Exceptions.</p>"},{"location":"install/","title":"Installation","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"qasm2/","title":"QASM2","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/#the-analog-module-of-bloqade","title":"The Analog Module of Bloqade","text":""},{"location":"analog/#what-is-bloqade-analog","title":"What is Bloqade Analog?","text":"<p>Bloqade Analog is a Python SDK for QuEra's neutral atom quantum computer Aquila (check out our paper!). It's designed to make writing and analyzing the results of analog quantum programs on Aquila as easy as possible. It features custom atom geometries and flexible waveform definitions in both emulation and real hardware. Bloqade Analog interfaces with the AWS Braket cloud service where Aquila  is hosted, enabling you to submit programs as well as retrieve and analyze real hardware results all-in-one.</p>"},{"location":"analog/#installation","title":"Installation","text":"<p>You can install the package with <code>pip</code> in your Python environment of choice via:</p> <pre><code>pip install bloqade[analog]\n</code></pre>"},{"location":"analog/#a-glimpse-of-bloqade-analog","title":"A Glimpse of Bloqade Analog","text":"<p>Let's try a simple example where we drive a Rabi oscillation on a single neutral atom. Don't worry if you're unfamiliar with neutral atom physics, (you can check out our Background for more information!) the goal here is to just give you a taste of what Bloqade Analog can do.</p> <p>We start by defining where our atoms go, otherwise known as the atom geometry. In this particular example we will use a small Honeycomb lattice:</p> <pre><code>from bloqade.analog.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\n</code></pre> <p>We can verify what the atom geometry looks like by <code>.show()</code>'ing it:</p> <pre><code>geometry.show()\n</code></pre> <p>We now define what the time evolution looks like using a pulse sequence. The pulse sequence here is the time profile of the Rabi Drive targeting the ground-Rydberg two level transition, which causes the Rabi oscillations. We choose a constant waveform with a value of \\(\\frac{\\pi}{2} \\text{rad}/\\text{us}\\) and a duration of \\(1.0 \\,\\text{us}\\). This produces a \\(\\frac{\\pi}{2}\\) rotation on the Bloch sphere meaning our final measurements should be split 50/50 between the ground and Rydberg state.</p> <pre><code>from math import pi\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\n</code></pre> <p>Here <code>rabi.amplitude</code> means exactly what it is, the Rabi amplitude term of the Hamiltonian. <code>uniform</code> refers to applying the waveform uniformly across all the atom locations.</p> <p>We can visualize what our program looks like again with <code>.show()</code>:</p> <p>We can now run the program through Bloqade Analog's built-in emulator to get some results. We designate that we want the program to be run and measurements performed 100 times:</p> <pre><code>emulation_results = rabi_program.bloqade.python().run(100)\n</code></pre> <p>With the results we can generate a report object that contains a number of methods for analyzing our data, including the number of counts per unique bitstring:</p> <pre><code>bitstring_counts = emulation_results.report().counts()\n</code></pre> <p>Which gives us:</p> <pre><code>[OrderedDict([('0', 55), ('1', 45)])]\n</code></pre> <p>If we want to submit our program to hardware we'll need to adjust the waveform as there is a constraint the Rabi amplitude waveform must start and end at zero. This is easy to do as we can build off the atom geometry we saved previously but apply a piecewise linear waveform:</p> <pre><code>hardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\n\nhardware_rabi_program.show()\n</code></pre> <p>Now instead of using the built-in Bloqade Analog emulator we submit the program to Aquila. You will need to use the AWS CLI to obtain credentials from your AWS account or set the proper environment variables before hand.</p> <pre><code>hardware_results = hardware_rabi_program.braket.aquila.run_async(100)\n</code></pre> <p><code>.run_async</code> is a non-blocking version of the standard <code>.run</code> method, allowing you to continue work while waiting for results from Aquila. <code>.run_async</code> immediately returns an object you can query for the status of your tasks in the queue as well.</p> <p>You can do the exact same analysis you do on emulation results with hardware results too:</p> <pre><code>hardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p>If you want to try the above at once, we collected the above steps into the snippet below:</p> <pre><code>from math import pi\nfrom bloqade.analog.atom_arrangement import Honeycomb\n\ngeometry = Honeycomb(2, lattice_spacing = 10.0)\nrabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .constant(value=pi/2, duration=1.0)\n)\nemulation_results = rabi_program.bloqade.python().run(100)\nbitstring_counts = emulation_results.report().counts()\n\nhardware_rabi_program = (\n  geometry\n  .rydberg.rabi.amplitude.uniform\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nhardware_results = hardware_rabi_program.braket.aquila.run_async(100)\nhardware_bitstring_counts = hardware_results.report().counts()\n</code></pre> <p> </p>"},{"location":"analog/#features","title":"Features","text":""},{"location":"analog/#customizable-atom-geometries","title":"Customizable Atom Geometries","text":"<p>You can easily explore a number of common geometric lattices with Bloqade Analog's <code>atom_arrangement</code>'s:</p> <pre><code>from bloqade.analog.atom_arrangement import Lieb, Square, Chain, Kagome\n\ngeometry_1 = Lieb(3)\ngeometry_2 = Square(2)\ngeometry_3 = Chain(5)\ngeometry_4 = Kagome(3)\n</code></pre> <p>If you're not satisfied with the Bravais lattices we also allow you to modify existing Bravais lattices as follows:</p> <pre><code>geometry_5 = Kagome(3).add_position((10,11))\n</code></pre> <p>You can also build your geometry completely from scratch:</p> <pre><code>from bloqade.analog import start\n\ngeometry = start.add_positions([(0,0), (6,0), (12,0)])\n</code></pre>"},{"location":"analog/#flexible-pulse-sequence-construction","title":"Flexible Pulse Sequence Construction","text":"<p>Define waveforms for pulse sequences any way you like by either building (and chaining!) them immediately as part of your program:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\n\ngeometry = Square(2)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\ncustom_rabi_amp_waveform = (\n  target_rabi_amplitude\n  .piecewise_linear(values=[0, 10, 10, 0], durations=[0.1, 3.5, 0.1])\n  .piecewise_linear(values=[0, 5, 3, 0], durations=[0.2, 2.0, 0.2])\n)\n</code></pre> <p>Or building them separately and applying them later:</p> <pre><code>from bloqade.analog.atom_arrangement import Square, Chain\n\ngeometry_1 = Square(3)\ngeometry_2 = Chain(5)\n\ntarget_rabi_amplitude = start.rydberg.rabi.amplitude.uniform\npulse_sequence = target_rabi_amplitude.uniform.constant(value=2.0, duration=1.5).parse_sequence()\n\nprogram_1 = geometry_1.apply(pulse_sequence)\nprogram_2 = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/#hardware-and-emulation-backends","title":"Hardware and Emulation Backends","text":"<p>Go from a fast and powerful emulator:</p> <pre><code>from bloqade.analog.atom_arrangement import Square\nfrom math import pi\n\ngeometry = Square(3, lattice_spacing = 6.5)\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nprogram = (\n  target_rabi_amplitude\n  .piecewise_linear(values = [0, pi/2, pi/2, 0], durations = [0.06, 1.0, 0.06])\n)\nemulation_results = program.bloqade.python().run(100)\n</code></pre> <p>To real quantum hardware in a snap:</p> <pre><code>hardware_results = program.braket.aquila().run_async(100)\n</code></pre>"},{"location":"analog/#simple-parameter-sweeps","title":"Simple Parameter Sweeps","text":"<p>Use variables to make parameter sweeps easy on both emulation and hardware:</p> <pre><code>from bloqade.analog import start\nimport numpy as np\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_oscillation_program = (\n  target_rabi_amplitude\n  .piecewise_linear(durations = [0.06, \"run_time\", 0.06], values = [0, 15, 15, 0])\n)\nrabi_oscillation_job = rabi_oscillation_program.batch_assign(run_time=np.linspace(0, 3, 101))\n\nemulation_results = rabi_oscillation_job.bloqade.python().run(100)\nhardware_results = rabi_oscillation_job.braket.aquila().run(100)\n</code></pre> <pre><code>emulation_results.report().rydberg_densities()\n                0\ntask_number\n0            0.16\n1            0.35\n2            0.59\n3            0.78\n4            0.96\n...           ...\n96           0.01\n97           0.09\n98           0.24\n99           0.49\n100          0.68\n\n[101 rows x 1 columns]\n</code></pre>"},{"location":"analog/#quick-results-analysis","title":"Quick Results Analysis","text":"<p>Want to just see some plots of your results? <code>.show()</code> will show you the way!</p> <p><pre><code>from bloqade.analog.atom_arrangement import Square\n\nrabi_amplitude_values = [0.0, 15.8, 15.8, 0.0]\nrabi_detuning_values = [-16.33, -16.33, 42.66, 42.66]\ndurations = [0.8, 2.4, 0.8]\n\ngeometry = Square(3, lattice_spacing=5.9)\nrabi_amplitude_waveform = (\n  geometry\n  .rydberg.rabi.amplitude.uniform.piecewise_linear(durations, rabi_amplitude_values)\n)\nprogram = (\n  rabi_amplitude_waveform\n  .detuning.uniform.piecewise_linear(durations, rabi_detuning_values)\n)\nemulation_results = program.bloqade.python().run(100)\nemulation_results.report().show()\n</code></pre> </p>"},{"location":"analog/#contributing-to-bloqade-analog","title":"Contributing to Bloqade Analog","text":"<p>Bloqade Analog is released under the Apache License, Version 2.0. If you'd like the chance to shape the future of neutral atom quantum computation, see our Contributing Guide for more info!</p>"},{"location":"analog/emulation/","title":"Emulation","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/geometry/","title":"Geometry","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/gotchas/","title":"Gotchas","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/gotchas/#bloqade-gotchas-common-mistakes-in-using-bloqade","title":"Bloqade Gotchas: Common Mistakes in Using Bloqade","text":"<p>It is tempting when coming from different quantum SDKs and frameworks to apply the same pattern of thought to Bloqade. However, a lot of practices from those prior tools end up being anti-patterns in Bloqade. While you can use those patterns and they can still work, it ends up causing you the developer to write unnecessarily verbose, complex, and hard-to-read code as well as preventing you from reaping the full benefits of what Bloqade has to offer.</p> <p>This page is dedicated to cataloguing those anti-patterns and what you can do instead to maximize the benefit Bloqade can offer you.</p>"},{"location":"analog/gotchas/#redefining-lattices-and-common-atom-arrangements","title":"Redefining Lattices and Common Atom Arrangements","text":"<p>You might be tempted to define lattice-based geometries through the following means:</p> <pre><code>from bloqade import start\n\nspacing = 4.0\ngeometry = start.add_positions(\n    [(i * spacing, j * spacing) for i in range(4) for j in range(4)]\n)\n</code></pre> <p>This is quite redundant and verbose, especially considering Bloqade offers a large number of pre-defined lattices you can customize the spacing of in <code>bloqade.atom_arrangement</code>. In the code above, we're just defining a 4x4 square lattice of atoms with 4.0 micrometers of spacing between them. This can be expressed as follows</p> <pre><code>from bloqade.atom_arrangement import Square\n\nspacing = 4.0\ngeometry = Square(4, lattice_spacing = spacing)\n</code></pre>"},{"location":"analog/gotchas/#copying-a-program-to-create-new-ones","title":"Copying a Program to create New Ones","text":"<p>Many gate-based SDKs rely on having a mutable object representing your circuit. This means if you want to build on top of some base circuit without mutating it, you have to copy it:</p> <pre><code>import copy\n\nbase_circuit = qubits.x(0)....\n# make copy of base circuit\ncustom_circuit_1 = copy(base_circuit)\n# build on top of copy of base circuit\ncustom_circuit_1.x(0).z(5)...\n# create a new circuit by copying the base again\ncustom_circuit_2 = copy(base_circuit)\n# build on top of that copy again\ncustom_circuit_2.y(5).cz(0,2)...\n</code></pre> <p>In Bloqade Python this is unnecessary because at every step of your program an immutable object is returned which means you can save it and not have to worry about mutating any internal state.</p> <pre><code>from bloqade import start\nbase_program = start.add_position((0,0)).rydberg.rabi.amplitude.uniform\n# Just recycle your base program! No `copy` needed!\nnew_program_1 = base_program.constant(duration=5.0, value=5.0)\nnew_program_2 = base_program.piecewise_linear(\n    durations=[5.0], values = [0.0, 5.0]\n)\n</code></pre>"},{"location":"analog/gotchas/#creating-new-programs-instead-of-using-batch_assign","title":"Creating New Programs Instead of Using <code>.batch_assign</code>","text":"<p>If you have a set of parameters you'd like to test your program on versus a single parameter, don't generate a new program for each value:</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\nprograms_with_different_rabi_values = []\n\nfor rabi_value in rabi_values:\n    program = start.add_position((0, 0)).rydberg.rabi.amplitude.uniform.constant(\n        duration=5.0, value=rabi_value\n    )\n    programs_with_different_rabi_values.append(program)\n\nresults = []\n\nfor program in programs_with_different_rabi_values:\n    result = program.bloqade.python().run(100)\n    results.append(result)\n</code></pre> <p>Instead take advantage of the fact Bloqade has facilities specifically designed to make trying out multiple values in your program without needing to make individual copies via <code>.batch_assign</code>. The results are also automatically handled for you so each value you test has its own set of results, but all collected in a singular dataframe versus the above where you'd have to keep track of individual results.</p> <pre><code>rabi_values = [2.0, 4.7, 6.1]\n# place a variable for the Rabi Value and then batch assign values to it\nprogram_with_rabi_values = start.add_position(\n    0, 0\n).rydberg.rabi.amplitude.uniform.constant(duration=5.0, value=\"rabi_value\")\nprogram_with_assignments = program_with_rabi_values.batch_assign(\n    rabi_value=rabi_values\n)\n\n# get your results in one dataframe versus having to keep track of a\n# bunch of individual programs and their individual results\nbatch = program_with_assignments.bloqade.python().run(100)\nresults_dataframe = batch.report().dataframe\n</code></pre>"},{"location":"analog/quick_start/","title":"Quick start","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/quick_start/#quick-start","title":"Quick Start","text":"<p>All the sections below are self-contained, you can click on the links in the Table of Contents to read the relevant parts.</p>"},{"location":"analog/quick_start/#navigating-the-bloqade-api","title":"Navigating the Bloqade API","text":"<p>As you develop your Bloqade program, you are expected to rely on pop-up \"hints\" provided in your development environment to help you determine what the next part of your program should be.</p>"},{"location":"analog/quick_start/#vs-code","title":"VS Code","text":"<p>In VS Code this is automatic, just type the <code>.</code> and see what options pop up:</p> <p></p>"},{"location":"analog/quick_start/#jetbrains-pycharm","title":"JetBrains PyCharm","text":"<p>The same goes for JetBrains PyCharm:</p> <p></p>"},{"location":"analog/quick_start/#jupyter-notebook","title":"Jupyter Notebook","text":"<p>In a Jupyter Notebook you'll need to type <code>.</code> and then hit tab for the hints to appear:</p> <p></p>"},{"location":"analog/quick_start/#ipython","title":"IPython","text":"<p>The same goes for IPython:</p> <p></p>"},{"location":"analog/quick_start/#defining-atom-geometry","title":"Defining Atom Geometry","text":"<p>You can import pre-defined geometries based on Bravais lattices from <code>bloqade.atom_arrangement</code>. You may also specify a lattice spacing which dictates the spacing between the atoms as well as the number of atom sites in a certain direction.</p> <pre><code>from bloqade.atom_arrangement import Square, Kagome\n\nsimple_geometry = Square(2, 4, lattice_spacing = 4.0)\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\n</code></pre> <p>You can easily visualize your geometries as well with <code>.show()</code>:</p> <pre><code>more_complex_geometry.show()\n</code></pre> <p>You can also add positions to a pre-defined geometry:</p> <pre><code>from bloqade.atom_arrangement import Square\n\nbase_geometry = Square(2)\ngeometry_with_my_positions = base_geometry.add_position([(10,10), (20,20)])\n</code></pre> <p>As well as apply defects via <code>.apply_defect_density</code>. In the example below we apply a defect with a probability of 0.2:</p> <pre><code>from bloqade.atom_arrangement import Square, Kagome\n\nmore_complex_geometry = Kagome(2, 2, lattice_spacing = 2.0)\ndefective_geometry = more_complex_geometry.apply_defect_density(0.2)\n</code></pre> <p>Or if you want to completely roll out your own atom geometry from scratch just use <code>add_position</code> by itself:</p> <pre><code>from bloqade import start\n\nmy_geometry = start.add_position([(1,2), (3,4), (5,6)])\n</code></pre>"},{"location":"analog/quick_start/#building-waveforms","title":"Building Waveforms","text":"<p>After you've defined a geometry you:</p> <ul> <li>Specify which level coupling to drive: <code>rydberg</code> or <code>hyperfine</code></li> <li>Specify <code>detuning</code>, <code>rabi.amplitude</code> or <code>rabi.phase</code></li> <li>Specify the spatial modulation</li> </ul> <p>Which then leads you to the ability to specify a waveform of interest and begin constructing your pulse sequence. In the example below, we target the ground-Rydberg level coupling to drive with uniform spatial modulation for the Rabi amplitude. Our waveform is a piecewise linear one which ramps from \\(0\\) to \\(5 \\,\\text{rad/us}\\), holds that value for \\(1 \\,\\text{us}\\) and then ramps back down to \\(0 \\,\\text{rad/us}\\).</p> <pre><code>from bloqade import start\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nwaveform_applied = (\n    target_rabi_amplitude\n    .piecewise_linear(durations = [0.06, 1, 0.06], values = [0, 5, 5, 0])\n)\n</code></pre> <p>You aren't restricted to just piecewise linear waveforms however, you can also specify:</p> <ul> <li><code>linear</code> - Define a transition from one value to another over a duration</li> <li><code>constant</code> - Define a fixed value over a duration</li> <li><code>piecewise_constant</code> - Define a step-wise function with specific durations for each step</li> <li><code>poly</code> - Define a polynomial waveform using coefficients over a duration</li> </ul>"},{"location":"analog/quick_start/#arbitrary-functions-as-waveforms","title":"Arbitrary Functions as Waveforms","text":"<p>For more complex waveforms it may provide to be tedious trying to chain together a large number of <code>piecewise_constant</code> or <code>piecewise_linear</code> methods and instead easier to just define the waveform as a function of time.</p> <p>Bloqade lets you easily plug in an arbitrary function with <code>.fn</code>:</p> <pre><code>from bloqade import start\nfrom math import sin\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\n\ndef custom_waveform(t):\n    return 2.0 * sin(t)\n\ncustom_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n)\n</code></pre> <p>In this form you can immediately emulate it if you'd like but to run this on hardware you need to discretize it. The waveform on hardware has to either be:</p> <ul> <li>Piecewise linear for Rabi amplitude and detuning terms of the Hamiltonian</li> <li>Piecewise constant for the Phase term of the Hamiltonian</li> </ul> <p>Bloqade can automatically perform this conversion with <code>sample()</code>, all you need to do is specify the kind of interpolation and the size of the discretization step in time. Below we set the step duration to be \\(0.05 \\,\\text{us}\\) with <code>\"linear\"</code> interpolation to give us a resulting piecewise linear waveform.</p> <pre><code>custom_discretized_waveform_applied = (\n    target_rabi_amplitude\n    .fn(custom_waveform, duration = 3.0)\n    .sample(0.05, \"linear\")\n)\n</code></pre> <p>Note</p> <p>Programs that have custom functions as waveforms are not fully serializable. This means that when you are saving and reloading results, the original embedded program will be missing that custom waveform. You will still be able to analyze the saved results!</p>"},{"location":"analog/quick_start/#slicing-and-recording-waveforms","title":"Slicing and Recording Waveforms","text":"<p>When you conduct parameter sweeps with your program, you may want to sweep over your program across  time. This will require \"slicing\" your waveforms, where you define the waveform of interest and then, using a variable with <code>.slice</code>, indicate the times at which the waveform duration should be cut short.</p> <p>In the example below we define a simple piecewise linear waveform but slice it starting from a time duration of \\(0 \\,\\text{us}\\) to values between \\(1\\) to \\(2 \\,\\text{us}\\).</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre> <p>This program will run fine in emulation but due to hardware constraints certain waveforms (such as those targeting the Rabi Amplitude), the waveform needs to start and end at \\(0 \\,\\text{rad}/\\text{us}\\). Thus, there needs to be a way to slice our waveform but also add an end component to that waveform. <code>.record</code> in Bloqade lets you literally \"record\" the value at the end of a <code>.slice</code> and then use it to construct further parts of the waveform.</p> <p>In the program below the waveform is still sliced but with the help of <code>.record</code> a linear segment that pulls the waveform down to \\(0.0 \\,\\text{rad}/\\text{us}\\) from whatever its current value at the slice is in \\(0.7 \\,\\text{us}\\) is added.</p> <pre><code>from bloqade import start\nimport numpy as np\n\nsliced_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.5, 2.5, 0.5], values=[0, 3.0, 3.0, 0]\n    ).slice(start=0, stop=\"run_time\")\n    .record(\"waveform_value\")\n    .linear(\"rabi_value\", 0.0, 0.7)\n)\n\nrun_times = np.linspace(1.0, 2.0, 10)\nvars_assigned_program = sliced_program.batch_assign(run_time=run_times)\n</code></pre>"},{"location":"analog/quick_start/#waveforms-with-no-geometry","title":"Waveforms with No Geometry","text":"<p>If you have multiple atom geometries you'd like to apply a pulse sequence to or you simply don't want to worry about what atom geometry to start with, you can just build straight off of <code>start</code>:</p> <pre><code>from bloqade import start\n\npulse_sequence = (\n    start\n    .rydberg.rabi.amplitude.uniform\n    .constant(value=1.0, duration=1.0)\n    .parse_sequence()\n)\n</code></pre> <p>You can visualize your sequence as well with <code>.show()</code>:</p> <pre><code>pulse_sequence.show()\n</code></pre> <p></p> <p>And when you're content with it you just <code>.apply()</code> it on the geometries of your choice:</p> <pre><code>from bloqade.atom_arrangement import Honeycomb, Kagome\n\ngeometry_1 = Honeycomb(2, lattice_spacing = 6.0)\ngeometry_2 = Kagome(2, lattice_spacing = 6.0)\n\nprogram_1  = geometry_1.apply(pulse_sequence)\nprogram_2  = geometry_2.apply(pulse_sequence)\n</code></pre>"},{"location":"analog/quick_start/#emulation","title":"Emulation","text":"<p>When you've completed the definition of your program you can use Bloqade's own emulator to get results. The emulation performs the time evolution of the analog Rydberg Hamiltonian. Here we say we want to the program to be run and measurements obtained 1000 times.</p> <pre><code>results = your_program.bloqade.python().run(1000)\n</code></pre> <p>Note</p> <p>If your atoms are particularly close together or the ODE solver gives you the following message:</p> <pre><code>RuntimeError: DOP853/DOPRI5: Problem is probably stiff (interrupted).\n</code></pre> <p>In which case you will need to specify the <code>interaction_picture=True</code> argument:</p> <pre><code>results = your_program.bloqade.python().run(1000, interaction_picture=True)\n</code></pre>"},{"location":"analog/quick_start/#submitting-to-hardware","title":"Submitting to Hardware","text":"<p>To submit your program to hardware ensure you have your AWS Braket credentials loaded. You will need to use the AWS CLI to do this.</p> <p>Then it's just a matter of selecting the Aquila on Braket backend. Before going any further Bloqade provides two options for running your program on actual hardware:</p> <ul> <li>Using <code>.run</code> is blocking, meaning you will not be able to execute anything else while Bloqade waits for results</li> <li>Using <code>.run_async</code> lets you submit to hardware and continue any further execution, while also letting you query the status of your program in the queue.</li> </ul> <p>In the example below we use <code>.run_async</code> to specify the program should be run and measurements obtained 1000 times.</p> <pre><code>async_results = your_program.braket.aquila().run_async(1000)\n</code></pre> <p>We can see the status of our program via:</p> <p><pre><code>async_results.fetch()\n</code></pre> Which gives us the Task ID, a unique identifier for the task as well as the status of the task. In the example below the task is <code>Enqueued</code> meaning it has been successfully created and is awaiting execution on the cloud. When the task is actually running on hardware, the status will change to <code>Running</code>. <pre><code>                                             task ID    status  shots\n0  arn:aws:braket:us-east-1:XXXXXXXXXXXX:quantum-...  Enqueued    100\n</code></pre></p>"},{"location":"analog/quick_start/#analyzing-results","title":"Analyzing Results","text":"<p>When you've retrieved your results from either emulation or hardware you can generate a <code>.report()</code>:</p> <pre><code>report = results.report()\n</code></pre> <p>For the examples below we analyze the results of a two atom program.</p> <p>The report contains useful information such as:</p> <ul> <li> <p>The raw bitstrings measured per each execution of the program <pre><code>report.bitstrings()\n</code></pre> <pre><code>[array([[1, 1],\n        [1, 1],\n        [1, 1],\n        ...,\n        [1, 1],\n        [1, 1],\n        [1, 0]], dtype=int8)]\n</code></pre></p> </li> <li> <p>The number of times each unique bitstring occurred: <pre><code>report.counts()\n</code></pre> <pre><code>[OrderedDict([('11', 892), ('10', 59), ('01', 49)])]\n</code></pre></p> </li> <li> <p>The Rydberg Density for each atom <pre><code>report.rydberg_densities()\n</code></pre> <pre><code>                 0      1\ntask_number\n0            0.053  0.054\n</code></pre></p> </li> </ul> <p>And can also provide useful visual information such as the state of your atoms and the bitstring distribution via:</p> <pre><code>report.show()\n</code></pre> <p></p>"},{"location":"analog/quick_start/#parameter-sweeps","title":"Parameter Sweeps","text":"<p>You can easily do parameter sweeps in emulation and on Aquila with variables. Bloqade automatically detects strings in your program as variables that you can later assign singular or multiple values to.</p> <p>In the example below, we define a program with a singular variable that controls the amplitude of the waveform.</p> <pre><code>from bloqade import start\n\nrabi_oscillations_program = (\n    start.add_position((0, 0))\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=[0.06, 3, 0.06],\n        values=[0, \"rabi_amplitude\", \"rabi_amplitude\", 0]\n    )\n)\n</code></pre> <p>We can assign a single fixed value to the variable:</p> <pre><code>single_value_assignment = rabi_oscillations_program.assign(rabi_amplitude=3.5)\n</code></pre> <p>Or, to perform a sweep, we use <code>.batch_assign</code>:</p> <pre><code>import numpy as np\nrabi_amplitudes = np.linspace(1.0, 2.0, 20)\n\nmultiple_value_assignment = rabi_oscillations_program.batch_assign(rabi_amplitude=rabi_amplitudes)\n</code></pre> <p>This will actually create multiple versions of the program internally, with each program assigned a fixed value from the sweep. Bloqade will automatically handle the compilation of results from these multiple programs in order, meaning there is no major departure from what you saw in analyzing the results of your program.</p> <p>You can also delay assignment of a value to a variable by first declaring it in <code>.args()</code> and then passing a value when you call <code>run</code>:</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\nresults = delayed_assignment_program.bloqade.python().run(100, args=(1.0,))\n</code></pre> <p>You can alternatively treat the program as a callable after using <code>.args()</code> (note the inverted order of arguments in the call!):</p> <pre><code>delayed_assignment_program = rabi_oscillations_program.args([\"rabi_amplitude\"])\ncallable_program = delayed_assignment_program.bloqade.python()\nresults = callable_program(1.0, shots=100)\n</code></pre> <p>Variables aren't just restricted to having values assigned to them, you can also symbolically manipulate them!</p>"},{"location":"analog/quick_start/#symbolic-parameters","title":"Symbolic Parameters","text":"<p>Variables in Bloqade can also be symbolically manipulated, giving you even more flexibility when you construct your program.</p> <p>In the example below, we externally declare a variable <code>my_var</code> that then has some arithmetic done on it to allow it to have a different value in a later part of the program:</p> <pre><code>from bloqade import start, var\n\nmy_var = var(\"my_variable\")\nwaveform_durations = [0.6, 1.0, 0.6]\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=waveform_durations,\n                      values=[0.0, my_var, my_var, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .piecewise_linear(durations=waveform_durations,\n                      values=[my_var-1.0, my_var*0.5, my_var/2, my_var+1.0 ])\n)\n</code></pre> <p>You still perform variable assignment just like you normally would:</p> <pre><code>program = detuning_waveform.assign(my_variable=1.0)\n</code></pre> <p>You can also use Python's built-in <code>sum</code> if you want the sum of multiple variables as a value in your program. This is quite useful when it comes to needing to indicate a full duration for a waveform that doesn't need to be split up:</p> <p><pre><code>from bloqade import start, var\n\nvariable_durations = var([\"a\", \"b\", \"c\"])\n\ngeometry = start.add_position((0,0))\ntarget_rabi_amplitude = geometry.rydberg.rabi.amplitude.uniform\nrabi_waveform = (\n    target_rabi_amplitude\n    .piecewise_linear(durations=variable_durations,\n                      values=[0.0, 1.5, 1.5, 0.0])\n)\ntarget_detuning = rabi_waveform.detuning.uniform\ndetuning_waveform = (\n    target_detuning\n    .constant(duration=sum(variable_durations),\n              value=16.2)\n)\n</code></pre> We later assign values and Bloqade will automatically handle the summation:</p> <pre><code>program = detuning_waveform.assign(a=0.5, b=1.2, c=0.5)\n</code></pre>"},{"location":"analog/quick_start/#saving-and-loading-results","title":"Saving and Loading Results","text":"<p>You can save your results in JSON format using Bloqade's <code>save</code> function:</p> <pre><code>from bloqade import start, save\n\nyour_program = ...\nemulation_results = your_program.bloqade.python().run(100)\nhardware_results = your_program.braket.aquila.run_async(100)\n\nsave(emulation_results, \"emulation_results.json\")\nsave(hardware_results, \"hardware_results.json\")\n</code></pre> <p>And later reload them into Python using the <code>load</code> function:</p> <pre><code>from bloqade import load\nemulation_results = load(\"emulation_results.json\")\nhardware_results = load(\"hardware_results.json\")\n</code></pre>"},{"location":"analog/submission/","title":"Submission","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/visualization/","title":"Visualization","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"analog/waveforms/","title":"Waveforms","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/","title":"Introducing Bloqade SDK for Python","text":"<p>Greetings Neutral Atom QC experts, enthusiasts, and newcomers!</p> <p>We are excited to the Rydberg state thrilled to announce the Python version of our cutting-edge SDK, Bloqade. Originally developed in Julia, Bloqade has been a game-changer in the realm of Neutral Atom quantum computing. With the introduction of the Python version, we aim to make this revolutionary technology more accessible and user-friendly than ever before.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-python","title":"Why Python?","text":"<p>Python is one of the most widely used programming languages, especially in the quantum computing community and broader scientific communities. By extending Bloqade to Python, we are opening doors to a broader audience, enabling more developers, researchers, and organizations to harness the power of Neutral Atom quantum computing.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#neutral-atom-quantum-computing","title":"Neutral Atom Quantum Computing","text":"<p>Recently, the Neutral Atom platform has come on the QC scene in the form of Analog Hamiltonian Simulators that have a broad set of use cases beyond quantum circuits. Ranging from simulating unique quantum phases of matter, solving combinatorial optimization problems, and machine learning applications, the analog mode provides strong values in solving practical, interesting problems in the near term.</p> <p>These advances are crucial milestones on the way towards scalable digital gate-based architecture using atom shuttling. This new technology and its novel applications demand a paradigm shift in the way we not only think about quantum computing, but translate those ideas to real hardware. Enter Bloqade, a next-generation SDK designed to put the power of neutral atoms at your fingertips.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#why-bloqade","title":"Why Bloqade?","text":"<p>Bloqade is designed with the primary goal of making it easier to compose programs for QuEra\u2019s hardware and analyze results.</p> <p>We've gained valuable insights into how users have used our neutral-atom hardware and with it, their struggles with existing tools. We took advantage of this knowledge to produce a tool that could take the \"hard\" out of \"hardware\". Bloqade is precision-balanced in both flexibility to empower novices to experiment with ease and power to let experts perform cutting-edge work without breaking a sweat.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#highlights","title":"Highlights","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#smart-documentation","title":"Smart Documentation","text":"<p>With our commitment to enabling more seamless program development, we've put the relevant documentation you need right where and when you need it.</p> <p>No more obnoxious switching between your favorite coding environment and documentation in a separate window. Let Bloqade guide you where you'd like to go:</p> <p></p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#fully-parameterized-analog-programs","title":"Fully Parameterized Analog Programs","text":"<p>Parameter sweeps are a common theme of programs for analog quantum computers, where a user would like to observe differences in output results by varying a value or values in their program.</p> <p>You used to have to manually crank out variations of your program with different values and then keep track of all the individual submissions to the emulator and hardware, a mess to keep track of and process the results of afterwards.</p> <p>Bloqade eliminates this with its own support for variables that can later be assigned single values or a whole sequence of values for trivial parameter sweeping. This isn't some feature that's constrained to a certain backend, you can take your program with all its variables and submit it to your choice of emulator or our hardware directly.</p> <pre><code>from bloqade import var\nfrom bloqade.atom_arrangement import Square\n\nimport numpy as np\n\nadiabatic_durations = [0.4, 3.2, 0.4]\n\n# create variables explicitly...\nmax_detuning = var(\"max_detuning\")\n# ...or implicitly inside the program definition.\nadiabatic_program = (\n    Square(3, \"lattice_spacing\")\n    .rydberg.rabi.amplitude.uniform.piecewise_linear(\n        durations=adiabatic_durations, values=[0.0, \"max_rabi\", \"max_rabi\", 0.0]\n    )\n    .detuning.uniform.piecewise_linear(\n        durations=adiabatic_durations,\n        values=[\n            -max_detuning, # scalar variables support direct arithmetic operations\n            -max_detuning,\n            max_detuning,\n            max_detuning,\n        ],\n    )\n    .assign(max_rabi=15.8, max_detuning=16.33)\n    .batch_assign(lattice_spacing=np.arrange(4.0, 7.0, 0.5))\n)\n\n# Launch your program on your choice of Braket or in-house emulator...\nemu_results = adiabatic_program.braket.local_emulator().run(10000)\nfaster_emu_results = adiabatic_program.bloqade.python().run(10000)\n# ...as well as hardware without stress\nhw_results = adiabatic_program.parallelize(24).braket.aquila().run_async(100)\n</code></pre>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#integrated-visualization-tools","title":"Integrated Visualization Tools","text":"<p>Instantly understand what your programs are doing faster than you can say \"neutral atoms rock!\" with Bloqade's built-in visualization tools:</p> <p></p> <p></p> <p>For your results, no more obnoxious manual compilation of results across different parameters or wrangling them into more useful forms. Get insights of experiment outcomes in the blink of an eye:</p> <p></p> <p></p> <p>Now that's what we call having your cake AND eating it.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-roadmap","title":"Bloqade Roadmap","text":""},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#bloqade-alpha-phase","title":"Bloqade Alpha Phase","text":"<p>During the next year, we plan on continuing development of Bloqade's python interface. If you are as excited about Neutral Atom quantum computing as us, or heck, even just quantum physics in general, give Bloqade a try! This is your opportunity to influence the direction of Bloqade and get in on the ground floor of the next Quantum Computing revolution.</p>"},{"location":"blog/2023/12/15/introducing-bloqade-sdk-for-python/#but-what-about-julia","title":"But what about Julia?","text":"<p>Don't you guys already HAVE an SDK in Julia? Why do you need two SDKs?</p> <p>That's right! However, there's a key motivating factor for the reason we created Bloqade Python that's distinct for Bloqade.jl's existence.</p> <p>Bloqade.jl is primarily geared as a high-performance emulator. It allows you to design complex neutral-atom algorithms that may not necessarily run on our hardware BUT are excellent if you're exploring novel physical phenonema/algorithms or as a tool for pedagogical purposes.</p> <p>Bloqade.jl does have the ability to submit to Aquila, our flagship quantum computer, but for more complex tasks such as sweeping parameters (e.g. running the same program on hardware with slightly different parameters each time) or advanced post-processing, it becomes cumbersome quite quickly.</p> <p>There are no plans to drop support any time soon though. On the contrary, we plan on fully integrating Bloqade.jl into the Python package, which will enable you to program Neutral Atom quantum hardware without having to choose.</p> <p>We very much look forward to you trying out Bloqade!</p>"},{"location":"blog/2025/02/15/a-new-journey-of-bloqade/","title":"A New Journey of Bloqade","text":""},{"location":"digital/","title":"Index","text":"<p>Warning</p> <p>This page is under construction. The content may be incomplete or incorrect. Submit an issue on GitHub if you need help or want to contribute.</p>"},{"location":"digital/examples/ghz/","title":"GHZ State Preparation with Parallelism.","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade import qasm2\nfrom kirin.dialects import ilist\n</pre> import math  from bloqade import qasm2 from kirin.dialects import ilist In\u00a0[\u00a0]: Copied! <pre>def ghz_linear(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def ghz_linear_program():\n\n        qreg = qasm2.qreg(n_qubits)\n        qasm2.h(qreg[0])\n        for i in range(1, n_qubits):\n            qasm2.cx(qreg[i - 1], qreg[i])\n\n    return ghz_linear_program\n</pre> def ghz_linear(n: int):     n_qubits = int(2**n)      @qasm2.extended     def ghz_linear_program():          qreg = qasm2.qreg(n_qubits)         qasm2.h(qreg[0])         for i in range(1, n_qubits):             qasm2.cx(qreg[i - 1], qreg[i])      return ghz_linear_program In\u00a0[\u00a0]: Copied! <pre>def ghz_log_depth(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n        for j in range(0, n_qubits, step):\n            qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_depth(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)         for j in range(0, n_qubits, step):             qasm2.cx(ctrl=qreg[j], qarg=qreg[j + step // 2])      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer(i_layer=i, qreg=qreg)      return ghz_log_depth_program In\u00a0[\u00a0]: Copied! <pre>def ghz_log_simd(n: int):\n    n_qubits = int(2**n)\n\n    @qasm2.extended\n    def layer(i_layer: int, qreg: qasm2.QReg):\n        step = n_qubits // (2**i_layer)\n\n        def get_qubit(x: int):\n            return qreg[x]\n\n        ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))\n        targ_qubits = ilist.Map(\n            fn=get_qubit, collection=range(step // 2, n_qubits, step)\n        )\n\n        # Ry(-pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)\n\n        # CZ gates\n        qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)\n\n        # Ry(pi/2)\n        qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)\n\n    @qasm2.extended\n    def ghz_log_depth_program():\n\n        qreg = qasm2.qreg(n_qubits)\n\n        qasm2.h(qreg[0])\n        for i in range(n):\n            layer(i_layer=i, qreg=qreg)\n\n    return ghz_log_depth_program\n</pre> def ghz_log_simd(n: int):     n_qubits = int(2**n)      @qasm2.extended     def layer(i_layer: int, qreg: qasm2.QReg):         step = n_qubits // (2**i_layer)          def get_qubit(x: int):             return qreg[x]          ctrl_qubits = ilist.Map(fn=get_qubit, collection=range(0, n_qubits, step))         targ_qubits = ilist.Map(             fn=get_qubit, collection=range(step // 2, n_qubits, step)         )          # Ry(-pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=-math.pi / 2, phi=0.0, lam=0.0)          # CZ gates         qasm2.parallel.cz(ctrls=ctrl_qubits, qargs=targ_qubits)          # Ry(pi/2)         qasm2.parallel.u(qargs=targ_qubits, theta=math.pi / 2, phi=0.0, lam=0.0)      @qasm2.extended     def ghz_log_depth_program():          qreg = qasm2.qreg(n_qubits)          qasm2.h(qreg[0])         for i in range(n):             layer(i_layer=i, qreg=qreg)      return ghz_log_depth_program <p>Note on using closure to capture global variable: Since qasm2 does not allow main program with arguments, so we need to put the program in a closure. our kirin compiler toolchain can capture the global variable inside the closure. In this case, the n_qubits will be captured upon calling the <code>ghz_half_simd(n_qubits)</code> python function, As a result, the return qasm2 program will not have any arguments.</p>"},{"location":"digital/examples/ghz/#ghz-state-preparation-with-parallelism","title":"GHZ State Preparation with Parallelism.\u00b6","text":"<p>In this example, we will consider the GHZ state preparation circuit with 2^n qubits</p>"},{"location":"digital/examples/ghz/#simple-linear-depth-impl-of-ghz-state-prep","title":"Simple linear depth impl of ghz state prep\u00b6","text":"<p>A simple GHZ state preparation circuit can be done with N CX gates and 1 H gate. This gives circuit execution depth of N+1.</p>"},{"location":"digital/examples/ghz/#log-depth-impl-of-ghz-state-prep","title":"log depth impl of ghz state prep\u00b6","text":"<p>Let's take a look how we can rewrite the circuit toward more QuEra's hardware friendly circuit. We can rewrite the GHZ state preparation circuit with log(N) depth by rearranging the CX gates [citation](https://arxiv.org/abs/2101.08946 \u2013 Mooney, White, Hill, Hollenberg)</p> <p>Note it is important to separate the concept of circuit depth and circuit execution depth. For example, in the following implementation, each CX gate instruction inside the for loop are executed in sequence. So even thought the circuit depth is N/2 + 1. The circuit execution depth is still N + 1.</p>"},{"location":"digital/examples/ghz/#native-gate-set-and-parallelism","title":"Native gate set and parallelism\u00b6","text":"<p>On our digital quantum computer, by nature can execute native gate in parallel in an single instruction/ execution cycle. The concept is very similar to the SIMD (Single Instruction, Multiple Data) in classical computing. On our hardware, there are two important factor to be consider:</p> <ol> <li>the native gate set is arbitrary (parallel) rotations and (parallel) CZ gates.</li> <li>Our atom shuttling architecture allows arbitrary qubit connectivity. This means that our parallel instruction is not limited to certain hardware connectivity (for example nearest neighbor connectivity).</li> </ol> <p>Let's try to rewrite the <code>layer</code> subroutinme. We know that the CX gate can be decomposed into CZ gate with two single qubit gates Ry(-pi/2) and Ry(pi/2) acting on the target qubits. After such decomposition, we can now using our parallel gate instructions <code>parallel.u</code> and <code>parallel.cz</code>. With the following modification, we can further reduce the circuit execution depth to n (log of total qubit number N)</p>"},{"location":"digital/examples/qft/","title":"Quantum Fourier Transform","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n\nfrom bloqade import qasm2\nfrom bloqade.pyqrack import PyQrack\n\n\n# In the following, we will define the Quantum Fourier Transform (QFT) circuit using recursion\n# inside a kernel function `qft`. The `qft` function takes two arguments: a quantum register `qreg`\n# and an integer `n` representing the number of qubits we want to apply the QFT circuit to.\n</pre> import math  from bloqade import qasm2 from bloqade.pyqrack import PyQrack   # In the following, we will define the Quantum Fourier Transform (QFT) circuit using recursion # inside a kernel function `qft`. The `qft` function takes two arguments: a quantum register `qreg` # and an integer `n` representing the number of qubits we want to apply the QFT circuit to. In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef qft(qreg: qasm2.QReg, n: int):\n    if n == 0:\n        return qreg\n\n    qasm2.h(qreg[0])\n    for i in range(1, n):\n        qasm2.cu1(qreg[i], qreg[0], 2 * math.pi / 2**i)\n    qft(qreg, n - 1)\n    return qreg\n</pre> @qasm2.extended def qft(qreg: qasm2.QReg, n: int):     if n == 0:         return qreg      qasm2.h(qreg[0])     for i in range(1, n):         qasm2.cu1(qreg[i], qreg[0], 2 * math.pi / 2**i)     qft(qreg, n - 1)     return qreg <p>Next, we will call this kernel function <code>qft</code> inside a <code>main</code> function to check if the QFT circuit is correctly implemented. We will use a quantum register of size 3.</p> In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef main():\n    return qft(qasm2.qreg(3), 3)\n</pre> @qasm2.extended def main():     return qft(qasm2.qreg(3), 3) <p>Finally, we will run the <code>main</code> function on the <code>PyQrack</code> backend and print the quantum register to see the final state of the qubits after applying the QFT circuit.</p> In\u00a0[\u00a0]: Copied! <pre>device = PyQrack()\nqreg = device.run(main)\nprint(qreg)\n</pre> device = PyQrack() qreg = device.run(main) print(qreg)"},{"location":"digital/examples/qft/#quantum-fourier-transform","title":"Quantum Fourier Transform\u00b6","text":"<p>In this example, we will explore the Quantum Fourier Transform (QFT) circuit using recursion and iteration -- a convenient way to implement the QFT circuit using our high-level programming features.</p> <p>To begin, we will import the <code>qasm2</code> module from the <code>bloqade</code> package and the <code>PyQrack</code> backend from the <code>bloqade.pyqrack</code> module, which can be installed via</p> <pre>pip install bloqade[pyqrack]\n</pre> <p>or</p> <pre>pip install bloqade[pyqrack-cpu]\n</pre> <p>depending on the hardware and OS you have.</p>"},{"location":"digital/examples/repeat_until_success/","title":"Repeat until success","text":"In\u00a0[\u00a0]: Copied! <pre>import math\n</pre> import math In\u00a0[\u00a0]: Copied! <pre>from bloqade import qasm2\nfrom kirin.dialects import ilist\n</pre> from bloqade import qasm2 from kirin.dialects import ilist In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef prep_magic_state(theta: float)-&gt;qasm2.types.QReg:\n    qreg = qasm2.qreg(1)\n    qasm2.rz(qreg[0], theta)\n    return qreg\n</pre> @qasm2.extended def prep_magic_state(theta: float)-&gt;qasm2.types.QReg:     qreg = qasm2.qreg(1)     qasm2.rz(qreg[0], theta)     return qreg In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef star_gadget_recursive(reg, theta)-&gt;qasm2.types.QReg:\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    ancilla = prep_magic_state(theta)\n    qasm2.cx(ancilla[0], reg[0])\n    creg = qasm2.creg(1)\n    qasm2.measure(reg[0], creg[0])\n    if creg[0] == 1:\n        # qasm2.deallocate(reg)\n        return ancilla\n    else:\n        qasm2.x(ancilla[0])\n        return star_gadget_recursive(ancilla, 2*theta)\n</pre> @qasm2.extended def star_gadget_recursive(reg, theta)-&gt;qasm2.types.QReg:     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     ancilla = prep_magic_state(theta)     qasm2.cx(ancilla[0], reg[0])     creg = qasm2.creg(1)     qasm2.measure(reg[0], creg[0])     if creg[0] == 1:         # qasm2.deallocate(reg)         return ancilla     else:         qasm2.x(ancilla[0])         return star_gadget_recursive(ancilla, 2*theta) In\u00a0[\u00a0]: Copied! <pre>@qasm2.extended\ndef star_gadget_loop(reg:qasm2.types.QReg, theta:float,depth:int=100)-&gt;qasm2.types.QReg:\n    \"\"\"\n    https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7\n    \"\"\"\n    creg = qasm2.creg(1)\n    \n    for ctr in range(depth):\n        ancilla = prep_magic_state(theta*(2**ctr))\n        qasm2.cx(ancilla[0], reg[0])\n        qasm2.measure(reg[0], creg[0])\n        if creg[0] == 1:\n            return ancilla\n        else:\n            qasm2.x(ancilla[0])\n            reg = ancilla\n    raise RuntimeError(\"Did not converge\")\n</pre> @qasm2.extended def star_gadget_loop(reg:qasm2.types.QReg, theta:float,depth:int=100)-&gt;qasm2.types.QReg:     \"\"\"     https://journals.aps.org/prxquantum/pdf/10.1103/PRXQuantum.5.010337 Fig. 7     \"\"\"     creg = qasm2.creg(1)          for ctr in range(depth):         ancilla = prep_magic_state(theta*(2**ctr))         qasm2.cx(ancilla[0], reg[0])         qasm2.measure(reg[0], creg[0])         if creg[0] == 1:             return ancilla         else:             qasm2.x(ancilla[0])             reg = ancilla     raise RuntimeError(\"Did not converge\") In\u00a0[\u00a0]: Copied! <pre>\n</pre> In\u00a0[\u00a0]: Copied! <pre>star_gadget_recursive.print()\n</pre> star_gadget_recursive.print()"},{"location":"reference/bloqade/types/","title":"Types","text":"<p>Bloqade types.</p> <p>This module defines the basic types used in Bloqade eDSLs.</p>"},{"location":"reference/bloqade/types/#bloqade.types.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade/types/#bloqade.types.Qubit","title":"Qubit","text":"<p>               Bases: <code>ABC</code></p> <p>Runtime representation of a qubit.</p> Note <p>This is the base class of more specific qubit types, such as a reference to a piece of quantum register in some quantum register dialects.</p>"},{"location":"reference/bloqade/analysis/","title":"Index","text":""},{"location":"reference/bloqade/analysis/address/","title":"Index","text":""},{"location":"reference/bloqade/analysis/address/analysis/","title":"Analysis","text":""},{"location":"reference/bloqade/analysis/address/impls/","title":"Impls","text":"<p>qubit.address method table for a few builtin dialects.</p>"},{"location":"reference/bloqade/analysis/address/lattice/","title":"Lattice","text":""},{"location":"reference/bloqade/noise/","title":"Index","text":""},{"location":"reference/bloqade/noise/native/","title":"Index","text":""},{"location":"reference/bloqade/noise/native/rewrite/","title":"Rewrite","text":""},{"location":"reference/bloqade/noise/native/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/glob/","title":"Glob","text":"<p>QASM2 extension for global gates.</p>"},{"location":"reference/bloqade/qasm2/groups/","title":"Groups","text":""},{"location":"reference/bloqade/qasm2/parallel/","title":"Parallel","text":"<p>QASM2 extension for parallel execution of gates.</p>"},{"location":"reference/bloqade/qasm2/types/","title":"Types","text":""},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.BitType","title":"BitType  <code>module-attribute</code>","text":"<pre><code>BitType = PyClass(Bit)\n</code></pre> <p>Kirin type for a classical bit.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.CRegType","title":"CRegType  <code>module-attribute</code>","text":"<pre><code>CRegType = PyClass(CReg)\n</code></pre> <p>Kirin type for a classical register.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.QRegType","title":"QRegType  <code>module-attribute</code>","text":"<pre><code>QRegType = PyClass(QReg)\n</code></pre> <p>Kirin type for a quantum register.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.Bit","title":"Bit","text":"<p>Runtime representation of a bit.</p> Note <p>This is the base class of more specific bit types, such as a reference to a piece of classical register in some quantum register dialects.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.CReg","title":"CReg","text":"<p>Runtime representation of a classical register.</p>"},{"location":"reference/bloqade/qasm2/types/#bloqade.qasm2.types.QReg","title":"QReg","text":"<p>Runtime representation of a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/glob/","title":"Glob","text":""},{"location":"reference/bloqade/qasm2/dialects/indexing/","title":"Indexing","text":"<p>This dialect provides the indexing syntax in Python lowering for QASM2 dialects. The dialect itself does not contain new statements.</p> <p>Using this dialect will be conflict with Python semantics provided by <code>kirin.dialects.py.binop</code> and <code>kirin.dialects.py.indexing</code> dialects.</p>"},{"location":"reference/bloqade/qasm2/dialects/inline/","title":"Inline","text":"<p>Inline QASM dialect.</p> <p>This dialect allows users to use QASM string as part of a <code>@qasm2.main</code> kernel.</p>"},{"location":"reference/bloqade/qasm2/dialects/noise/","title":"Noise","text":""},{"location":"reference/bloqade/qasm2/dialects/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/qasm2/dialects/core/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.BitType","title":"BitType  <code>module-attribute</code>","text":"<pre><code>BitType = PyClass(Bit)\n</code></pre> <p>Kirin type for a classical bit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegType","title":"CRegType  <code>module-attribute</code>","text":"<pre><code>CRegType = PyClass(CReg)\n</code></pre> <p>Kirin type for a classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegType","title":"QRegType  <code>module-attribute</code>","text":"<pre><code>QRegType = PyClass(QReg)\n</code></pre> <p>Kirin type for a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq","title":"CRegEq","text":"<p>               Bases: <code>Statement</code></p> <p>Check if two classical registers are equal.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>lhs (CReg): The first register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (bool): True if the registers are equal, False otherwise.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegEq.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>rhs (CReg): The second register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet","title":"CRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a bit from a classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the bit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(CRegType)\n</code></pre> <p>reg (CReg): The classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(BitType)\n</code></pre> <p>result (Bit): The bit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegNew","title":"CRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegNew.n_bits","title":"n_bits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_bits: SSAValue = argument(Int)\n</code></pre> <p>n_bits (Int): The number of bits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.CRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(CRegType)\n</code></pre> <p>result (CReg): The new classical register with all bits set to 0.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Measure","title":"Measure","text":"<p>               Bases: <code>Statement</code></p> <p>Measure a qubit and store the result in a bit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Measure.carg","title":"carg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carg: SSAValue = argument(BitType)\n</code></pre> <p>carg (Bit): The bit to store the result in.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Measure.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to measure.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet","title":"QRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a qubit from a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the qubit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(QRegType)\n</code></pre> <p>reg (QReg): The quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QubitType)\n</code></pre> <p>result (Qubit): The qubit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegNew","title":"QRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegNew.n_qubits","title":"n_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_qubits: SSAValue = argument(Int)\n</code></pre> <p>n_qubits: The number of qubits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.QRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QRegType)\n</code></pre> <p>A new quantum register with n_qubits set to |0&gt;.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Reset","title":"Reset","text":"<p>               Bases: <code>Statement</code></p> <p>Reset a qubit to the |0&gt; state.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/#bloqade.qasm2.dialects.core.Reset.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to reset.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/address/","title":"Address","text":""},{"location":"reference/bloqade/qasm2/dialects/core/emit/","title":"Emit","text":""},{"location":"reference/bloqade/qasm2/dialects/core/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq","title":"CRegEq","text":"<p>               Bases: <code>Statement</code></p> <p>Check if two classical registers are equal.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>lhs (CReg): The first register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (bool): True if the registers are equal, False otherwise.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegEq.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(Int | CRegType | BitType)\n</code></pre> <p>rhs (CReg): The second register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet","title":"CRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a bit from a classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the bit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(CRegType)\n</code></pre> <p>reg (CReg): The classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(BitType)\n</code></pre> <p>result (Bit): The bit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew","title":"CRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new classical register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew.n_bits","title":"n_bits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_bits: SSAValue = argument(Int)\n</code></pre> <p>n_bits (Int): The number of bits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.CRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(CRegType)\n</code></pre> <p>result (CReg): The new classical register with all bits set to 0.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure","title":"Measure","text":"<p>               Bases: <code>Statement</code></p> <p>Measure a qubit and store the result in a bit.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure.carg","title":"carg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>carg: SSAValue = argument(BitType)\n</code></pre> <p>carg (Bit): The bit to store the result in.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Measure.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to measure.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet","title":"QRegGet","text":"<p>               Bases: <code>Statement</code></p> <p>Get a qubit from a quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.idx","title":"idx  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>idx: SSAValue = argument(Int)\n</code></pre> <p>idx (Int): The index of the qubit in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.reg","title":"reg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>reg: SSAValue = argument(QRegType)\n</code></pre> <p>reg (QReg): The quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegGet.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QubitType)\n</code></pre> <p>result (Qubit): The qubit at position <code>idx</code>.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew","title":"QRegNew","text":"<p>               Bases: <code>Statement</code></p> <p>Create a new quantum register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew.n_qubits","title":"n_qubits  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>n_qubits: SSAValue = argument(Int)\n</code></pre> <p>n_qubits: The number of qubits in the register.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.QRegNew.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(QRegType)\n</code></pre> <p>A new quantum register with n_qubits set to |0&gt;.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Reset","title":"Reset","text":"<p>               Bases: <code>Statement</code></p> <p>Reset a qubit to the |0&gt; state.</p>"},{"location":"reference/bloqade/qasm2/dialects/core/stmts/#bloqade.qasm2.dialects.core.stmts.Reset.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit to reset.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add","title":"Add","text":"<p>               Bases: <code>Statement</code></p> <p>Add two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Add.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int, property=True)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstPI","title":"ConstPI","text":"<p>               Bases: <code>Statement</code></p> <p>The constant value of PI.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.ConstPI.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (ConstPI): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Cos","title":"Cos","text":"<p>               Bases: <code>Statement</code></p> <p>Take the cosine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Cos.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The cosine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Cos.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the cosine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div","title":"Div","text":"<p>               Bases: <code>Statement</code></p> <p>Divide two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The numerator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the division.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Div.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The denominator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Exp","title":"Exp","text":"<p>               Bases: <code>Statement</code></p> <p>Take the exponential of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Exp.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The exponential of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Exp.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the exponential of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Log","title":"Log","text":"<p>               Bases: <code>Statement</code></p> <p>Take the natural log of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Log.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The natural log of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Log.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the natural log of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul","title":"Mul","text":"<p>               Bases: <code>Statement</code></p> <p>Multiply two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Mul.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>Negate a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Neg.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The negated number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Neg.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to negate.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow","title":"Pow","text":"<p>               Bases: <code>Statement</code></p> <p>Take the power of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The base.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the power operation.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Pow.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The exponent.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sin","title":"Sin","text":"<p>               Bases: <code>Statement</code></p> <p>Take the sine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sin.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The sine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sin.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the sine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sqrt","title":"Sqrt","text":"<p>               Bases: <code>Statement</code></p> <p>Take the square root of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sqrt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The square root of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sqrt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the square root of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub","title":"Sub","text":"<p>               Bases: <code>Statement</code></p> <p>Subtract two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Sub.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Tan","title":"Tan","text":"<p>               Bases: <code>Statement</code></p> <p>Take the tangent of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Tan.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The tangent of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/#bloqade.qasm2.dialects.expr.Tan.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the tangent of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/emit/","title":"Emit","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/interp/","title":"Interp","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add","title":"Add","text":"<p>               Bases: <code>Statement</code></p> <p>Add two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Add.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the addition.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int, property=True)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstPI","title":"ConstPI","text":"<p>               Bases: <code>Statement</code></p> <p>The constant value of PI.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.ConstPI.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (ConstPI): The result value.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos","title":"Cos","text":"<p>               Bases: <code>Statement</code></p> <p>Take the cosine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The cosine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Cos.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the cosine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div","title":"Div","text":"<p>               Bases: <code>Statement</code></p> <p>Divide two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The numerator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the division.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Div.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The denominator.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp","title":"Exp","text":"<p>               Bases: <code>Statement</code></p> <p>Take the exponential of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The exponential of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Exp.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the exponential of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log","title":"Log","text":"<p>               Bases: <code>Statement</code></p> <p>Take the natural log of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The natural log of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Log.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the natural log of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul","title":"Mul","text":"<p>               Bases: <code>Statement</code></p> <p>Multiply two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Mul.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the multiplication.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>Negate a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The negated number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Neg.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to negate.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow","title":"Pow","text":"<p>               Bases: <code>Statement</code></p> <p>Take the power of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The base.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the power operation.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Pow.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The exponent.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin","title":"Sin","text":"<p>               Bases: <code>Statement</code></p> <p>Take the sine of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The sine of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sin.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the sine of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt","title":"Sqrt","text":"<p>               Bases: <code>Statement</code></p> <p>Take the square root of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The square root of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sqrt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the square root of.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub","title":"Sub","text":"<p>               Bases: <code>Statement</code></p> <p>Subtract two numbers.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.lhs","title":"lhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lhs: SSAValue = argument(PyNum)\n</code></pre> <p>lhs (Union[int, float]): The left-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (Union[int, float]): The result of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Sub.rhs","title":"rhs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>rhs: SSAValue = argument(PyNum)\n</code></pre> <p>rhs (Union[int, float]): The right-hand side of the subtraction.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan","title":"Tan","text":"<p>               Bases: <code>Statement</code></p> <p>Take the tangent of a number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(PyNum)\n</code></pre> <p>result (float): The tangent of the number.</p>"},{"location":"reference/bloqade/qasm2/dialects/expr/stmts/#bloqade.qasm2.dialects.expr.stmts.Tan.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: SSAValue = argument(PyNum)\n</code></pre> <p>value (Union[int, float]): The number to take the tangent of.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.QubitType","title":"QubitType  <code>module-attribute</code>","text":"<pre><code>QubitType = PyClass(Qubit)\n</code></pre> <p>Kirin type for a qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Barrier","title":"Barrier","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the Barrier statement.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Barrier.qargs","title":"qargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qargs: tuple[SSAValue, ...] = argument(QubitType)\n</code></pre> <p>qargs: tuple of qubits to apply the barrier to.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX","title":"CCX","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the doubly controlled X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX.ctrl1","title":"ctrl1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl1: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl1 (Qubit): The first control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX.ctrl2","title":"ctrl2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl2: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl2 (Qubit): The second control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CCX.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CH","title":"CH","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-H gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRX","title":"CRX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CRX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle to rotate around the X axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU1","title":"CU1","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU3","title":"CU3","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U3 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU3.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CU3.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CX","title":"CX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Alias for the CNOT or CH gate operations.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CY","title":"CY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.CZ","title":"CZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Z gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.H","title":"H","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Hadamard gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RX","title":"RX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around x axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RY","title":"RY","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RY gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RY.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around y axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RZ","title":"RZ","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RZ gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.RZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): the angle of rotation around Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.S","title":"S","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Sdag","title":"Sdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.SingleQubitGate","title":"SingleQubitGate","text":"<p>               Bases: <code>Statement</code></p> <p>Base class for single qubit gates.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.SingleQubitGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit argument.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.T","title":"T","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Tdag","title":"Tdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.TwoQubitCtrlGate","title":"TwoQubitCtrlGate","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.TwoQubitCtrlGate.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.TwoQubitCtrlGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U1","title":"U1","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U2","title":"U2","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U2 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U2.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.U2.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate","title":"UGate","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply A general single qubit unitary gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.UGate.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The theta parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.X","title":"X","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Y","title":"Y","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/#bloqade.qasm2.dialects.uop.Z","title":"Z","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Z gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/emit/","title":"Emit","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Barrier","title":"Barrier","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the Barrier statement.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Barrier.qargs","title":"qargs  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qargs: tuple[SSAValue, ...] = argument(QubitType)\n</code></pre> <p>qargs: tuple of qubits to apply the barrier to.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX","title":"CCX","text":"<p>               Bases: <code>Statement</code></p> <p>Apply the doubly controlled X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.ctrl1","title":"ctrl1  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl1: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl1 (Qubit): The first control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.ctrl2","title":"ctrl2  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl2: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl2 (Qubit): The second control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CCX.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CH","title":"CH","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-H gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRX","title":"CRX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CRX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle to rotate around the X axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU1","title":"CU1","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3","title":"CU3","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-U3 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CU3.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CX","title":"CX","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Alias for the CNOT or CH gate operations.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CY","title":"CY","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.CZ","title":"CZ","text":"<p>               Bases: <code>TwoQubitCtrlGate</code></p> <p>Apply the Controlled-Z gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.H","title":"H","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Hadamard gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RX","title":"RX","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RX gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RX.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around x axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RY","title":"RY","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RY gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RY.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The angle of rotation around y axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZ","title":"RZ","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the RZ gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.RZ.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): the angle of rotation around Z axis.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.S","title":"S","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Sdag","title":"Sdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of S gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SingleQubitGate","title":"SingleQubitGate","text":"<p>               Bases: <code>Statement</code></p> <p>Base class for single qubit gates.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.SingleQubitGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The qubit argument.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.T","title":"T","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Tdag","title":"Tdag","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the hermitian conj of T gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate","title":"TwoQubitCtrlGate","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate.ctrl","title":"ctrl  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>ctrl: SSAValue = argument(QubitType)\n</code></pre> <p>ctrl (Qubit): The control qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.TwoQubitCtrlGate.qarg","title":"qarg  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>qarg: SSAValue = argument(QubitType)\n</code></pre> <p>qarg (Qubit): The target qubit.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U1","title":"U1","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U1 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U1.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2","title":"U2","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the U2 gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.U2.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate","title":"UGate","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply A general single qubit unitary gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.lam","title":"lam  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>lam: SSAValue = argument(PyNum)\n</code></pre> <p>lam (float): The lambda parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.phi","title":"phi  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>phi: SSAValue = argument(PyNum)\n</code></pre> <p>phi (float): The phi parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.UGate.theta","title":"theta  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>theta: SSAValue = argument(PyNum)\n</code></pre> <p>theta (float): The theta parameter.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.X","title":"X","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the X gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Y","title":"Y","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Y gate.</p>"},{"location":"reference/bloqade/qasm2/dialects/uop/stmts/#bloqade.qasm2.dialects.uop.stmts.Z","title":"Z","text":"<p>               Bases: <code>SingleQubitGate</code></p> <p>Apply the Z gate.</p>"},{"location":"reference/bloqade/qasm2/emit/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/emit/base/","title":"Base","text":""},{"location":"reference/bloqade/qasm2/emit/gate/","title":"Gate","text":""},{"location":"reference/bloqade/qasm2/emit/main/","title":"Main","text":""},{"location":"reference/bloqade/qasm2/emit/target/","title":"Target","text":""},{"location":"reference/bloqade/qasm2/parse/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/parse/ast/","title":"Ast","text":""},{"location":"reference/bloqade/qasm2/parse/build/","title":"Build","text":""},{"location":"reference/bloqade/qasm2/parse/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/qasm2/parse/parser/","title":"Parser","text":""},{"location":"reference/bloqade/qasm2/parse/print/","title":"Print","text":""},{"location":"reference/bloqade/qasm2/parse/visitor/","title":"Visitor","text":""},{"location":"reference/bloqade/qasm2/passes/","title":"Index","text":""},{"location":"reference/bloqade/qasm2/passes/parallel/","title":"Parallel","text":""},{"location":"reference/bloqade/qbraid/","title":"Index","text":""},{"location":"reference/bloqade/qbraid/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/qbraid/lowering/#bloqade.qbraid.lowering.Lowering","title":"Lowering  <code>dataclass</code>","text":"<pre><code>Lowering()\n</code></pre>"},{"location":"reference/bloqade/qbraid/lowering/#bloqade.qbraid.lowering.Lowering.lower","title":"lower","text":"<pre><code>lower(sym_name: str, noise_model: schema.NoiseModel)\n</code></pre> <p>Lower the noise model to a method.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the method to generate.</p> required <p>Returns:</p> Name Type Description <code>Method</code> <p>The generated kirin method.</p> Source code in <code>src/bloqade/qbraid/lowering.py</code> <pre><code>def lower(self, sym_name: str, noise_model: schema.NoiseModel):\n    \"\"\"Lower the noise model to a method.\n\n    Args:\n        name (str): The name of the method to generate.\n\n    Returns:\n        Method: The generated kirin method.\n\n    \"\"\"\n    self.process_noise_model(noise_model)\n    block = ir.Block(stmts=self.block_list)\n    block.args.append_from(ir.types.PyClass(ir.Method), name=f\"{sym_name}_self\")\n    region = ir.Region(block)\n    func_stmt = func.Function(\n        sym_name=sym_name,\n        signature=func.Signature(inputs=(), output=qasm2.types.QRegType),\n        body=region,\n    )\n\n    mt = ir.Method(\n        mod=None,\n        py_func=None,\n        sym_name=sym_name,\n        dialects=qbraid_noise,\n        code=func_stmt,\n        arg_names=[],\n    )\n    qbraid_noise.run_pass(mt)\n\n    return mt\n</code></pre>"},{"location":"reference/bloqade/qbraid/schema/","title":"Schema","text":""},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.CZ","title":"CZ","text":"<p>               Bases: <code>Operation</code></p> <p>A CZ gate operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"CZ\"]). participants (Tuple[Union[Tuple[int], Tuple[int, int]], ...]): The qubit indices that are participating in the CZ gate.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.CZError","title":"CZError","text":"<p>               Bases: <code>ErrorOperation[ErrorModelType]</code></p> <p>CZError operation.</p> Fields <p>survival_prob (Tuple[float, ...]): The survival probabilities for each qubit. error_type (str): The type of error (Literal[\"CZError\"]). storage_error (ErrorModelType): The error model for storage. entangled_error (ErrorModelType): The error model for entangled qubits. single_error (ErrorModelType): The error model for single qubits.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.ErrorModel","title":"ErrorModel","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for error models.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.ErrorOperation","title":"ErrorOperation","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <p>Base class for error operations.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.GateEvent","title":"GateEvent","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <p>A gate event.</p> Fields <p>error (Union[SingleQubitError[ErrorModelType], CZError[ErrorModelType]]): The error model for the gate event. operation (OperationType): The operation for the gate event.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.GlobalRz","title":"GlobalRz","text":"<p>               Bases: <code>Operation</code></p> <p>GlobalRz operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"GlobalRz\"]). phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.GlobalW","title":"GlobalW","text":"<p>               Bases: <code>Operation</code></p> <p>GlobalW operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"GlobalW\"]). theta (float): The angle of rotation. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.LocalRz","title":"LocalRz","text":"<p>               Bases: <code>Operation</code></p> <p>LocalRz operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"LocalRz\"]). participants (Tuple[int, ...]): The qubit indices that are participating in the local Rz gate. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.LocalW","title":"LocalW","text":"<p>               Bases: <code>Operation</code></p> <p>LocalW operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"LocalW\"]). participants (Tuple[int, ...]): The qubit indices that are participating in the local W gate. theta (float): The angle of rotation. phi (float): The angle of rotation.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.Measurement","title":"Measurement","text":"<p>               Bases: <code>Operation</code></p> <p>Measurement operation.</p> Fields <p>op_type (str): The type of operation (Literal[\"Measurement\"]). measure_tag (str): The tag to use for the measurement. participants (Tuple[int, ...]): The qubit indices that are participating in the measurement.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel","title":"NoiseModel","text":"<p>               Bases: <code>BaseModel</code>, <code>Generic[ErrorModelType]</code></p> <p>Noise model for a circuit.</p> Fields <p>all_qubits (Tuple[int, ...]): The qubit indices for the noise model. gate_events (List[GateEvent[ErrorModelType]]): The gate events for the noise model.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.num_qubits","title":"num_qubits  <code>property</code>","text":"<pre><code>num_qubits: int\n</code></pre> <p>Return the number of qubits in the noise model.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.decompiled_circuit","title":"decompiled_circuit","text":"<pre><code>decompiled_circuit() -&gt; str\n</code></pre> <p>Clean the circuit of noise.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The decompiled circuit from hardware execution.</p> Source code in <code>src/bloqade/qbraid/schema.py</code> <pre><code>def decompiled_circuit(self) -&gt; str:\n    \"\"\"Clean the circuit of noise.\n\n    Returns:\n        str: The decompiled circuit from hardware execution.\n\n    \"\"\"\n    from kirin import ir\n    from bloqade.noise import native\n    from bloqade.qasm2.emit import QASM2\n\n    mt = self.lower_noise_model(\"method\")\n\n    native.RemoveNoisePass(mt.dialects)(mt)\n    mt.dialects = ir.DialectGroup(\n        mt.dialects.data.symmetric_difference([native.dialect])\n    )\n\n    return QASM2(qelib1=True).emit_str(mt)\n</code></pre>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.NoiseModel.lower_noise_model","title":"lower_noise_model","text":"<pre><code>lower_noise_model(sym_name: str)\n</code></pre> <p>Lower the noise model to a method.</p> <p>Parameters:</p> Name Type Description Default <code>sym_name</code> <code>str</code> <p>The name of the method to generate.</p> required <p>Returns:</p> Name Type Description <code>Method</code> <p>The generated kirin method.</p> Source code in <code>src/bloqade/qbraid/schema.py</code> <pre><code>def lower_noise_model(self, sym_name: str):\n    \"\"\"Lower the noise model to a method.\n\n    Args:\n        sym_name (str): The name of the method to generate.\n\n    Returns:\n        Method: The generated kirin method.\n\n    \"\"\"\n    from bloqade.qbraid.lowering import Lowering\n\n    return Lowering().lower(sym_name, self)\n</code></pre>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.Operation","title":"Operation","text":"<p>               Bases: <code>BaseModel</code></p> <p>Base class for operations.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.PauliErrorModel","title":"PauliErrorModel","text":"<p>               Bases: <code>ErrorModel</code></p> <p>Pauli error model.</p> Fields <p>error_model_type (str): The type of error model (Literal[\"PauliNoise\"]). errors (Tuple[Tuple[int, Tuple[float, float, float]], ...]): The qubit indices and the error rates for each qubit.</p>"},{"location":"reference/bloqade/qbraid/schema/#bloqade.qbraid.schema.SingleQubitError","title":"SingleQubitError","text":"<p>               Bases: <code>ErrorOperation[ErrorModelType]</code></p> <p>SingleQubitError operation.</p> Fields <p>survival_prob (Tuple[float, ...]): The survival probabilities for each qubit. error_type (str): The type of error (Literal[\"SingleQubitError\"]). operator_error (ErrorModelType): The error model for the single qubit.</p>"},{"location":"reference/bloqade/qbraid/simulation_result/","title":"Simulation result","text":""},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult","title":"QuEraSimulationResult  <code>dataclass</code>","text":"<pre><code>QuEraSimulationResult(\n    flair_visual_version: str,\n    counts: dict[str, int],\n    logs: DataFrame,\n    atom_animation_state: vis_qpustate.AnimateQPUState,\n    noise_model: NoiseModel,\n)\n</code></pre> <p>Results of the QuEra hardware model simulation.</p> Fields <p>flair_visual_version (str): The version of the Flair Visual package used to generate the simulation result. counts (dict[str, int]): The measurement bitstrings of the simulation. logs (DataFrame): Grainular logs events of what happened to each atom during the simulation. atom_animation_state (vis_qpustate.AnimateQPUState): Object used to play back atom trajectories and events during the simulation. noise_model (NoiseModel): The noise model used in the simulation.</p>"},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.animate","title":"animate","text":"<pre><code>animate(\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: Optional[int] = None,\n)\n</code></pre> <p>animate the qpu state</p> <p>Parameters:</p> Name Type Description Default <code>dilation_rate</code> <code>float</code> <p>Conversion factor from the qpu time to animation time units. when dilation_rate=1.0, 1 (us) of qpu exec time corresponds to 1 second of animation time.</p> <code>0.05</code> <code>fps</code> <code>int</code> <p>frame per second. Defaults to 30.</p> <code>30</code> <code>gate_display_dilation</code> <code>float</code> <p>relative dilation rate of a gate event. Defaults to 1. When setting higher value, the gate event will be displayed longer.</p> <code>1.0</code> <code>save_mpeg</code> <code>bool</code> <p>Save as mpeg. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>The file name of saved mpeg file. Defaults to \"vqpu_animation\". When <code>save_mpeg</code> is False, this argument is ignored.</p> <code>'vqpu_animation'</code> <code>start_block</code> <code>int</code> <p>The start block to animate. Defaults to 0.</p> <code>0</code> <code>n_blocks</code> <code>int</code> <p>number of blocks to animate. Defaults to None. When None, animate all blocks after <code>start_block</code>.</p> <code>None</code> <p>Returns:     ani: matplotlib animation object</p> Source code in <code>src/bloqade/qbraid/simulation_result.py</code> <pre><code>def animate(\n    self,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: Optional[int] = None,\n):\n    \"\"\"animate the qpu state\n\n    Args:\n        dilation_rate (float): Conversion factor from the qpu time to animation time units. when dilation_rate=1.0, 1 (us) of qpu exec time corresponds to 1 second of animation time.\n        fps (int, optional): frame per second. Defaults to 30.\n        gate_display_dilation (float, optional): relative dilation rate of a gate event. Defaults to 1. When setting higher value, the gate event will be displayed longer.\n        save_mpeg (bool, optional): Save as mpeg. Defaults to False.\n        filename (str, optional): The file name of saved mpeg file. Defaults to \"vqpu_animation\". When `save_mpeg` is False, this argument is ignored.\n        start_block (int, optional): The start block to animate. Defaults to 0.\n        n_blocks (int, optional): number of blocks to animate. Defaults to None. When None, animate all blocks after `start_block`.\n    Returns:\n        ani: matplotlib animation object\n    \"\"\"\n    from bloqade.visual.animation.animate import animate_qpu_state\n\n    ani = animate_qpu_state(\n        state=self.atom_animation_state,\n        dilation_rate=dilation_rate,\n        fps=fps,\n        gate_display_dilation=gate_display_dilation,\n        start_block=start_block,\n        n_blocks=n_blocks,\n        save_mpeg=save_mpeg,\n        filename=filename,\n    )\n    return ani\n</code></pre>"},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.from_json","title":"from_json  <code>classmethod</code>","text":"<pre><code>from_json(json: dict) -&gt; QuEraSimulationResult\n</code></pre> <p>deserialize the object from a JSON serializable dictionary.</p> Source code in <code>src/bloqade/qbraid/simulation_result.py</code> <pre><code>@classmethod\ndef from_json(cls, json: dict) -&gt; \"QuEraSimulationResult\":\n    \"\"\"deserialize the object from a JSON serializable dictionary.\"\"\"\n    flair_visual_version = json[\"flair_visual_version\"]\n    counts = json[\"counts\"]\n    logs = pd.read_csv(StringIO(json[\"logs\"]), index_col=0)\n    atom_animation_state = vis_qpustate.AnimateQPUState.from_json(\n        json[\"atom_animation_state\"]\n    )\n    noise_model = NoiseModel(**json[\"noise_model\"])\n\n    return cls(\n        flair_visual_version=flair_visual_version,\n        counts=counts,\n        logs=logs,\n        atom_animation_state=atom_animation_state,\n        noise_model=noise_model,\n    )\n</code></pre>"},{"location":"reference/bloqade/qbraid/simulation_result/#bloqade.qbraid.simulation_result.QuEraSimulationResult.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; Dict[str, Any]\n</code></pre> <p>Turn the object into a JSON serializable dictionary.</p> Source code in <code>src/bloqade/qbraid/simulation_result.py</code> <pre><code>def to_json(self) -&gt; Dict[str, Any]:\n    \"\"\"Turn the object into a JSON serializable dictionary.\"\"\"\n    return {\n        \"flair_visual_version\": self.flair_visual_version,\n        \"counts\": self.counts,\n        \"logs\": self.logs.to_csv(),\n        \"atom_animation_state\": self.atom_animation_state.to_json(),\n        \"noise_model\": self.noise_model.model_dump(mode=\"json\"),\n    }\n</code></pre>"},{"location":"reference/bloqade/qbraid/target/","title":"Target","text":""},{"location":"reference/bloqade/stim/","title":"Index","text":""},{"location":"reference/bloqade/stim/#bloqade.stim.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int, property=True)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String, property=True)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/#bloqade.stim.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/#bloqade.stim.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/groups/","title":"Groups","text":""},{"location":"reference/bloqade/stim/dialects/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int, property=True)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String, property=True)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/#bloqade.stim.dialects.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/aux/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int, property=True)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String, property=True)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/#bloqade.stim.dialects.aux.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/dialects/aux/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/aux/interp/","title":"Interp","text":""},{"location":"reference/bloqade/stim/dialects/aux/lowering/","title":"Lowering","text":""},{"location":"reference/bloqade/stim/dialects/aux/types/","title":"Types","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/annotate/","title":"Annotate","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/","title":"Const","text":""},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstBool","title":"ConstBool","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstBool.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Bool)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstBool.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: bool = attribute(Bool, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstFloat","title":"ConstFloat","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstFloat.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Float)\n</code></pre> <p>result (Float): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstFloat.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: float = attribute(Float, property=True)\n</code></pre> <p>value (float): The constant float value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstInt","title":"ConstInt","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstInt.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(Int)\n</code></pre> <p>result (Int): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstInt.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: int = attribute(Int, property=True)\n</code></pre> <p>value (int): The constant integer value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstStr","title":"ConstStr","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstStr.result","title":"result  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>result: ResultValue = result(String)\n</code></pre> <p>result (str): The result value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.ConstStr.value","title":"value  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>value: str = attribute(String, property=True)\n</code></pre> <p>value (str): The constant str value.</p>"},{"location":"reference/bloqade/stim/dialects/aux/stmts/const/#bloqade.stim.dialects.aux.stmts.const.Neg","title":"Neg","text":"<p>               Bases: <code>Statement</code></p> <p>IR Statement representing a negation operation.</p>"},{"location":"reference/bloqade/stim/dialects/collapse/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/collapse/#bloqade.stim.dialects.collapse.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/collapse/#bloqade.stim.dialects.collapse.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/collapse/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/measure/","title":"Measure","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/measure/#bloqade.stim.dialects.collapse.stmts.measure.Measurement","title":"Measurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/measure/#bloqade.stim.dialects.collapse.stmts.measure.Measurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/pp_measure/","title":"Pp measure","text":""},{"location":"reference/bloqade/stim/dialects/collapse/stmts/pp_measure/#bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement","title":"PPMeasurement","text":"<p>               Bases: <code>Statement</code></p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/pp_measure/#bloqade.stim.dialects.collapse.stmts.pp_measure.PPMeasurement.p","title":"p  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>p: SSAValue = argument(Float)\n</code></pre> <p>probability of noise introduced by measurement. For example 0.01 means 1% the measurement will be flipped</p>"},{"location":"reference/bloqade/stim/dialects/collapse/stmts/reset/","title":"Reset","text":""},{"location":"reference/bloqade/stim/dialects/gate/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/gate/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/base/","title":"Base","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/clifford_1q/","title":"Clifford 1q","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/clifford_2q/","title":"Clifford 2q","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/control_2q/","title":"Control 2q","text":""},{"location":"reference/bloqade/stim/dialects/gate/stmts/pp/","title":"Pp","text":""},{"location":"reference/bloqade/stim/dialects/noise/","title":"Index","text":""},{"location":"reference/bloqade/stim/dialects/noise/emit/","title":"Emit","text":""},{"location":"reference/bloqade/stim/dialects/noise/stmts/","title":"Stmts","text":""},{"location":"reference/bloqade/stim/emit/","title":"Index","text":""},{"location":"reference/bloqade/stim/emit/stim/","title":"Stim","text":""},{"location":"reference/bloqade/stim/passes/","title":"Index","text":""},{"location":"reference/bloqade/stim/passes/simplify/","title":"Simplify","text":""},{"location":"reference/bloqade/visual/","title":"Index","text":""},{"location":"reference/bloqade/visual/animation/","title":"Index","text":""},{"location":"reference/bloqade/visual/animation/animate/","title":"Animate","text":""},{"location":"reference/bloqade/visual/animation/animate/#bloqade.visual.animation.animate.animate_qpu_state","title":"animate_qpu_state","text":"<pre><code>animate_qpu_state(\n    state: QPUStateABC,\n    display_fov: Optional[FieldOfView] = None,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    fig_args={},\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: int | None = None,\n)\n</code></pre> <p>Generate an animation from the QPU state</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>QPUStateABC</code> <p>The QPU state to animate</p> required <code>display_fov</code> <code>Optional[FieldOfView]</code> <p>The field of view to display. Defaults to None. If None, it will use the QPU's field of view.</p> <code>None</code> <code>dilation_rate</code> <code>float</code> <p>The rate at which to dilate the time. Defaults to 0.05.</p> <code>0.05</code> <code>fps</code> <code>int</code> <p>The frames per second. Defaults to 30.</p> <code>30</code> <code>gate_display_dilation</code> <code>float</code> <p>The rate at which to dilate the gate display. Defaults to 1.0.</p> <code>1.0</code> <code>fig_args</code> <code>dict</code> <p>The arguments to pass to the matplotlib.pyplot.figure. Defaults to {}.</p> <code>{}</code> <code>save_mpeg</code> <code>bool</code> <p>Whether to save the animation as an mpeg. Defaults to False.</p> <code>False</code> <code>filename</code> <code>str</code> <p>The filename to save the mpeg as. Defaults to \"vqpu_animation\".</p> <code>'vqpu_animation'</code> <code>start_block</code> <code>int</code> <p>The block to start the animation at. Defaults to 0.</p> <code>0</code> <code>n_blocks</code> <code>int | None</code> <p>The number of blocks to animate. Defaults to None. If None, it will animate all blocks after <code>start_block</code>.</p> <code>None</code> Source code in <code>src/bloqade/visual/animation/animate.py</code> <pre><code>def animate_qpu_state(\n    state: QPUStateABC,\n    display_fov: Optional[FieldOfView] = None,\n    dilation_rate: float = 0.05,\n    fps: int = 30,\n    gate_display_dilation: float = 1.0,\n    fig_args={},\n    save_mpeg: bool = False,\n    filename: str = \"vqpu_animation\",\n    start_block: int = 0,\n    n_blocks: int | None = None,\n):\n    \"\"\"Generate an animation from the QPU state\n\n    Args:\n        state (QPUStateABC): The QPU state to animate\n        display_fov (Optional[FieldOfView], optional): The field of view to display. Defaults to None. If None, it will use the QPU's field of view.\n        dilation_rate (float, optional): The rate at which to dilate the time. Defaults to 0.05.\n        fps (int, optional): The frames per second. Defaults to 30.\n        gate_display_dilation (float, optional): The rate at which to dilate the gate display. Defaults to 1.0.\n        fig_args (dict, optional): The arguments to pass to the matplotlib.pyplot.figure. Defaults to {}.\n        save_mpeg (bool, optional): Whether to save the animation as an mpeg. Defaults to False.\n        filename (str, optional): The filename to save the mpeg as. Defaults to \"vqpu_animation\".\n        start_block (int, optional): The block to start the animation at. Defaults to 0.\n        n_blocks (int | None, optional): The number of blocks to animate. Defaults to None. If None, it will animate all blocks after `start_block`.\n\n    \"\"\"\n    qpu_fov = state.qpu_fov\n\n    if display_fov is None:\n        display_fov = qpu_fov\n\n    if start_block &gt;= len(state.block_durations) or start_block &lt; 0:\n        raise ValueError(\"Start block index is out of range\")\n\n    if n_blocks is None:\n        n_blocks = len(state.block_durations) - start_block\n\n    if n_blocks &lt; 0:\n        raise ValueError(\"Number of block to animate must be non-negative\")\n\n    slm_sites = state.get_slm_sites()\n\n    # Scale the figure to different screens and so that the number of SLM sites has the same\n    # \"area\" on screen\n    nsites = max([4, len(slm_sites)])\n    scale = (\n        np.sqrt(44.0 / nsites) * 2.0 * plt.rcParams[\"figure.dpi\"] / 100\n    )  # scale the size of the figure\n\n    # figure:\n    new_fig_args = {\"figsize\": (14, 8), **fig_args}\n    fig, mpl_axs = plt.subplot_mosaic(\n        mosaic=[[\"Reg\", \"Info\"], [\"Reg\", \"Gate\"], [\"Reg\", \"Gate\"]],\n        gridspec_kw={\"width_ratios\": [3, 1]},\n        **new_fig_args,\n    )\n\n    # mpl_axs[\"Reg\"].axis(\"equal\")  # Axis equal must come before axis limits\n    mpl_axs[\"Reg\"].set_xlim(left=display_fov.xmin, right=display_fov.xmax)\n    mpl_axs[\"Reg\"].set_ylim(bottom=display_fov.ymin, top=display_fov.ymax)\n    mpl_axs[\"Reg\"].set(xlabel=\"x (um)\", ylabel=\"y (um)\")\n    mpl_axs[\"Reg\"].set_aspect(\"equal\")\n\n    # slm:\n    slm_plt_arg = {\n        \"facecolors\": \"none\",\n        \"edgecolors\": \"k\",\n        \"linestyle\": \"-\",\n        \"s\": 80 * scale,\n        \"alpha\": 0.3,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    mpl_axs[\"Reg\"].scatter(\n        x=slm_sites[:, 0], y=slm_sites[:, 1], **slm_plt_arg\n    )  # this is statically generated, so it will be the background\n\n    # atoms:\n    reg_plt_arg = {\n        \"s\": 65 * scale,\n        \"marker\": \"o\",\n        \"facecolors\": quera_color_code.purple,\n        \"alpha\": 1.0,\n    }\n    reg_panel = mpl_axs[\"Reg\"]\n    reg_scat = reg_panel.scatter([], [], **reg_plt_arg)\n\n    # gates:\n    gp = GatePainter(mpl_ax=reg_panel, qpu_fov=qpu_fov, scale=scale)\n\n    # annotate_args = {\"fontsize\": 8, \"ha\": \"center\", \"alpha\": 0.7, \"color\": quera_color_code.yellow}\n    annotate_args = {\n        \"fontsize\": 6 * np.sqrt(scale),\n        \"ha\": \"center\",\n        \"va\": \"center\",\n        \"alpha\": 1.0,\n        \"color\": quera_color_code.yellow,\n        \"weight\": \"bold\",\n    }\n    reg_annot_list = [\n        reg_panel.annotate(f\"{i}\", atom_position, **annotate_args)\n        for i, atom_position in state.get_atoms_position(time=0.0, include_lost=False)\n    ]\n\n    # AODs:\n    aod_plot_args = {\n        \"s\": 260 * scale,\n        \"marker\": \"+\",\n        \"alpha\": 0.7,\n        \"facecolors\": quera_color_code.red,\n        \"zorder\": -100,\n        \"linewidth\": np.sqrt(scale),\n    }\n    aod_scat = reg_panel.scatter(x=[], y=[], **aod_plot_args)\n\n    aod_h_args = {\n        \"s\": 1e20,\n        \"marker\": \"|\",\n        \"alpha\": 1.0,\n        \"color\": \"#FFE8E9\",\n        \"zorder\": -101,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    aod_h_scat = reg_panel.scatter(x=[], y=[], **aod_h_args)\n    aod_v_args = {\n        \"s\": 1e20,\n        \"marker\": \"_\",\n        \"alpha\": 1.0,\n        \"color\": \"#FFE8E9\",\n        \"zorder\": -101,\n        \"linewidth\": 0.5 * np.sqrt(scale),\n    }\n    aod_v_scat = reg_panel.scatter(x=[], y=[], **aod_v_args)\n\n    ## Info Panel\n    info_text = mpl_axs[\"Info\"].text(x=0.05, y=0.5, s=\"\")\n    mpl_axs[\"Info\"].set_xticks([])\n    mpl_axs[\"Info\"].set_yticks([])\n    mpl_axs[\"Info\"].grid(False)\n\n    ## Event Panel:\n    log_text = mpl_axs[\"Gate\"].text(x=0.05, y=0.0, s=\"\", size=6)\n    mpl_axs[\"Gate\"].set_xticks([])\n    mpl_axs[\"Gate\"].set_yticks([])\n    mpl_axs[\"Gate\"].grid(False)\n\n    tstep_mv = 1.0 / (fps * dilation_rate)\n    tstep_gate = 1.0 / (fps * dilation_rate * gate_display_dilation)\n    blk_t_end = np.cumsum(state.block_durations)\n\n    # determine the dilation part of the timeline, and generate more frame\n    chunk_times = []\n    curr_t = 0 if start_block == 0 else blk_t_end[start_block - 1]\n\n    for glb_tstart_gate, duration in state.get_gate_events_timing():\n        if glb_tstart_gate &lt; curr_t:  # gate start before the current time\n            if glb_tstart_gate + duration &lt; curr_t:\n                continue\n        else:\n            dt = glb_tstart_gate - curr_t\n            chunk_times.append(np.linspace(curr_t, glb_tstart_gate, int(dt / tstep_mv)))\n            curr_t = glb_tstart_gate\n\n        t_gate_end = glb_tstart_gate + duration\n        dt = t_gate_end - curr_t\n        chunk_times.append(np.linspace(curr_t, t_gate_end, int(dt / tstep_gate)))\n        curr_t = t_gate_end\n\n    dt = blk_t_end[-1] - curr_t\n    chunk_times.append(np.linspace(curr_t, blk_t_end[-1], int(dt / tstep_mv)))\n\n    times = np.concatenate(chunk_times)\n\n    fig.tight_layout()\n    fig.subplots_adjust(wspace=0.1)\n\n    def _update_annotate(loc, idx, annotate_artist):\n        new_loc = (loc[0], loc[1] - 0.06)\n        annotate_artist.set_position(new_loc)\n        txt = f\"{idx}\"\n        annotate_artist.set_text(txt)\n        return loc\n\n    def update(frame: int, state: QPUStateABC, times: np.ndarray, blk_t_end: np.array):\n\n        # get positions:\n\n        blk_id = bisect.bisect_left(blk_t_end, times[frame])\n        lbl = f\"Block: [{blk_id}]\\n\"\n        lbl += f\"Block dur: {state.block_durations[blk_id]:.2f} us\\n\"\n        lbl += f\"Total elapsed time: {times[frame]:.2f} us\"\n        info_text.set_text(lbl)\n\n        # update atoms location and annotation\n        post = np.array(\n            [\n                _update_annotate(\n                    atom_position,\n                    i,\n                    reg_annot_list[i],\n                )\n                for i, atom_position in state.get_atoms_position(\n                    times[frame], include_lost=False\n                )\n            ]\n        )\n        post = post if post.size &gt; 0 else np.array([(None, None)])\n        reg_scat.set_offsets(post)\n\n        # update log event panels\n        lost_events = state.get_atoms_lost_info(times[frame])\n\n        # update log gate:\n        gate_events = state.get_gate_events(times[frame])\n        gate_events_log = [\n            f\"Gate: {gate.cls_name} @ {t:.6f} (us)\\n\"\n            for t, gate in state.get_gate_events(times[frame])\n        ]\n        log_text.set_text(\"\".join(lost_events) + \"\".join(gate_events_log))\n\n        gate_artists = gp.process_gates([gate for _, gate in gate_events])\n\n        # update AODs\n        post = state.sample_aod_traps(times[frame]) or [(None, None)]\n        aod_scat.set_offsets(post)\n        aod_v_scat.set_offsets(post)\n        aod_h_scat.set_offsets(post)\n\n        return (\n            [reg_scat, info_text, log_text, aod_scat, aod_v_scat, aod_h_scat]\n            + reg_annot_list\n            + gate_artists\n        )\n\n    ani = FuncAnimation(\n        fig=fig,\n        func=functools.partial(update, state=state, times=times, blk_t_end=blk_t_end),\n        frames=len(times),\n        interval=tstep_mv,\n        blit=True,\n        repeat=False,\n    )\n    if save_mpeg:\n        n_frame = len(times)\n        pbar = tqdm.tqdm(range(n_frame))\n\n        def p_call_back(i, total_n):\n            pbar.update()\n\n        ani.save(\n            f\"{filename}.mp4\", writer=\"ffmpeg\", fps=fps, progress_callback=p_call_back\n        )\n    else:\n        return ani\n</code></pre>"},{"location":"reference/bloqade/visual/animation/base/","title":"Base","text":""},{"location":"reference/bloqade/visual/animation/base/#bloqade.visual.animation.base.RowRegionGateArtist","title":"RowRegionGateArtist  <code>dataclass</code>","text":"<pre><code>RowRegionGateArtist(\n    mpl_ax: Any,\n    xmin,\n    width,\n    ymin,\n    ymin_keepout,\n    ymax,\n    ymax_keepout,\n    color,\n)\n</code></pre> <p>               Bases: <code>GateArtist</code></p> <p>A row region gate artist object.</p> <p>bound box is [y_origin - width/2, y_origin + width/2]</p> Source code in <code>src/bloqade/visual/animation/base.py</code> <pre><code>def __init__(\n    self, mpl_ax: Any, xmin, width, ymin, ymin_keepout, ymax, ymax_keepout, color\n):\n    super().__init__(mpl_ax)\n    self.width = width\n    self.xmin = xmin\n    rc_btm = mpatches.Rectangle(\n        [xmin, ymin_keepout],\n        width,\n        ymin - ymin_keepout,\n        color=color,\n        alpha=0.3,\n        visible=False,\n    )\n    mpl_ax.add_patch(rc_btm)\n    self.mpl_obj_keepout_btm = rc_btm\n\n    rc = mpatches.Rectangle(\n        [xmin, ymin], width, ymax - ymin, color=color, alpha=0.6, visible=False\n    )\n    mpl_ax.add_patch(rc)\n    self.mpl_obj = rc\n\n    rc_top = mpatches.Rectangle(\n        [xmin, ymax],\n        width,\n        ymax_keepout - ymax,\n        color=color,\n        alpha=0.3,\n        visible=False,\n    )\n    mpl_ax.add_patch(rc_top)\n    self.mpl_obj_keepout_top = rc_top\n</code></pre>"},{"location":"reference/bloqade/visual/animation/gate_event/","title":"Gate event","text":""},{"location":"reference/bloqade/visual/animation/runtime/","title":"Index","text":""},{"location":"reference/bloqade/visual/animation/runtime/aod/","title":"Aod","text":""},{"location":"reference/bloqade/visual/animation/runtime/atoms/","title":"Atoms","text":""},{"location":"reference/bloqade/visual/animation/runtime/ppoly/","title":"Ppoly","text":""},{"location":"reference/bloqade/visual/animation/runtime/qpustate/","title":"Qpustate","text":""},{"location":"reference/bloqade/visual/animation/runtime/utils/","title":"Utils","text":""},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Generate the code reference pages and navigation.\"\"\"\n</pre> \"\"\"Generate the code reference pages and navigation.\"\"\" In\u00a0[\u00a0]: Copied! <pre>from pathlib import Path\n</pre> from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>SRC_PATH = \"src\"\n</pre> SRC_PATH = \"src\" In\u00a0[\u00a0]: Copied! <pre>skip_keywords = [\n    \"julia\",  ## [KHW] skip for now since we didn't have julia codegen rdy\n    \"builder/base\",  ## hiding from user\n    \"builder/terminate\",  ## hiding from user\n    \"ir/tree_print\",  ## hiding from user\n    \"ir/visitor\",  ## hiding from user\n    \"codegen/\",  ## hiding from user\n    \"builder/factory\",  ## hiding from user\n    \"builder_old\",  ## deprecated from user\n    \"task_old\",  ## deprecated from user\n    \"visualization\",  ## hiding from user\n    \"submission/capabilities\",  ## hiding from user\n    \"submission/quera_api_client\",\n]\n</pre> skip_keywords = [     \"julia\",  ## [KHW] skip for now since we didn't have julia codegen rdy     \"builder/base\",  ## hiding from user     \"builder/terminate\",  ## hiding from user     \"ir/tree_print\",  ## hiding from user     \"ir/visitor\",  ## hiding from user     \"codegen/\",  ## hiding from user     \"builder/factory\",  ## hiding from user     \"builder_old\",  ## deprecated from user     \"task_old\",  ## deprecated from user     \"visualization\",  ## hiding from user     \"submission/capabilities\",  ## hiding from user     \"submission/quera_api_client\", ] In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nfor path in sorted(Path(SRC_PATH).rglob(\"*.py\")):\n    module_path = path.relative_to(SRC_PATH).with_suffix(\"\")\n    doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    iskip = False\n\n    for kwrd in skip_keywords:\n        if kwrd in str(doc_path):\n            iskip = True\n            break\n    if iskip:\n        print(\"[Ignore]\", str(doc_path))\n        continue\n\n    print(\"[&gt;]\", str(doc_path))\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1].startswith(\"_\"):\n        continue\n\n    nav[parts] = doc_path.as_posix()\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path)\n</pre> nav = mkdocs_gen_files.Nav() for path in sorted(Path(SRC_PATH).rglob(\"*.py\")):     module_path = path.relative_to(SRC_PATH).with_suffix(\"\")     doc_path = path.relative_to(SRC_PATH).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      iskip = False      for kwrd in skip_keywords:         if kwrd in str(doc_path):             iskip = True             break     if iskip:         print(\"[Ignore]\", str(doc_path))         continue      print(\"[&gt;]\", str(doc_path))      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1].startswith(\"_\"):         continue      nav[parts] = doc_path.as_posix()     with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\")      mkdocs_gen_files.set_edit_path(full_doc_path, \"..\" / path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"},{"location":"blog/archive/2025/","title":"2025","text":""},{"location":"blog/archive/2023/","title":"2023","text":""}]}